<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raptor&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raptor1998.top/"/>
  <updated>2022-09-25T03:31:30.915Z</updated>
  <id>http://raptor1998.top/</id>
  
  <author>
    <name>陳 ？</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ByteDance Month 3</title>
    <link href="http://raptor1998.top/2022/09/16/ByteDance7/"/>
    <id>http://raptor1998.top/2022/09/16/ByteDance7/</id>
    <published>2022-09-15T16:00:00.000Z</published>
    <updated>2022-09-25T03:31:30.915Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="测开的理解"><a href="#测开的理解" class="headerlink" title="测开的理解"></a>测开的理解</h1><p>针对于被问的最多的就是，为什么选择做测开，实习的时候确实没想过，一心奔着字节就来了，其他厂的开发offer没去</p><p>首先根据自身实习经历，感觉测开更像是一个贯穿项目始终的督促和保障人员，首先从项目立项开始，和PM和RD review需求文档，继而开始测试用例，查漏补缺，然后在开发的过程中不断的发现风险点，及时暴露出来，最终提测之后开始着手测试工作，包括功能、自动化、性能、兼容等等，最终项目上线小流量观测，感觉测开的角色贯穿整个过程中，而不是之前理解的单纯等研发写完了，测测功能，然后撒手；测开的日常也有一些开发符合业务测试工具的工作，包括环境治理等</p><p>在和百度的三面老哥沟通的时候，问测开的发展前景，得到的答复是发展到工具产品化，从团队影响到公司，再到全行业，这时候要做的就多了，产品、运营等等，前景听起来还是可以的</p><h1 id="字节氛围"><a href="#字节氛围" class="headerlink" title="字节氛围"></a>字节氛围</h1><p>对于我当前所在的组，其实氛围是很好的，和大家相处的都很融洽，每个人都很耐心的解答问题，平时生活中的话题也能聊的上来，所以我还是很喜欢这个氛围的</p><h1 id="润了"><a href="#润了" class="headerlink" title="润了"></a>润了</h1><p>八月中旬，根据上一个实习一年的实习生沟通过后，得知没有hc，又跟ld沟通之后，告知确实没有，随即就开始重新拾起八股，刚好有十天左右的空档，属于是带薪复习了，投了一波测开，没想到反馈率出奇的高，出了快手简历挂，其余四家全约面了</p><ul><li><p>开水团</p><p>感谢收留，流程飞速，直接给了意向，算是稳定了一下军心</p><p>一面大多是基础八股文，没什么阻塞点；二面省去了自我介绍，让我打开美团app，退出到登录界面，分别从前后端角度去出技术方案；然后再从测试角度执行测试计划；手撕  力扣  1539  必须logn</p></li><li><p>小米一面挂</p><p>没有八股，面试官首先介绍了下手机的测试流程和他们负责的通信模块，我一个字没听懂，然后就成闲聊了，确实不懂手机测试，象征性的聊了半小时  然后G</p></li><li><p>360未知</p><p>也是一些基础问题，但是感觉对我没啥取代，简单问了几个，然后没答上来，手撕一道快排，草草结束</p></li><li><p>百度</p><p>一面纯基础，基础到怀疑自己听错了，基本数据类型，mysql增删改查语句，手撕1 ~ n 中，1出现的次数，linux和安卓的知识没答出来</p><p>二面老哥非常实在，说不问花里胡哨的，没有意义，基础的会能干活就行，手撕一道大数的加减乘除（没出）；问了linux下一个类似表格的文件，取出第二列用什么命令，可以，由不会，然后让我java实现，我说了一下思路，又没写了。。。最后还让手撕一个翻转单词，说了下思路，说也不用写了</p><p>三面问的就是比较大的方向问题了，比如字节的自动化测试框架怎么实现，哪些功能，调试等，然后就是一些项目介绍，本科的经历等等</p></li></ul><p>难定，至此，八月底投的测开全约了，but，投的研发岗基本没消息，只能继续等了，押宝华子</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"hotkey":true,"preload":"metadata","video":{"url":"https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220920153959.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> </body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志</title>
    <link href="http://raptor1998.top/2022/08/23/mysql-%E6%97%A5%E5%BF%97/"/>
    <id>http://raptor1998.top/2022/08/23/mysql-%E6%97%A5%E5%BF%97/</id>
    <published>2022-08-22T16:00:00.000Z</published>
    <updated>2022-08-23T12:38:23.664Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body></body></html>]]></content>
    
    <summary type="html">
    
      desc
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="MySQL" scheme="http://raptor1998.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>项目相关的问题</title>
    <link href="http://raptor1998.top/2022/08/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98(1)/"/>
    <id>http://raptor1998.top/2022/08/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98(1)/</id>
    <published>2022-08-22T16:00:00.000Z</published>
    <updated>2022-08-24T13:43:59.598Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h3 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h3><ol><li>实例化Bean：通过反射调用构造方法实例化对象。</li><li>依赖注入：装配Bean的属性</li><li>实现了Aware接口的Bean，执行接口方法：如顺序执行BeanNameAware、BeanFactoryAware、 ApplicationContextAware的接口方法。</li><li>Bean对象初始化前，循环调用实现了BeanPostProcessor接口的预初始化方法 （postProcessBeforeInitialization）</li><li>Bean对象初始化：顺序执行@PostConstruct注解方法、InitializingBean接口方法、init-method方法</li><li>Bean对象初始化后，循环调用实现了BeanPostProcessor接口的后初始化方法 （postProcessAfterInitialization）</li><li>容器关闭时，执行Bean对象的销毁方法，顺序是：@PreDestroy注解方法、DisposableBean接口方法、destroy-method</li></ol><h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><p>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。<br>为 A 创建一个 Bean工厂，并放入到 singletonFactories 中。<br>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。<br>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。<br>为 B 创建一个 Bean工厂，并放入到 singletonFactories 中。<br>发现 B 需要注入 A 对象，此时在一级、二级未发现对象<br>A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A<br>还是一个半成品，并没有完成属性填充和执行初始化方法）<br>将对象 A 注入到对象 B 中。<br>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）<br>对象 A 得到对象B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）<br>对象 A完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</p><h3 id="sync锁升级"><a href="#sync锁升级" class="headerlink" title="sync锁升级"></a>sync锁升级</h3><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p><h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><p>Web测试主要从下面几个大方向考虑</p><p>功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等</p><p>性能测试，考虑连接速度测试，以及负载测试，例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？还有压力测试</p><p>可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等</p><p>兼容性测试，市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试。</p><p>安全性测试，</p><p>（1）现在的Web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。</p><p>（2）Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。</p><p>（3）为了保证Web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。</p><p>（4）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。</p><p>（5）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。</p><h3 id="临平"><a href="#临平" class="headerlink" title="临平"></a>临平</h3><h4 id="关于本地事务和mq的使用"><a href="#关于本地事务和mq的使用" class="headerlink" title="关于本地事务和mq的使用"></a>关于本地事务和mq的使用</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><ul><li><p>step1：开启本地事务</p></li><li><p>step2：生成购物订单</p></li><li><p>step3：投递消息到mq</p></li><li><p>step4：提交本地事务</p></li></ul><p>这种方式是将发送消息放在了事务提交之前。</p><p><strong>可能存在的问题</strong></p><p>step3发生异常：导致step4失败，商品下单失败，直接影响到商品下单业务</p><p>step4发生异常，其他step成功：商品下单失败，消息投递成功，给用户增加了积分</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>下面我们换种方式，我们将发送消息放到事务之后进行。</p><ul><li>step1：开启本地事务</li><li>step2：生成购物订单</li><li>step3：提交本地事务</li><li>step4：投递消息到mq</li></ul><p>step4发生异常，其他step成功：导致商品下单成功，投递消息失败，用户未增加积分</p><p>上面两种是比较常见的做法，也是最容易出错的。</p><h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><ul><li>step1：开启本地事务</li><li>step2：生成购物订单</li><li>step3：本地库中插入一条需要发送消息的记录t_msg_record</li><li>step3：提交本地事务</li><li>step5：新增一个定时器，轮询t_msg_record，将待发送的记录投递到mq中</li></ul><p>这种方式借助了数据库的事务，业务和消息记录作为了一个原子操作，业务成功之后，消息日志必定是存在的。解决了前两种方式遇到的问题。如果我们的业务系统比较单一，可以采用这种方式。</p><p>对于微服务化的情况，上面这种方式不是太好，每个服务都需要上面的操作；也不利于扩展。</p><h5 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h5><p>增加一个消息服务及消息库，负责消息的落库、将消息发送投递到mq。</p><ul><li>step1：开启本地事务</li><li>step2：生成购物订单</li><li>step3：当前事务库插入一条日志：生成一个唯一的业务id（msg_order_id），将msg_order_id和订单关联起来保存到当前事务所在的库中</li><li>step4：调用消息服务：携带msg_order_id，将消息先落地入库，此时消息的状态为待发送状态，返回消息id(msg_id)</li><li>step5：提交本地事务</li><li>step6：如果上面都成功，调用消息服务，将消息投递到mq中；如果上面有失败的情况，则调用消息服务取消消息的发送</li></ul><p>能想到上面这种方式，已经算是有很大进步了，我们继续分析一下可能存在的问题：</p><p>系统中增加了一个消息服务，商品下单操作依赖于该服务，业务对该服务依赖性比较高，当消息服务不可用时，整个业务将不可用。</p><p>若step6失败，消息将处于待发送状态，此时业务方需要提供一个回查接口（通过msg_order_id查询）,验证业务是否执行成功；消息服务需新增一个定时任务，对于状态为待发送状态的消息做补偿处理，检查一下业务是否处理成功；从而确定消息是投递还是取消发送</p><p>step4依赖于消息服务，如果消息服务性能不佳，会导致当前业务的事务提交时间延长，容易产生死锁，并导致并发性能降低。我们通常是比较忌讳在事务中做远程调用处理的，远程调用的性能和时间往往不可控，会导致当前事务变为一个大事务，从而引发其他故障。</p><h5 id="方式五"><a href="#方式五" class="headerlink" title="方式五"></a>方式五</h5><p>在以上方式中，我们继续改进，进而出现了更好的一种方式：</p><ul><li><p>step1：生成一个全局唯一业务消息id（bus_msg_id)，调用消息服务，携带bus_msg_id，将消息先落地入库，此时消息的状态为待发送状态，返回消息id（msg_id）</p></li><li><p>step2：开启本地事务</p></li><li><p>step3：生成购物订单</p></li><li><p>step4：当前事务库插入一条日志（将step3中的业务和bus_msg_id关联起来）</p></li><li><p>step5：提交本地事务</p></li><li><p>step6：分2种情况：如果上面都成功，调用消息服务，将消息投递到mq中；如果上面有失败的情况，则调用消息服务取消消息的发送</p></li></ul><p>  若step6失败，消息将处于待发送状态，此时业务方需要提供一个回查接口（通过bus_msg_id查询）,验证业务是否执行成功；</p><p>消息服务需新增一个定时任务，对于状态为待发送状态的消息做补偿处理，检查一下业务是否处理成功；从而确定消息是投递还是取消发送。</p><p>方式五和方式四对比，比较好的一个地方：将调用消息服务，消息落地操作，放在了事务之外进行，这点小的改进其实算是一个非常好的优化，减少了本地事务的执行时间，从而可以提升并发量，阿里有个消息中间件RocketMQ就支持方式5这种，大家可以去用用。</p><h4 id="另一种方案"><a href="#另一种方案" class="headerlink" title="另一种方案"></a>另一种方案</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111604.png" data-fancybox="group" data-caption="image-20220325140442199" class="fancybox"><img alt="image-20220325140442199" title="image-20220325140442199" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111604.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="消息的可靠性"><a href="#消息的可靠性" class="headerlink" title="消息的可靠性"></a>消息的可靠性</h4><h5 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h5><ul><li>消息发送出去，由于网络问题没有抵达服务器<ul><li>做好容错方法(try-catch)，发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</li><li>做好日志记录，每个消息状态是否都被服务器收到都应该记录</li><li>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</li></ul></li><li>消息抵达Broker，Broker要将消息写入磁盘(持久化)才算成功。此时Broker尚未持久化完成，宕机.<ul><li>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</li></ul></li><li>自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机<ul><li>一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</li></ul></li></ul><h5 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h5><ul><li>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者</li><li>消息消费失败，由于重试机制，自动又将消息发送出去</li><li>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送<ul><li>消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志</li><li>使用防重表（redis/mysql)，发送消息每一个都有业务的唯一标识，处理过就不用处理</li><li>rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</li></ul></li></ul><h5 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h5><ul><li>消费者宕机积压</li><li>消费者消费能力不足宕机</li><li>发送者发送流量太大<ul><li>上线更多的消费者，进行正常消费</li><li>上线专门的队列消费服务，将消息先批量的取出来，记录数据库，离线慢慢处理</li></ul></li></ul><h3 id="选课"><a href="#选课" class="headerlink" title="选课"></a>选课</h3><h4 id="关于redis的分布式锁"><a href="#关于redis的分布式锁" class="headerlink" title="关于redis的分布式锁"></a>关于redis的分布式锁</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">synchronized (this)</span><br><span class="line">1. 在分布式环境下  多个jvm  进程级别锁</span><br><span class="line">Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "lalal");</span><br><span class="line">stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);</span><br><span class="line">stringRedisTemplate.delete(lockKey);</span><br><span class="line">1. 进程执行到  设置过期时间, 服务挂掉，则无法解锁</span><br><span class="line">2. 若A需要执行 15s, 代码未执行完成，锁过期，则后续请求B进入，加B锁，5s后，A执行到删除锁，删掉B加的锁</span><br><span class="line">    同理，C进来，上锁，B此时执行了5s，  套娃下去，总会出现，多个请求，同时在做库存相关操作</span><br><span class="line">String clientId = UUID.randomUUID().toString();</span><br><span class="line">if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) {</span><br><span class="line">        stringRedisTemplate.delete(lockKey);</span><br><span class="line">    }</span><br><span class="line">1. 引入进程识别，只能删除我自己加的锁</span><br><span class="line"></span><br><span class="line">在主线程处理业务逻辑时，开辟新的timer线程，强行为locakKey续命，最好设置为过期时间的1/3</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618786.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618786.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h4><ul><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li><li>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h4 id="接口的幂等性问题及解决方案"><a href="#接口的幂等性问题及解决方案" class="headerlink" title="接口的幂等性问题及解决方案"></a>接口的幂等性问题及解决方案</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111613.png" data-fancybox="group" data-caption="image-20220323145312086" class="fancybox"><img alt="image-20220323145312086" title="image-20220323145312086" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111613.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111740.png" data-fancybox="group" data-caption="image-20220317103031072" class="fancybox"><img alt="image-20220317103031072" title="image-20220317103031072" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220328111740.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><h4 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220330223107.png" data-fancybox="group" data-caption="image-20220329111901643" class="fancybox"><img alt="image-20220329111901643" title="image-20220329111901643" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220330223107.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a>skiplist与平衡树、哈希表的比较</h4><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h3><p>中止策略：无特殊场景。<br>丢弃策略：无关紧要的任务（博客阅读量）。<br>弃老策略：发布消息。<br>调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）。</p><p>详细回答：</p><ol><li><p>AbortPolicy中止策略：丢弃任务并抛出RejectedExecutionException异常。</p><p>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.<br>使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p></li><li><p>DiscardPolicy丢弃策略：ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</p><p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</p><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作。<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</p></li><li><p>DiscardOldestPolicy弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。<br>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</p><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</p></li><li><p>CallerRunsPolicy调用者运行策略：由调用线程处理该任务。<br>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p></li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618824.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618824.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h5 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h5><p>在了解ThreadLocal之前，我们先了解下什么是线程封闭。</p><p>对象封闭在一个线程里，即便这个对象不是线程安全的，也不会出现并发安全问题。</p><p>例如 栈封闭：就是用栈（stack）来保证线程安全。</p><p>public void testThread() {<br>    StringBuilder s = new StringBuilder();<br>    s.append(“Hello”);<br>}<br>StringBuilder是线程不安全的，但是它只是个局部变量，局部存储在虚拟机栈，虚拟机栈是线程隔离的，所以不会有线程安全问题。</p><p>ThreadLocal线程封闭：简单易用。</p><p>使用ThreadLocal来实现线程封闭，线程封闭的指导思想是封闭，而不是共享。所以说ThreadLocal是用来解决变量共享的并发安全问题，多少有些不精确。</p><h5 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h5><p>从名字我们就可以看到ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p> 为每个线程复制一份变量副本。</p><p> 底层使用的一个ThreadLocalMap对象存储（键值对存储）。</p><p> 使用ThreadLocal会存在内存泄漏问题。</p><p> 使用ThreadLocal对象作为键存储，是弱引用的，可以被回收掉，键为null，但是value值是强引用，不能被回收。</p><p> 建议：在使用完后，主动调用remove()，删除</p><p><a href="https://img-blog.csdnimg.cn/bb620a99391944a1a1ece4fcfad7c433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg2Njg0OQ==,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="请添加图片描述" class="fancybox"><img alt="请添加图片描述" title="请添加图片描述" data-src="https://img-blog.csdnimg.cn/bb620a99391944a1a1ece4fcfad7c433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg2Njg0OQ==,size_16,color_FFFFFF,t_70" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h5 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h5><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中的key为null，而value还存在着强引用，只有thread线程退出以后，value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry 的value 就会一直存在一条强引用链：</p><p>Thread Ref -&gt; Thread -&gt;ThreadLocalMap -&gt; Entry -&gt; value</p><p>永远无法回收，造成内存泄漏。</p><h5 id="key-使用强引用"><a href="#key-使用强引用" class="headerlink" title="key 使用强引用"></a>key 使用强引用</h5><p>当ThreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p><h5 id="key使用弱引用"><a href="#key使用弱引用" class="headerlink" title="key使用弱引用"></a>key使用弱引用</h5><p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的软引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除 value值。</p><h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><p>每次使用完ThreadLocal都调用它的remove()方法清除数据。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618806.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208231618806.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      desc
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://raptor1998.top/2022/08/19/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://raptor1998.top/2022/08/19/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-08-18T16:00:00.000Z</published>
    <updated>2022-08-19T03:28:47.390Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h1><h2 id="Serial-串行回收"><a href="#Serial-串行回收" class="headerlink" title="Serial  串行回收"></a>Serial  串行回收</h2><p>Serial采用的是<strong>复制算法</strong>的垃圾收集器，而且是<strong>单线程运作</strong>的。也就是说，当Serial进行垃圾收集时，必须要暂停其他所有线程的工作，直到垃圾收集完成，这个动作叫STW（Stop The World） 。Golang中的GC也会存在STW，在其标记阶段的准备过程中会暂停掉所有正在运行的Goroutine。</p><p>而且这个暂停动作对用户来说是不可见的，用户可能只会知道某个请求执行了很久，没有经验的话是很难跟GC挂上钩的。</p><p>但是从某些方面来看，如果你的系统就只有单核，那么Serial就不会存在线程之间的交互的开销，可以提高GC的效率。这也是为什么Serial仍然是Client模式下的默认新生代收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182007931.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="ParNew-并行回收"><a href="#ParNew-并行回收" class="headerlink" title="ParNew 并行回收"></a>ParNew 并行回收</h2><p>ParNew与Serial只有一个区别，那就是ParNew是<strong>多线程</strong>的，而Serial是<strong>单线程</strong>的。除此之外，其使用的垃圾收集算法和收集行为完全一样。</p><p>该收集器如果在单核的环境下，其性能可能会比Serial更差一些，因为单核无法发挥多线程的优势。在多核环境下，其默认的线程与CPU数量相同。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182008541.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="Parallel-Scavenge-吞吐量优先"><a href="#Parallel-Scavenge-吞吐量优先" class="headerlink" title="Parallel Scavenge 吞吐量优先"></a>Parallel Scavenge 吞吐量优先</h2><p>Parallel Scavenge是一个多线程的收集器，也是在server模式下的默认垃圾收集器。上面的两种收集器关注的重点是如何减少STW的时间，而Parallel Scavenge则更加关注于系统的吞吐量。</p><p>例如JVM已经运行了100分钟，而GC了1分钟，那么此时系统的吞吐量为(100 - 1)/100 = 99% 。</p><p><code>吞吐量和短停顿时间其侧重的点不一样，需要根据自己的实际情况来判断。</code></p><ul><li><p>高吞吐量<br>  GC的总时间越短，系统的吞吐量则越高。换句话说，高吞吐量则意味着，STW的时间可能会比正常的时间多一点，也就更加适合那种不存在太多交互的后台的系统，因为对实时性的要求不是很高，就可以高效率的完成任务。</p></li><li><p>短停顿时间<br>  STW的时间短，则说明对系统的响应速度要求很高，因为要跟用户频繁的交互。因为低响应时间会带来较高的用户体验。</p></li></ul><h1 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h1><h2 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h2><p>Serial Old是Serial的老年代版本，使用的标记-整理算法， 其实从这看出来，新生代和老年代收集器的一个差别。</p><blockquote><p>新生代：大部分的资源都是需要被回收</p></blockquote><blockquote><p>老年代：大部分的资源都不需要被回收</p></blockquote><p>所以，新生代收集器基本都是用的<strong>复制算法</strong>，老年代收集器基本都是用的<strong>标记-整理</strong>算法。</p><p>Serial Old也是给Client模式下JVM使用的。</p><h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p>Parallel Old是Parallel Scavenge的老年代版本，也是一个多线程的、采用<strong>标记-整理</strong>算法的收集器，刚刚讨论过了系统吞吐量，那么在对CPU的资源十分敏感的情况下， 可以考虑Parallel Scavenge和Parallel Old这个新生代-老年代的垃圾收集器组合。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025950.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><p>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025973.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>从图中可以看出其核心的步骤：</p><blockquote><ul><li>首先会进行<strong>初始标记</strong>，标记从GCRoots出发能够关联到的所有对象，此时需要STW，但是不需要很多时间</li><li>然后会进行<strong>并发标记</strong>，多线程对所有对象通过GC Roots Tracing进行可达性分析，这个过程较为耗时</li><li>完成之后会<strong>重新标记</strong>，由于在并发标记的过程中，程序还在正常运行，此时有些对象的状态可能已经发生了变化，所以需要STW，来进行重新标记，所用的时间大小关系为<code>初始标记 &lt; 重新标记 &lt; 并发标记</code>。</li><li>标记阶段完成之后，开始执行<strong>并发清除</strong>。</li></ul></blockquote><p>CMS是一个优点很明显的的垃圾收集器，例如可以多线程的进行GC，且拥有较低的STW的时间。但是同样的，CMS也有很多缺点。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使用标记-清除算法会造成不连续的内存空间，也就是内存碎片。如果此时需要给较大的对象分配空间，会发现内存不足，重新触发一次Full GC。</p><p>其次，由于CMS可能会比注重<strong>吞吐量</strong>的收集器占用更多的CPU资源，但是如果应用程序本身就已经对CPU资源很敏感了，就会导致GC时的可用CPU资源变少，GC的整个时间就会变长，那么就会导致系统的吞吐量降低。</p><h3 id="为什么不使用标记整理算法"><a href="#为什么不使用标记整理算法" class="headerlink" title="为什么不使用标记整理算法"></a>为什么不使用标记整理算法</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><p>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><h3 id="如何选择回收器"><a href="#如何选择回收器" class="headerlink" title="如何选择回收器"></a>如何选择回收器</h3><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p><p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p><p>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1全称Garbage First，业界目前对其评价很高，JDK9中甚至提议将其设置为默认的垃圾收集器。Parallel Scavenge更加关注于吞吐量，而CMS更加关注于更短的STW时间，那么G1就是在实现高吞吐的同时，尽可能的减少STW的时间。</p><p>垃圾收集器都会把连续的堆内存空间分为新生代、老年代，新生代则被划分的更加的细，有Eden和两个较小的Survivor空间，而且都是连续的内存空间。而G1则与众不同，它引入了新的概念，叫<strong>Region</strong>。</p><p>Region是一堆<strong>大小相等</strong>但是<strong>不连续</strong>的内存空间，同样是采用了分代的思想，但是不存在其他的收集器的物理隔离，属于新生代和老年代的region分布在堆的各个地方。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025992.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><code>H则代表大对象，也叫Humongous Object。为了防止大对象的频繁拷贝，会直接的将其放入老年代</code></p><h3 id="回收过程-1"><a href="#回收过程-1" class="headerlink" title="回收过程"></a>回收过程</h3><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220316160315.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><strong>从宏观上来看，其采用的是标记-整理算法， 而从region到region来看，其采用的是复制算法的，所以G1在运行期间不会像CMS一样产生内存碎片。</strong></p><h4 id="分区region"><a href="#分区region" class="headerlink" title="分区region"></a>分区region</h4><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182042718.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h1><h2 id="JVM参数参考"><a href="#JVM参数参考" class="headerlink" title="JVM参数参考"></a>JVM参数参考</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jvmOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xms6144m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xmx6144m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xmn1024m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:SurvivorRatio=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+UseG1GC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MaxGCPauseMillis=200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:ParallelGCThreads=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:ConcGCThreads=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MetaspaceSize=256m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MaxMetaspaceSize=512M</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+PrintGCDetails</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+PrintHeapAtGC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-javaagent:/opt/tiger/skywalking/skywalking-agent/skywalking-agent.jar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Dskywalking.agent.service_name=toutiao.cg.wolong</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="G1其他"><a href="#G1其他" class="headerlink" title="G1其他"></a>G1其他</h2><h3 id="关键细节"><a href="#关键细节" class="headerlink" title="关键细节"></a>关键细节</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191120320.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191124064.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191125838.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191108135.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="与CMS对比"><a href="#与CMS对比" class="headerlink" title="与CMS对比"></a>与CMS对比</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191109445.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://raptor1998.top/2022/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
    <id>http://raptor1998.top/2022/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/</id>
    <published>2022-08-17T16:00:00.000Z</published>
    <updated>2022-08-24T09:38:01.545Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>Volatile是Java虚拟机提供的轻量级的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p><code>Java Memory Model</code>，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208172139279.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208172139279.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设是主物理内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">60</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile的可见性</span></span><br><span class="line"><span class="comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args [])</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 资源类</span></span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AAA线程 实现了Runnable接口的，lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程睡眠3秒，假设在进行运算</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 修改number的值</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出修改后的值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t update number value:"</span> + myData.number);</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"AAA"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.number == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// main线程就一直在这里等待循环，直到number的值不等于零</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span></span><br><span class="line">        <span class="comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后输出结果：</span></span><br><span class="line"><span class="comment">         * AAA come in</span></span><br><span class="line"><span class="comment">         * AAA update number value:60</span></span><br><span class="line"><span class="comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建10个线程，线程里面进行1000次循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        <span class="comment">// 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) {</span><br><span class="line">            myData.addPlusPlus();</span><br><span class="line">        }</span><br><span class="line">    }, String.valueOf(i)).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="禁止指令重拍"><a href="#禁止指令重拍" class="headerlink" title="禁止指令重拍"></a>禁止指令重拍</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p><p><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></p><h4 id="DCL单例模式"><a href="#DCL单例模式" class="headerlink" title="DCL单例模式"></a>DCL单例模式</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1、分配对象内存空间</span></span><br><span class="line">instance(memory); <span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3、设置instance指向刚刚分配的内存地址，</span></span><br></pre></td></tr></tbody></table></figure></div><p>此时instance != null<br>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1、分配对象内存空间</span></span><br><span class="line">instance = memory; <span class="comment">// 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory); <span class="comment">// 2、初始化对象</span></span><br></pre></td></tr></tbody></table></figure></div><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span> <span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法SingletonDemo"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) //<span class="title">b</span></span></span><br><span class="line"><span class="class">            </span>{ </span><br><span class="line">           <span class="comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) { </span><br><span class="line">                <span class="comment">// d 此时才开始初始化</span></span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的<br>以AtomicInteger为例</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个原子类</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">     * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">"\t current data: "</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">"\t current data: "</span> + atomicInteger.get());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    } <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="什么叫ABA"><a href="#什么叫ABA" class="headerlink" title="什么叫ABA"></a>什么叫ABA</h3><p>在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="如何解决ABA"><a href="#如何解决ABA" class="headerlink" title="如何解决ABA"></a>如何解决ABA</h3><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第一次版本号"</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第二次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第三次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第一次版本号"</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 修改成功否："</span> + result + <span class="string">"\t 当前最新实际版本号："</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 当前实际最新值"</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t4"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！</a></p><p><a href="https://www.cnblogs.com/heyouxin/p/13037146.html" target="_blank" rel="noopener">【并发编程】公平锁与非公平锁的区别</a></p><p><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></p><h2 id="synchronized锁实现"><a href="#synchronized锁实现" class="headerlink" title="synchronized锁实现"></a>synchronized锁实现</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p><p>加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p><p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p><p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p><p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p><p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><h4 id="偏向锁-、-轻量级锁-、-重量级锁"><a href="#偏向锁-、-轻量级锁-、-重量级锁" class="headerlink" title="偏向锁 、 轻量级锁 、 重量级锁"></a>偏向锁 、 轻量级锁 、 重量级锁</h4><blockquote><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ corePoolSize：核心线程数，线程池中的常驻核心线程数</span><br><span class="line">    </span><br><span class="line">    在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</span><br><span class="line">    </span><br><span class="line">    当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</span><br><span class="line">+ maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、</span><br><span class="line">    相当有扩容后的线程数，这个线程池能容纳的最多线程数</span><br><span class="line">+ keepAliveTime：多余的空闲线程存活时间</span><br><span class="line">    当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</span><br><span class="line">    </span><br><span class="line">    默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</span><br><span class="line">+ unit：keepAliveTime的单位</span><br><span class="line">+ workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）</span><br><span class="line">    LinkedBlockingQueue：链表阻塞队列</span><br><span class="line"></span><br><span class="line">    SynchronousBlockingQueue：同步阻塞队列</span><br><span class="line"></span><br><span class="line">+ threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</span><br><span class="line"></span><br><span class="line">+ handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</span><br></pre></td></tr></tbody></table></figure></div><h2 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h2><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</p><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p><p>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><strong>Executors返回的线程池对象弊端如下：</strong></p><p>FixedThreadPool和SingleThreadPool：运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</p><p>CacheThreadPool和ScheduledThreadPool<br>非核心线程数为：Integer.MAX_VALUE，线程数上限太大导致oom</p><h2 id="参数如何设置"><a href="#参数如何设置" class="headerlink" title="参数如何设置"></a>参数如何设置</h2><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><strong><em>1. 非核心线程的创建时机</em></strong></p><ul><li><p>核心线程的数量是 corePoolSize 的值，非核心线程的数量是 maxinumPoolSize - corePoolSize ；</p></li><li><p>非核心线程创建的触发时机是：当前线程池中核心线程已满，且没有空闲的线程，还有任务等待队列已满，满足上面的所有条件，才会去创建线程去执行新提交的任务；</p></li><li><p>如果线程池中的线程数量达到 maxinumPoolSize 的值，此时还有任务进来，就会执行拒绝策略，抛弃任务或者其他</p></li></ul><p><strong>如果拒绝策略是抛弃任务的话，有一种场景，就会造成大量任务的丢弃，就是瞬时冲高的情况下。</strong></p><p><strong><em>2. 排队任务调度策略</em></strong></p><ul><li><p>当线程池中核心线程数量已达标，且没有空闲线的情况下，在产生的任务，会加入到等待队列中去，这样一直持续下去，</p></li><li><p>等到等待队列已满，在来的任务，会创建非核心线程去执行新提交的任务，那么就产生一种结果，在等待队列中的任务是先提交的任务，反而没有在此时提交的任务先执行。</p></li></ul><p><strong>任务的执行顺序和任务的提交顺序不一致，如果业务需求的任务是有先后依赖关系的，就会降低线程的调度效率</strong></p><h2 id="拒绝策略使用场景"><a href="#拒绝策略使用场景" class="headerlink" title="拒绝策略使用场景"></a>拒绝策略使用场景</h2><p><strong>中止策略：无特殊场景。</strong><br><strong>丢弃策略：无关紧要的任务（博客阅读量）。</strong><br><strong>弃老策略：发布消息。</strong><br><strong>调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）。</strong></p><h3 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h3><p><strong>丢弃任务并抛出RejectedExecutionException异常。</strong></p><p>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.<br>使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h3 id="DiscardPolicy丢弃策略"><a href="#DiscardPolicy丢弃策略" class="headerlink" title="DiscardPolicy丢弃策略"></a>DiscardPolicy丢弃策略</h3><p><strong>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</strong></p><p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</p><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作。<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</p><h3 id="DiscardOldestPolicy弃老策略"><a href="#DiscardOldestPolicy弃老策略" class="headerlink" title="DiscardOldestPolicy弃老策略"></a>DiscardOldestPolicy弃老策略</h3><p><strong>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</strong></p><p>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</p><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</p><h3 id="CallerRunsPolicy调用者运行策略"><a href="#CallerRunsPolicy调用者运行策略" class="headerlink" title="CallerRunsPolicy调用者运行策略"></a>CallerRunsPolicy调用者运行策略</h3><p><strong>由调用线程处理该任务。</strong></p><p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p><h2 id="常见队列"><a href="#常见队列" class="headerlink" title="常见队列"></a>常见队列</h2><p><strong>1）ArrayBlockingQueue</strong></p><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><p><strong>（2）LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；</p><p>newFixedThreadPool线程池使用了这个队列。</p><p><strong>（3）DelayQueue</strong></p><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。</p><p>newScheduledThreadPool线程池使用了这个队列。</p><p><strong>（4）PriorityBlockingQueue</strong></p><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；</p><p><strong>（5）SynchronousQueue</strong></p><p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene</p><p>newCachedThreadPool线程池使用了这个队列。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从名字我们就可以看到ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p> 为每个线程复制一份变量副本。</p><p> 底层使用的一个ThreadLocalMap对象存储（键值对存储）。</p><p> 使用ThreadLocal会存在内存泄漏问题。</p><p> 使用ThreadLocal对象作为键存储，是弱引用的，可以被回收掉，键为null，但是value值是强引用，不能被回收。</p><p> 建议：在使用完后，主动调用remove()，删除</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191813112.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191813112.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><h3 id="key-ThreadLocal是强引用"><a href="#key-ThreadLocal是强引用" class="headerlink" title="key=ThreadLocal是强引用"></a>key=ThreadLocal是强引用</h3><ul><li><p>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</p></li><li><p>但是因为threadLocalMap的Entry强引用了threadLocal(key就是threadLocal), 造成ThreadLocal无法被回收</p></li><li><p>在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, 始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏</p></li></ul><p>  <strong>也就是说: ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的</strong></p><h3 id="key-ThreadLocal是弱引用"><a href="#key-ThreadLocal是弱引用" class="headerlink" title="key=ThreadLocal是弱引用"></a>key=ThreadLocal是弱引用</h3><ul><li>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</li><li>由于threadLocalMap只持有ThreadLocal的弱引用, 没有任何强引用指向threadlocal实例（这里Entry不再强引用ThreadLocal了）, 所以threadlocal就可以顺利被gc回收, 此时Entry中的key = null</li><li>在没有手动删除Entry以及CurrentThread依然运行的前提下, 也存在始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry,value就不会被回收, 而这块value永远不会被访问到了（因为key=null）, 导致value内存泄漏</li></ul><p><strong>也就是说: ThreadLocalMap中的key使用了弱引用, 也有可能内存泄漏</strong></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>文末的解释写更加清晰</strong></p><p>如果<code>ThreadLocalMap</code>的<code>key</code>为强引用回收<code>ThreadLocal</code>时，因为<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>就不会被回收，导致<code>Entry</code>内存泄漏。</p><p><code>ThreadLocalMap</code>的<code>key</code>为弱引用回收<code>ThreadLocal</code>时，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。当key为null，在下一次<code>ThreadLocalMap</code>调用set(),get(),remove()时会清除value的值。</p><p><strong>因此，<code>ThreadLocal</code>内存泄漏的根源是由于<code>ThreadLocalMap</code>的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不因为弱引用。</strong></p><p><strong><code>ThreadLocal</code>正确的使用方法：</strong></p><ol><li>每次使用完<code>ThreadLocal</code>都要调用它的remove()清除数据。</li><li>将<code>ThreadLoca</code>l变量定义成<code>private static</code>，这样就一直存在<code>ThreadLocal</code>的强引用，也能保证任何时候都能通过<code>ThreadLocal</code>的弱引用访问到Entry的value值，进而清除掉。</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/JH39456194/article/details/107304997" target="_blank" rel="noopener">threadlocal内存泄露问题</a></p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h1 id="并发容器-amp-阻塞队列"><a href="#并发容器-amp-阻塞队列" class="headerlink" title="并发容器 &amp; 阻塞队列"></a>并发容器 &amp; 阻塞队列</h1><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrenthashmap" target="_blank" rel="noopener">https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrenthashmap</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://raptor1998.top/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://raptor1998.top/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-16T16:00:00.000Z</published>
    <updated>2022-08-19T06:20:50.660Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>1、物理层：实现计算机节点之间比特流的透明传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p><p>2、数据链路层：通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p><p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p><p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：实现网络地址与物理地址的转换，并通过路由选择算法为分组通过通信子网选择最适当的路径</p><p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p><p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p><p>网络层协议负责的是提供主机间的逻辑通信；<br>传输层协议负责的是提供进程间的逻辑通信。<br>5、会话层：是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持、终止通信。</p><p>6、表示层：处理用户数据的表示问题，如数据的编码、格式转换、加密和解密、压缩和解压缩。</p><p>7、应用层：为用户的应用进程提供网络通信服务，完成和实现用户请求的各种服务。</p><h1 id="浏览器中输入一个网址它的运行过程"><a href="#浏览器中输入一个网址它的运行过程" class="headerlink" title="浏览器中输入一个网址它的运行过程"></a>浏览器中输入一个网址它的运行过程</h1><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p><strong>1、查询DNS，获取域名对应的IP。</strong></p><p>（1）检查浏览器缓存、检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p><p>（2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。</p><p>（3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：</p><p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p><p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p><p>（4）如果本地DNS服务器也失效：</p><p>如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<a href="http://baidu.com/" target="_blank" rel="noopener">http://baidu.com</a>）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</p><p>如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</p><p><strong>2、得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文：</strong></p><p>（1）应用层：客户端发送HTTP请求报文。</p><p>（2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。</p><p>（3）网络层：（加入IP头）路由寻址。</p><p>（4）数据链路层：（加入frame头）传输数据。</p><p>（5）物理层：物理传输bit。</p><p><strong>3、服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。</strong></p><p><strong>4、关闭连接，TCP四次挥手。</strong></p><p><strong>5、客户端解析HTTP响应报文，浏览器开始显示HTML</strong></p><h1 id="TCP的连接建立与断开"><a href="#TCP的连接建立与断开" class="headerlink" title="TCP的连接建立与断开"></a>TCP的连接建立与断开</h1><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171127810" data-fancybox="group" data-caption="三次握手" class="fancybox"><img alt="三次握手" title="三次握手" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171127810" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128756.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128756.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><h3 id="为什么不能用两次握手进行建立连接？"><a href="#为什么不能用两次握手进行建立连接？" class="headerlink" title="为什么不能用两次握手进行建立连接？"></a>为什么不能用两次握手进行建立连接？</h3><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><ul><li><p>三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p><p>因为TCP协议是双向的，第三次握手是为了使得sever知道客户答应了连接的请求。其中两次握手只能确定<strong>从客户端到服务端的网络是可达的</strong>，但却<strong>无法保证从服务端到客户端的网络是可达的</strong>。所以我们一定要保证双向的可达。</p></li><li><p>三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p><p>客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文段后：</p><ul><li>假设不采用“三次握手”，那么只要Sever发出确认，新的连接就建立了。但由于现在Client并没有发出建立连接的请求，因此不会理睬Server的确认，也不会向Server发送数据。而Server却以为新的连接已经建立，并一直等待Client发来数据，这样，Server的很多资源就白白浪费掉了</li><li>而采用“三次握手”协议，只要Server收不到来自Client的确认，就知道Client并没有要求建立请求，就不会建立连接了。</li></ul></li></ul><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><h3 id="挥手过程"><a href="#挥手过程" class="headerlink" title="挥手过程"></a>挥手过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128075" data-fancybox="group" data-caption="四次挥手" class="fancybox"><img alt="四次挥手" title="四次挥手" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128075" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129832.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129832.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h1 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP, UDP 协议的区别"></a>TCP, UDP 协议的区别</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129736.jpeg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129736.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h1 id="什么是https和http"><a href="#什么是https和http" class="headerlink" title="什么是https和http"></a>什么是https和http</h1><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="http存在的问题"><a href="#http存在的问题" class="headerlink" title="http存在的问题"></a>http存在的问题</h2><ul><li>通信使用明文不加密，通信内容可能被窃听；</li><li>无法验证报文的完整性，数据内容可能被篡改</li><li>不验证通信方身份、可能遭到伪装，无法保证数据发送到正确的机器上；</li></ul><h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p>https 是基于tcp协议，在http的基础上加入了SSL/TLS，可看成是添加了加密和认证机制的http，使用对称加密、非对称加密、证书等技术进行进行客户端与服务端的数据加密传输，最终达到保证整个通信的安全性。</p><p>对称加密指加密和解密都使用同一个密钥的方式，这种方式存在如何安全地将密钥发送对方的问题；非对称加密使用两个密钥，公钥加密则需要私钥解密，私钥加密则需要公钥解密。不能私钥加密，私钥解密。非对称加密不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，速度非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><p><strong>证书通常包含这些内容：(1) 服务端的公钥；(2) 证书发行者(CA)对证书的数字签名；(3) 证书所用的签名算法；(4) 证书发布机构、有效期、所有者的信息等其他信息</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130100.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130100.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="https的认证加密过程？如何保证内容不会被篡改的？"><a href="#https的认证加密过程？如何保证内容不会被篡改的？" class="headerlink" title="https的认证加密过程？如何保证内容不会被篡改的？"></a>https的认证加密过程？如何保证内容不会被篡改的？</h2><p>（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立<br>（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息<br>（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性<br>（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端<br>（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</p><h2 id="根证书如何保证签发的证书是安全有效的？"><a href="#根证书如何保证签发的证书是安全有效的？" class="headerlink" title="根证书如何保证签发的证书是安全有效的？"></a>根证书如何保证签发的证书是安全有效的？</h2><p>（1）服务器会预先生成非对称加密密钥，私钥S.pri自己保留，而公钥S.pub则发送给CA进行签名认证<br>（2）CA机构也会预先生成非对称加密密钥，其私钥C.pri用来对服务器的公钥S.pub进行签名，生成CA证书<br>（3）CA机构将签名生成的CA证书返回给服务器，也就是前面服务端给客户端那个证书<br>（4）因为CA机构比较权威，所以很多浏览器会内置包含它公钥C.pub的证书，称之为根证书，然后可以使用根证书来验证其颁发证书的合法性了</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130488.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130488.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>1、本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器<br>2、中间人服务器返回中间人自己的证书<br>3、客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。<br>4、中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密<br>5、中间人以客户端的请求内容再向正规网站发起请求<br>6、因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据<br>7、中间人凭借与正规网站建立的对称加密算法对内容进行解密<br>8、中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输<br>9、客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</p><p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p><h2 id="非对称加密和对称加密"><a href="#非对称加密和对称加密" class="headerlink" title="非对称加密和对称加密"></a>非对称加密和对称加密</h2><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><strong>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</strong></p><h1 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h1><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如 </p><p>① 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；② 一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密。</p><h1 id="get和-post-请求的区别"><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a>get和 post 请求的区别</h1><p>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。<br>（2）幂等性：get 是幂等的，post 为非幂等的<br>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。<br>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。<br>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。<br>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。<br>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</p><h1 id="关于https的其他解释"><a href="#关于https的其他解释" class="headerlink" title="关于https的其他解释"></a>关于https的其他解释</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171131640.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171131640.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      desc
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ipv4到ipv6改造</title>
    <link href="http://raptor1998.top/2022/08/16/ByteStudy%20ipv4%E5%88%B0ipv6%E6%94%B9%E9%80%A0/"/>
    <id>http://raptor1998.top/2022/08/16/ByteStudy%20ipv4%E5%88%B0ipv6%E6%94%B9%E9%80%A0/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-08-15T13:32:04.571Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="IPv6的3种表示方法"><a href="#IPv6的3种表示方法" class="headerlink" title="IPv6的3种表示方法"></a>IPv6的3种表示方法</h1><ol><li><p>冒分十六进制表示法<br> 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    　　ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</span><br></pre></td></tr></tbody></table></figure></div><p> 　　这种表示法中，每个X的前导0是可以省略的，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    　　2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>0位压缩表示法<br> 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    　　FF01:0:0:0:0:0:0:1101 → FF01::1101</span><br><span class="line">    　　0:0:0:0:0:0:0:1 → ::1</span><br><span class="line">    　　0:0:0:0:0:0:0:0 → ::</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>内嵌IPv4地址表示法</p><p> 为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用 。</p></li></ol><h1 id="过度技术"><a href="#过度技术" class="headerlink" title="过度技术"></a>过度技术</h1><h2 id="双栈技术"><a href="#双栈技术" class="headerlink" title="双栈技术"></a>双栈技术</h2><p>主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。</p><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><p>在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。</p><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p><h2 id="协议翻译技术"><a href="#协议翻译技术" class="headerlink" title="协议翻译技术"></a>协议翻译技术</h2><p>对IPV6和IPV4报头时行相互翻译，实现IPV4/IPV6协议和地址的转换。</p><p>网络地址转换/协议转换技术 NAT-PT 通过与SIIT协议转换和传统的IPv4下的动态地址翻译（NAT）以及适当的应用层网关（ALG）相结合，实现了只安装了IPv6的主机和只安装了IPv4机器的大部分应用的相互通信。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.mfisp.com/6796.html" target="_blank" rel="noopener">详细对比IPv4与IPv6的区别 - 梦飞科技</a></p><p><a href="https://www.docin.com/p-2600732241.html" target="_blank" rel="noopener">浅析ＩＰｖ４到ＩＰｖ６的过渡技术（论文范文）</a></p><p><a href="https://blog.csdn.net/weixin_40228200/article/details/118737890" target="_blank" rel="noopener">IPv6-IPv4过渡技术详解及配置实例_永远是少年啊的博客-CSDN博客_ipv6toipv4</a></p><p><a href="https://blog.csdn.net/AIwenIPgeolocation/article/details/122925047" target="_blank" rel="noopener">从IPv4 到 IPv6 的过渡技术_AIwenIPgeolocation的博客-CSDN博客_ipv4到ipv6的过渡技术</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Java基础——集合</title>
    <link href="http://raptor1998.top/2022/08/15/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>http://raptor1998.top/2022/08/15/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</id>
    <published>2022-08-14T16:00:00.000Z</published>
    <updated>2022-08-16T06:58:44.099Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="与LinkedList的区别"><a href="#与LinkedList的区别" class="headerlink" title="与LinkedList的区别"></a>与LinkedList的区别</h3><ol><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</li><li>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</li><li>内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        } <span class="keyword">else</span> {<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">          <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入<code>grow(minCapacity)</code>方法。</p><p>当 add 第 2 个元素时，<code>minCapacity</code> 为 2，此时 <code>elementData.length(容量)</code>在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code>方法。</p><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p><p>直到添加第 11 个元素，<code>minCapacity(为 11)</code>比 <code>elementData.length（为 10）</code>要大。进入 grow 方法进行扩容。</p><h4 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h4><p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><p>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity(为 10)</code>。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</p><p>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入<code>hugeCapacity</code> 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。<br>以此类推······</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">       <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) {</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>HashMap中有两个重要的参数：初始容量大小和加载因子，初始容量大小是创建时给数组分配的容量大小，默认值为16，加载因子默认0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容.</p><p>在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能.</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>第一步首先将k,v封装到Node对象当中（节点）。</p><p>第二步它的底层会调用K的hashCode()方法得出hash值。第三步通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。</p><p>java1.8 中put 源码：put 中调用 putVal（）方法：</p><p>1.首先判断map中是否有数据，没有就执行resize方法</p><p>2.如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可</p><p>3.如果这个元素的key与要插入的一样，那么就替换一下。</p><p>4.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</p><p>5.遍历这条链子上的数据，完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</li><li>每次扩展的时候，都是扩展2倍；</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="为什么HashMap要树化"><a href="#为什么HashMap要树化" class="headerlink" title="为什么HashMap要树化"></a>为什么HashMap要树化</h3><p>之前在极客时间的专栏里看到过一个解释。本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p><p>用哈希碰撞发起拒绝服务攻击(DOS，Denial-Of-Service attack),常见的场景是攻击者可以事先构造大量相同哈希值的数据，然后以JSON数据的形式发送给服务器，服务器端在将其构建成为Java对象过程中，通常以Hashtable或HashMap等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数据级，进而耗费大量CPU资源。</p><h3 id="为什么要将链表中转红黑树的阈值设为8？"><a href="#为什么要将链表中转红黑树的阈值设为8？" class="headerlink" title="为什么要将链表中转红黑树的阈值设为8？"></a>为什么要将链表中转红黑树的阈值设为8？</h3><p>，当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）的要求，就会把链表转换为红黑树。同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。</p><p>每次遍历一个链表，平均查找的时间复杂度是 O(n)，n 是链表的长度。红黑树有和链表不一样的查找性能，由于红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n))。最初链表还不是很长，所以可能 O(n) 和 O(log(n)) 的区别不大，但是如果链表越来越长，那么这种区别便会有所体现。所以为了提升查找性能，需要把链表转化为红黑树的形式。</p><h3 id="hashmap、hashtable、treemap的却别"><a href="#hashmap、hashtable、treemap的却别" class="headerlink" title="hashmap、hashtable、treemap的却别"></a>hashmap、hashtable、treemap的却别</h3><p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。存储的内容是基于key-value的键值对映射，不能有重复的key，而且一个key只能映射一个value。HashSet底层就是基于HashMap实现的。</p><p>Hashtable的key、value都不能为null；HashMap的key、value可以为null，不过只能有一个key为null，但可以有多个null的value；TreeMap键、值都不能为null。</p><p>Hashtable、HashMap具有无序特性。TreeMap是利用红黑树实现的（树中的每个节点的值都会大于或等于它的左子树中的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需求排序的情况下首选TreeMap，默认按键的升序排序（深度优先搜索），也可以自定义实现Comparator接口实现排序方式。</p><h3 id="负载因子为什么是0-75"><a href="#负载因子为什么是0-75" class="headerlink" title="负载因子为什么是0.75"></a>负载因子为什么是0.75</h3><ul><li><p>负载1.0</p><p>  当负载因子是1.0时，也就意味着，只有当数组的8个值全部填充了，才会发生扩容。这就带来了很大的问题，因为Hash冲突时避免不了的。</p><p>  后果：当负载因子是1.0的时候，意味着会出现大量的Hash的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。</p><p>  <strong>虽然空间利用率上去了，但是时间效率降低了。</strong></p></li><li><p>负载0.5</p><p>  负载因子是0.5的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，Hash冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。<br>  此时空间利用率就会大大的降低，原本存储1M的数据，现在就意味着需要2M的空间。</p><p>  <strong>虽然时间效率提升了，但是空间利用率降低了。</strong></p></li></ul><h3 id="为什么是2倍扩容"><a href="#为什么是2倍扩容" class="headerlink" title="为什么是2倍扩容"></a>为什么是2倍扩容</h3><blockquote><p>第一是因为哈希函数的问题</p></blockquote><pre><code>通过除留余数法方式获取桶号，因为Hash表的大小始终为2的n次幂，因此可以将取模转为位运算操作，提高效率，容量n为2的幂次方，n-1的二进制会全为1，位运算时可以充分散列，避免不必要的哈希冲突，这也就是为什么要按照2倍方式扩容的一个原因</code></pre><blockquote><p>第二是因为是否移位的问题</p></blockquote><pre><code>是否移位，由扩容后表示的最高位是否1为所决定，并且移动的方向只有一个，即向高位移动。因此，可以根据对最高位进行检测的结果来决定是否移位，从而可以优化性能，不用每一个元素都进行移位，因为为0说明刚好在移位完之后的位置，为1说明不是需要移动oldCop，这也是其为什么要按照2倍方式扩容的第二个原因。</code></pre><h3 id="hashmap的线程安全问题"><a href="#hashmap的线程安全问题" class="headerlink" title="hashmap的线程安全问题"></a>hashmap的线程安全问题</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192000&amp;idx=1&amp;sn=118cee6d1c67e7b8e4f762af3e61643e&amp;chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">hashmap循环链表的形成</a></p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">1.7CurrentHashMap小灰漫画解释</a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161417058.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161417058.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></tbody></table></figure></div><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化 Segment 流程：</p><ul><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p><ol><li><p>检查计算得到的位置的 Segment 是否为null.</p></li><li><p>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</p></li><li><p>再次检查计算得到的指定位置的 Segment 是否为null.</p></li><li><p>使用创建的 HashEntry 数组初始化这个 Segment.</p></li><li><p>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment</p></li></ol></li><li><p>Get方法：</p><p>  1.为输入的Key做Hash运算，得到hash值。</p></li></ul><pre><code>2.通过hash值，定位到对应的Segment对象3.再次通过hash值，定位到Segment当中数组的具体位置。</code></pre><ul><li>Put方法：</li></ul><pre><code>1.为输入的Key做Hash运算，得到hash值。2.通过hash值，定位到对应的Segment对象3.获取可重入锁4.再次通过hash值，定位到Segment当中数组的具体位置。5.插入或覆盖HashEntry对象。6.释放锁。</code></pre><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><p>1 .tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。</p><ol start="2"><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><ul><li><p>如果这个位置上的 HashEntry 不存在：</p><p>  如果当前容量大于扩容阀值，小于最大容量，进行扩容。直接头插法插入。</p></li><li><p>如果这个位置上的 HashEntry 存在：<br>  判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</p><p>  不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。</p><pre><code>如果当前容量大于扩容阀值，小于最大容量，进行扩容。直接链表头插法插入。</code></pre></li></ul></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) {</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) {</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                e = e.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161444447.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161444447.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h4><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</p></li></ol><p>#</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) {</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy CICD</title>
    <link href="http://raptor1998.top/2022/08/12/ByteStudy%20CICD/"/>
    <id>http://raptor1998.top/2022/08/12/ByteStudy%20CICD/</id>
    <published>2022-08-11T16:00:00.000Z</published>
    <updated>2022-08-15T13:23:08.049Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152120447.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><blockquote><p>continuous integration (CI) is the practice of merging all developer working copies to a shared mainline several times a day.</p></blockquote><p><strong>频繁的（一天多次的）将所有开发者的工作合并到主干上。</strong></p><p><strong>优点：</strong></p><ul><li>易于定位错误：每一次的代码集成都需要执行相关的测试工作，持续集成频繁的集成次数天然的将复杂的代码逻辑切割为了小块，也就使得每一次测试中遇到的错误能够更加容易的被定位；</li><li>易于控制开发流程：更为细致的工作提交也就意味着更容易判断当前的工作进度，这对于管理者规划开发流程而言提供了一个有效的参考，同时也为开发人员省下了汇报工作的时间；</li><li>易于CodeReview：对于大块工作的切分自然也有助于做 CodeReview；</li><li>易于减少不必要的工作：build 以及 test 过程的自动化可以为你节约一大票的时间，从而投入到有价值的工作中去。<h1 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h1><blockquote><p>Continuous delivery (CD or CDE) is a software engineering approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time and, when releasing the software, doing so manually.</p></blockquote></li></ul><p><strong>一种能够使得软件在较短的循环中可靠的发布的软件工程方法。</strong> </p><p>与持续集成相比，持续交付的侧重点在于 交付，其核心对象不在于代码，而在于可交付的产物。由于持续集成仅仅针对于新旧代码的集成过程执行了一定的测试，其变动到持续交付后还需要一些额外的流程。</p><h1 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h1><blockquote><p>Continuous deployment (CD) is a software engineering approach in which software functionalities are delivered frequently through automated deployments.</p></blockquote><p><strong>通过自动化部署的手段将软件功能频繁的进行交付。</strong></p><p>与持续交付以及持续集成相比，持续部署强调了通过 automated deployment 的手段，对新的软件功能进行集成。</p><h1 id="基础泳道的规范"><a href="#基础泳道的规范" class="headerlink" title="基础泳道的规范"></a>基础泳道的规范</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152120464.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/xp178171640/article/details/124379156" target="_blank" rel="noopener">持续集成、持续交付、持续部署(转载)_xupeng1644的博客-CSDN博客_持续集成持续交付持续部署</a></p><p>CICD </p><p>基础泳道流程规范 </p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Month 2</title>
    <link href="http://raptor1998.top/2022/08/10/ByteDance6/"/>
    <id>http://raptor1998.top/2022/08/10/ByteDance6/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-15T12:39:10.824Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="一期上线"><a href="#一期上线" class="headerlink" title="一期上线"></a>一期上线</h1><p>正式开始第三个月，新小组满一个月，比之前小组的工作多多了，目前这条线只有我一个QA，所以会接触的更多一点，在一期需求上线过程中也是充满坎坷，一个是不熟悉bug流程规范，导致这之间的数据没有记录，到最后写报告啥也没得写；二是参与的团队极多，协调起来比较困难；三是上线过程中遇到的问题贼多，由于算法的能力没法在线下环境验证，所以只能等上下游均ready后，直接一刀切，生产商验证能力，导致产生了很多脏数据，由于搜索中台不稳定，导致很多脏数据遗留在了es中；最后是提供的物料不满足预期，只能三四个人大半夜的手动去处理。。。。上了几个12点后的班，这辈子没这么累过，谁也顶不住</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151950107.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>如果对于技术有追求，确实不适合来做QA，业务上的经验对于应届来讲实际意义不大，而且不断地有消息出来，整个部门一个hc都没有，最近准备开始回忆八股了，感觉有点晚了，没办法了，只能硬着头皮上了，准备这周末投几个试试水了，今年可太难了，去年字节8000+hc，今年3000+，实际可能只有1000+，说是政治任务，难顶。。。</p><h2 id="西湖晚霞"><a href="#西湖晚霞" class="headerlink" title="西湖晚霞"></a>西湖晚霞</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151951314.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151951521.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"hotkey":true,"preload":"metadata","video":{"url":"https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151952688.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> </body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy filebeat原理</title>
    <link href="http://raptor1998.top/2022/08/05/ByteStudy%20filebeat%E5%8E%9F%E7%90%86/"/>
    <id>http://raptor1998.top/2022/08/05/ByteStudy%20filebeat%E5%8E%9F%E7%90%86/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-15T13:18:43.700Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ol><li>配置输入源, 可以是日志(log), 也可以是标准输入(stdin), 可以配置多个输入(input)</li><li>为每个日志启一个(Harvester) 收集器, 将不停的读取数据</li><li>数据卷轴, 将数据不断的输出到其它终端</li><li>终端, 如 es, kafaka, redis</li></ol><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152115374.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>工作原理是启动 filebeat 时, 它将启动一个或多个输入, 这些输入将在日志数据指定位置中查找, 对于 filebeat 所找到的每个日志, filebeat 都会启动收集器, 每个收割机都读取单个日志以获取新内容，并将新日志数据发送到libbeat，libbeat将聚集事件，并将聚集的数据发送到为Filebeat配置的输出</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="harvester-收割机"><a href="#harvester-收割机" class="headerlink" title="harvester(收割机)"></a>harvester(收割机)</h2><p>harvester :负责读取单个文件的内容。读取每个文件，并将内容发送到 the output</p><p>每个文件启动一个harvester, harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态</p><p>如果文件在读取时被删除或重命名，Filebeat将继续读取文件。</p><p>这有副作用，即在harvester关闭之前，磁盘上的空间被保留。默认情况下，Filebeat将文件保持打开状态，直到达到close_inactive状态</p><p>关闭harvester会产生以下结果：</p><p>1）如果在harvester仍在读取文件时文件被删除，则关闭文件句柄，释放底层资源。</p><p>2）文件的采集只会在scan_frequency过后重新开始。</p><p>3）如果在harvester关闭的情况下移动或移除文件，则不会继续处理文件。</p><p>要控制收割机何时关闭，请使用close_ *配置选项</p><h2 id="prospector-采矿者"><a href="#prospector-采矿者" class="headerlink" title="prospector(采矿者)"></a>prospector(采矿者)</h2><p>prospector 负责管理harvester并找到所有要读取的文件来源。</p><p>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个harvester。</p><p>每个prospector都在自己的Go协程中运行。</p><h1 id="Filebeat如何保持文件的状态？"><a href="#Filebeat如何保持文件的状态？" class="headerlink" title="Filebeat如何保持文件的状态？"></a>Filebeat如何保持文件的状态？</h1><p>Filebeat 保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中。<br>该状态用于记住harvester正在读取的最后偏移量，并确保发送所有日志行。</p><p>如果输出（例如Elasticsearch或Logstash）无法访问，Filebeat会跟踪最后发送的行，并在输出再次可用时继续读取文件。</p><p>在Filebeat运行时，每个prospector内存中也会保存的文件状态信息，<br>当重新启动Filebeat时，将使用注册文件的数据来重建文件状态，Filebeat将每个harvester在从保存的最后偏移量继续读取。</p><p>每个prospector为它找到的每个文件保留一个状态。</p><p>由于文件可以被重命名或移动，因此文件名和路径不足以识别文件。</p><p>对于每个文件，Filebeat存储唯一标识符以检测文件是否先前已采集过。</p><p>如果您的使用案例涉及每天创建大量新文件，您可能会发现注册文件增长过大。请参阅注册表文件太大？编辑有关您可以设置以解决此问题的配置选项的详细信息。</p><h1 id="Filebeat如何确保至少一次交付"><a href="#Filebeat如何确保至少一次交付" class="headerlink" title="Filebeat如何确保至少一次交付"></a>Filebeat如何确保至少一次交付</h1><p>Filebeat保证事件至少会被传送到配置的输出一次，并且不会丢失数据。 Filebeat能够实现此行为，因为它将每个事件的传递状态存储在注册文件中。</p><p>在输出阻塞或未确认所有事件的情况下，Filebeat将继续尝试发送事件，直<br>到接收端确认已收到。</p><p>如果Filebeat在发送事件的过程中关闭，它不会等待输出确认所有收到事件。</p><p>发送到输出但在Filebeat关闭前未确认的任何事件在重新启动Filebeat时会再次发送。</p><p>这可以确保每个事件至少发送一次，但最终会将重复事件发送到输出。<br>也可以通过设置shutdown_timeout选项来配置Filebeat以在关闭之前等待特定时间。</p><p>注意：</p><p>Filebeat的至少一次交付保证包括日志轮换和删除旧文件的限制。如果将日志文件写入磁盘并且写入速度超过Filebeat可以处理的速度，或者在输出不可用时删除了文件，则可能会丢失数据。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html</a></p><p><a href="https://blog.51cto.com/lansonli/5283480" target="_blank" rel="noopener">https://blog.51cto.com/lansonli/5283480</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ELK日志追踪</title>
    <link href="http://raptor1998.top/2022/08/04/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA/"/>
    <id>http://raptor1998.top/2022/08/04/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-15T13:11:00.756Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先食用此篇<br><a href="https://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/">ELK日志收集</a></p><p>MDC（Mapped Diagnostic Context）用于存储运行上下文的特定线程的上下文数据。因此，如果使用 log4j 进行日志记录，则每个线程都可以拥有自己的MDC，该 MDC 对整个线程是全局的。属于该线程的任何代码都可以轻松访问线程的 MDC 中存在的值。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152105838.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Nacos单节点启动"><a href="#Nacos单节点启动" class="headerlink" title="Nacos单节点启动"></a>Nacos单节点启动</h1><p><code>./bin/startup.sh -m standalone</code></p><h1 id="logback日志增加traceid"><a href="#logback日志增加traceid" class="headerlink" title="logback日志增加traceid"></a>logback日志增加traceid</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志输出格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">"%d{yyyy-MM-dd HH:mm:ss.SSS} | [%thread] | %-5level | %logger{50} | %X{traceId} | [%method,%line] | %msg%n"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="给上下游服务添加过滤器获取traceid"><a href="#给上下游服务添加过滤器获取traceid" class="headerlink" title="给上下游服务添加过滤器获取traceid"></a>给上下游服务添加过滤器获取traceid</h1><p><strong>启动类添加扫描</strong></p><p><strong>@ServletComponentScan</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>,filterName = <span class="string">"traceIdFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MDC_TRACE_ID = <span class="string">"traceId"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>{</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">        String traceId = httpRequest.getHeader(MDC_TRACE_ID);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(traceId)) {</span><br><span class="line">            traceId = IdUtil.fastSimpleUUID();;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" traceId "</span> + traceId);</span><br><span class="line">        MDC.put(MDC_TRACE_ID, traceId);</span><br><span class="line">        ThreadLocalUtils.setTraceId(traceId);</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        httpResponse.setHeader(MDC_TRACE_ID, traceId);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="调用者改造OpenFeign"><a href="#调用者改造OpenFeign" class="headerlink" title="调用者改造OpenFeign"></a>调用者改造OpenFeign</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>{</span><br><span class="line">        String traceId = MDC.get(TraceIdFilter.MDC_TRACE_ID);</span><br><span class="line">        System.out.println(<span class="string">"OpenFeignRequestInterceptor traceId "</span> + traceId);</span><br><span class="line">        requestTemplate.header(TraceIdFilter.MDC_TRACE_ID, traceId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152105857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ELK日志收集</title>
    <link href="http://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-08-15T13:04:09.666Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="日志收集意义"><a href="#日志收集意义" class="headerlink" title="日志收集意义"></a>日志收集意义</h1><p>分析日志是工程师发现问题，解决系统故障的主要手段。日志主要包括系统日志、应用程序日志和安全日志。</p><p>一般大型系统是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。通常，日志被分散的储存在不同的设备上。如果管理数十上百台服务器，还在使用依次登录每台机器的传统方法查阅日志，既繁琐又效率低下。为此，我们可以使用集中化的日志管理，例如：开源的 syslog，将所有服务器上的日志收集汇总。</p><p>集中化管理日志后，日志的统计和检查又成为一件比较麻烦的事情，一般我们使用 grep、awk 和 wc 等 Linux 命令能实现检索和统计，但是对于更高要求的查询、排序和统计等，再加上庞大的机器数量，使用这样的方法依然难免有点力不从心。</p><p>开源实时日志分析 ELK 平台能够完美的解决我们上述的问题，ELK 由 ElasticSearch、Logstash 和 Kibana 这三个开源工具组成。</p><h1 id="ELK组成"><a href="#ELK组成" class="headerlink" title="ELK组成"></a>ELK组成</h1><p>Elasticsearch、Logstash 和 Kibana 三个开源工具配合使</p><ul><li>filebeat：部署在需要采集日志的各个服务器上，负责监听log文件，Filebeat会将日志数据收集并结构化后传输到Logstash上；</li><li>Logstash：负责将日志进行过滤、收集，再传输到Elasticsearch上；</li><li>Elasticsearch：负责把日志作为索引进行存储并且构造对应倒排索引；</li><li>Kibana：负责可视化呈现日志，需要查询时Kibana调用Elasticsearch进行日志数据的查询；</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152053343.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Quick-Start——监听nginx日志"><a href="#Quick-Start——监听nginx日志" class="headerlink" title="Quick Start——监听nginx日志"></a>Quick Start——监听nginx日志</h1><h2 id="安装filebeat"><a href="#安装filebeat" class="headerlink" title="安装filebeat"></a>安装filebeat</h2><p><code>tar -zxvf filebeat-7.7.0-linux-x86_64.tar.gz</code></p><h2 id="监听nginx的accss-log并输出到es"><a href="#监听nginx的accss-log并输出到es" class="headerlink" title="监听nginx的accss.log并输出到es"></a>监听nginx的accss.log并输出到es</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/local/nginx/logs/*.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["nginx"]</span></span><br><span class="line"><span class="attr">steup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["114.116.32.159:9200"]</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="kinaba展示日志并制作柱状图"><a href="#kinaba展示日志并制作柱状图" class="headerlink" title="kinaba展示日志并制作柱状图"></a>kinaba展示日志并制作柱状图</h1><h2 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h2><p>略</p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>Visualize选择柱状图并选择filebeat输出的nginx索引</p><p>Y轴位数量   X轴以时间为单位</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152056092.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Metricbeat监听状态"><a href="#Metricbeat监听状态" class="headerlink" title="Metricbeat监听状态"></a>Metricbeat监听状态</h1><h2 id="nginx安装状态模块"><a href="#nginx安装状态模块" class="headerlink" title="nginx安装状态模块"></a>nginx安装状态模块</h2><h1 id="收集自定义服务的日志"><a href="#收集自定义服务的日志" class="headerlink" title="收集自定义服务的日志"></a>收集自定义服务的日志</h1><h2 id="Java服务"><a href="#Java服务" class="headerlink" title="Java服务"></a>Java服务</h2><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">3</span>){</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat slf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        String format = slf.format(date);</span><br><span class="line">        log.info(<span class="string">"hello info,{}"</span>,format);</span><br><span class="line">        log.debug(<span class="string">"hello debug,{}"</span>,format);</span><br><span class="line">        log.error(<span class="string">"hello error,{}"</span>,format);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"log hello"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">xmlns</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback</span></span></span><br><span class="line"><span class="tag"><span class="string">               https://raw.githubusercontent.com/enricopulatzo/logback-XSD/master/src/main/xsd/logback.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"/Users/bytedance/IdeaProjects/bytestudy/ELK/log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"clr"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wex"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wEx"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">"%d{yyyy-MM-dd HH:mm:ss.SSS} | [%thread] | %-5level | %logger{50} | [%method,%line] | %msg%n"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/info-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是INFO级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/error-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是ERROR级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"sqlAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/infoSql.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/infoSql-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是ERROR级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis log configure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.apache.ibatis"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Connection"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Statement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.PreparedStatement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--系统操作日志--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;root level="INFO"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;/root&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置自己写的代码的日志记录器    对应包里面的日志才会被记录  additivity表示我们自定义的日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.raptor"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.raptor.system.mapper"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"sqlAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h2><h3 id="监听Java服务的日志并输出到logstach"><a href="#监听Java服务的日志并输出到logstach" class="headerlink" title="监听Java服务的日志并输出到logstach"></a>监听Java服务的日志并输出到logstach</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/Users/bytedance/IdeaProjects/bytestudy/ELK/log/error.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["elkdemo"]</span></span><br><span class="line"><span class="attr">steup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="comment">#output.elasticsearch:</span></span><br><span class="line"><span class="comment">#  hosts: ["114.116.32.159:9200"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["127.0.0.1:5044"]</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="Logstach"><a href="#Logstach" class="headerlink" title="Logstach"></a>Logstach</h2><h3 id="简单测试控制台输出"><a href="#简单测试控制台输出" class="headerlink" title="简单测试控制台输出"></a>简单测试控制台输出</h3><p><code>./logstash -e "input {stdin {}} output {stdout{}}"</code></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152058000.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>监听5044 接收filebeat的输入 并输出 到控制台</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152058020.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input {</span><br><span class="line">  beats {</span><br><span class="line">    port =&gt; "5044"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output{</span><br><span class="line">        stdout{codec =&gt; rubydebug}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#output {</span><br><span class="line">#  elasticsearch {</span><br><span class="line">#    hosts =&gt; ["http://192.168.42.111:9200"]</span><br><span class="line">#    index =&gt; "mylogstash1"</span><br><span class="line">#    #user =&gt; "elastic"</span><br><span class="line">#    #password =&gt; "changeme"</span><br><span class="line">#  }</span><br><span class="line">#}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="输出到es"><a href="#输出到es" class="headerlink" title="输出到es"></a>输出到es</h2><h3 id="添加split效果"><a href="#添加split效果" class="headerlink" title="添加split效果"></a>添加split效果</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">         "input" =&gt; {</span><br><span class="line">        "type" =&gt; "log"</span><br><span class="line">    },</span><br><span class="line">           "ecs" =&gt; {</span><br><span class="line">        "version" =&gt; "1.10.0"</span><br><span class="line">    },</span><br><span class="line">          "tags" =&gt; [</span><br><span class="line">        [0] "elkdemo",</span><br><span class="line">        [<span class="number">1</span>] <span class="string">"beats_input_codec_plain_applied"</span></span><br><span class="line">    ],</span><br><span class="line">       "message" =&gt; [</span><br><span class="line">        [0] "2022-07-27 22:45:20.653 ",</span><br><span class="line">        [1] " [http-nio-8080-exec-1] ",</span><br><span class="line">        [2] " ERROR ",</span><br><span class="line">        [3] " com.raptor.elk.controller.LogController ",</span><br><span class="line">        [4] " [hello,28] ",</span><br><span class="line">        [<span class="number">5</span>] <span class="string">" hello error,22-7-27 下午10:45"</span></span><br><span class="line">    ],</span><br><span class="line">          "host" =&gt; {</span><br><span class="line">        "name" =&gt; "C02G94S8ML7H"</span><br><span class="line">    },</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">    "@timestamp" =&gt; 2022-07-27T14:45:24.480Z,</span><br><span class="line">         "agent" =&gt; {</span><br><span class="line">                "name" =&gt; "C02G94S8ML7H",</span><br><span class="line">                  "id" =&gt; "94db4c0d-006c-4e8a-999c-35e57c97099f",</span><br><span class="line">                "type" =&gt; "filebeat",</span><br><span class="line">             "version" =&gt; "7.14.0",</span><br><span class="line">        "ephemeral_id" =&gt; "bc8ce9a9-62c1-43f4-9826-e2f17a51cbe4",</span><br><span class="line">            "hostname" =&gt; "C02G94S8ML7H"</span><br><span class="line">    },</span><br><span class="line">           "log" =&gt; {</span><br><span class="line">          "file" =&gt; {</span><br><span class="line">            "path" =&gt; "/Users/bytedance/IdeaProjects/bytestudy/ELK/log/error.log"</span><br><span class="line">        },</span><br><span class="line">        "offset" =&gt; 1543</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="conf"><a href="#conf" class="headerlink" title=".conf"></a>.conf</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">input {</span><br><span class="line">  beats {</span><br><span class="line">    port =&gt; "5044"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">filter {</span><br><span class="line">    mutate{</span><br><span class="line">        split =&gt; {"message"=&gt;"|"}</span><br><span class="line">        }</span><br><span class="line">    mutate{</span><br><span class="line">        add_field =&gt; {</span><br><span class="line">                "controllerName" =&gt; "%{[message][3]}"</span><br><span class="line">                "errorMessage" =&gt; "%{[message][5]}"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    mutate{</span><br><span class="line">        convert =&gt; {</span><br><span class="line">                "controllerName" =&gt; "string"</span><br><span class="line">                "errorMessage" =&gt; "string"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output{</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        stdout{codec =&gt; rubydebug}</span></span><br><span class="line"><span class="meta">#</span><span class="bash">}</span></span><br><span class="line"></span><br><span class="line">output {</span><br><span class="line">  elasticsearch {</span><br><span class="line">    hosts =&gt; ["http://114.116.32.159:9200"]</span><br><span class="line">    index =&gt; "elkdemo"</span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="comment">#user =&gt; "elastic"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="comment">#password =&gt; "changeme"</span></span></span><br><span class="line">         }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="kibana制作表盘"><a href="#kibana制作表盘" class="headerlink" title="kibana制作表盘"></a>kibana制作表盘</h2><h3 id="访问量柱形图"><a href="#访问量柱形图" class="headerlink" title="访问量柱形图"></a>访问量柱形图</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100032.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100071.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="表格展示"><a href="#表格展示" class="headerlink" title="表格展示"></a>表格展示</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100090.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="制作一个简单的表盘"><a href="#制作一个简单的表盘" class="headerlink" title="制作一个简单的表盘"></a>制作一个简单的表盘</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152104124.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>同时监控多套环境、多个项目的日志：由于我们的测试环境和开发环境内网在同一个网段下，因此我基于多个（dev+test）环境创建了多个项目的索引，以dev、test开头作为索引的名称，以此区分环境类型，在索引列表中可手动切换索引查看对应项目的日志，无需像往常一样登录多台服务器、打开多个窗口；</li><li>不占用服务器资源：Elasticsearch、Logstash、Kibana分别部署在多台服务器上，Filebeat仅部署在需要采集日志的服务器上，它们彼此通过内外相互联通，因此并不会集中占用内存、CPU等资源；</li><li>外网访问，通过浏览器即可随时随地访问，无需任何工具：另由于Kibana所在的服务器可以通过外网IP访问，因此，即使回到家中，也能通过浏览器实时访问到各个环境下各个项目的日志信息；<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li>搭建过程较为繁琐：Elasticsearch、Logstash、Kibana、Filebeat等多个服务需要分别部署，在此过程中可能遇到各种问题；</li><li>日志访问有延时：由于日志的收集、过滤、解析需要一定的时间，因此，当发起请求后，并不能像命令行或浏览器的F12工具一样，在ELK实时看到响应日志信息，会带有5-10s左右的延时；</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal原理</title>
    <link href="http://raptor1998.top/2022/07/20/ByteStudy%20canal%E5%8E%9F%E7%90%86/"/>
    <id>http://raptor1998.top/2022/07/20/ByteStudy%20canal%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-08-23T12:41:14.688Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Canal工作原理"><a href="#Canal工作原理" class="headerlink" title="Canal工作原理"></a>Canal工作原理</h1><p>Canal是模拟Mysql主从复制原理。将自己伪装成Slave。向主库发起dump协议，拿到bin_log日志，解析之后对数据做相关操作</p><h1 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h1><h2 id="为什么要主从"><a href="#为什么要主从" class="headerlink" title="为什么要主从"></a>为什么要主从</h2><ol><li>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li>做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。</li><li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li>数据分布 (Data distribution )</li><li>负载平衡(load balancing)</li><li>数据备份(Backups) ，保证数据安全</li><li>高可用性和容错性(High availability and failover)</li><li>实现读写分离，缓解数据库压力</li></ul><p>注意：由于 mysql 实现的异步复制，所以主库和从库数据之间存在一定的差异，在从库执行查询操作需要考虑这些数据的差异，一般只有更新不频繁和对实时性要求不高的数据可以通过从库查询，实行要求高的仍要从主库查询。</p><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ol><li>读写分离<br>在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换(主从切换)<br>提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据；</li><li>高可用（HA）<br>1）因为数据库服务器中的数据都是相同的，当Master挂掉后，可以指定一台Slave充当Master继续保证服务的运行，因为数据是一致性的（如果当插入时Master就挂掉，可能不一致，因为同步也需要时间）当然这种配置不是简单的把一台Slave充当Master，毕竟还要考虑后续的Slave的数据同步到Master<br>2）在主服务器上执行写入和更新，在从服务器上向外提供读功能，达到读写分离的效果，也可以动态地调整从服务器的数量，从而调整整个数据库的性能。<br>3）在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li><li>架构扩展<br>随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h2 id="复制的基本过程"><a href="#复制的基本过程" class="headerlink" title="复制的基本过程"></a>复制的基本过程</h2><ol><li>在从节点上执行sart slave命令开启主从复制开关，开始进行主从复制。从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li><li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）；</li><li>从节点的I/O进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的relay-log（中继日志）的文件（Mysql-relay-bin.xxx）的最末端，并将读取到的binary log（bin-log）文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li><li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在主节点上实际执行过SQL语句，然后在本数据库中按照解析出来的顺序执行，并在relay-log.info中记录当前应用中继日志的文件名和位置点。</li></ol><h1 id="Canal会不会丢失数据"><a href="#Canal会不会丢失数据" class="headerlink" title="Canal会不会丢失数据"></a>Canal会不会丢失数据</h1><ol><li>ZK的数据可靠性或者安全性被破坏，比如ZK数据丢失，ZK的数据被人为串改，特别是有关Position的值。</li><li>MySQL binlog非正常运维，比如binglog迁移、重命名、丢失等。</li><li>切换MySQL源，比如原来基于M1实例，后来M1因为某种原因失效，那么Canal将数据源切换为M2，而且M1和M2可能binlog数据存在不一致（非常有可能）。</li><li>Consumer端ACK的时机不佳，比如调用get()方法，而不是getWithoutAck()，那么消息有可能尚未完全消费，就已经ACK，那么此时由异常或者Consumer实例失效，则可能导致消息丢失。我们需要在ACK时机上保障“at lease once”。</li></ol><h1 id="Canal会导致消息重复吗"><a href="#Canal会导致消息重复吗" class="headerlink" title="Canal会导致消息重复吗"></a>Canal会导致消息重复吗</h1><ol><li>Canal 实例初始化时，根据“消费者的Cursor”来确定binlog的起始位置，但是Cursor在ZK中的保存是滞后的（间歇性刷新），所以Canal 实例获得的起始位置一定不会大于消费者真实已见的位置。</li><li>客户端，因为某种原因的rollback，也可能导致一个batch内的所有消息重发，此时可能导致重复消费。</li></ol><p>我们建议，Consumer端需要保持幂等，对于重复数据可以进行校验或者replace。对于非幂等操作，比如累加、计费，需要慎重。</p><h1 id="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"><a href="#Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？" class="headerlink" title="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"></a>Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？</h1><p>比如有两个客户端集群，C1/C2，你希望C1和C2中的消费者都能够订阅到相同的消息，就像Kafka或者JMS Topic一样…但是非常遗憾，似乎Canal无法做到，这取决于Canal内部的存储模式，Canal内部是一个“即发即失”的内存队列，无法权衡、追溯不同客户端之间的消息，所以无法支持。</p><p>如果希望达到这种结果，有2个办法：第一，消费者收到消息以后转发到kafka或者MQ中，后继的其他客户端只与kafka或者MQ接入；第二：一个Canal中使用多个目的地，但是它们对应相同的MySQL源。</p><h1 id="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？-1"><a href="#Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？-1" class="headerlink" title="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"></a>Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？</h1><p>比如有两个客户端集群，C1/C2，你希望C1和C2中的消费者都能够订阅到相同的消息，就像Kafka或者JMS Topic一样…但是非常遗憾，似乎Canal无法做到，这取决于Canal内部的存储模式，Canal内部是一个“即发即失”的内存队列，无法权衡、追溯不同客户端之间的消息，所以无法支持。</p><p>如果希望达到这种结果，有2个办法：第一，消费者收到消息以后转发到kafka或者MQ中，后继的其他客户端只与kafka或者MQ接入；第二：一个Canal中使用多个目的地，但是它们对应相同的MySQL源。</p><h1 id="Canal性能如何？"><a href="#Canal性能如何？" class="headerlink" title="Canal性能如何？"></a>Canal性能如何？</h1><p>Canal本身非常轻量级，主要性能开支就是在binlog解析，其转发、存储、提供消费者服务等都很简单。它本身不负责数据存储。原则上，canal解析效率几乎没有负载，canal的本身的延迟，取决于其与slave之间的网络IO。<br>如果Canal更换上游的主库或者从库，该怎么办？（比如迁库、迁表等）<br>背景要求，我们建议“新的数据库最好是旧的数据库的slave”或者“新、旧数据库为同源master”，平滑迁移；</p><pre><code>1）创建一个新的实例，使用新的目的地，并与新的Slave创建连接。2）在此期间，Consumer仍然与旧的目的地消费。3）通过“timestamp”确认，新的slave的最近binlog至少已经超过此值。4）Consumer切换，使用新的目的地消费，可能会消费到重复数据，但是不会导致数据丢失。</code></pre><p>当然，更简单的办法就是直接将原目的地中的数据库地址跟新即可，前提是新、旧两个数据库同源master，新库最好已经同步执行了一段时间。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/K_520_W/article/details/117135287" target="_blank" rel="noopener">mysql主从复制原理_爱上口袋的天空的博客-CSDN博客_mysql主从复制的原理</a><br><a href="https://blog.csdn.net/qq_36971119/article/details/122856561" target="_blank" rel="noopener">Canal原理及其使用_②⑦丶的博客-CSDN博客_canal</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal adaptor同步es</title>
    <link href="http://raptor1998.top/2022/07/18/ByteStudy-canal%E5%90%8C%E6%AD%A5es/"/>
    <id>http://raptor1998.top/2022/07/18/ByteStudy-canal%E5%90%8C%E6%AD%A5es/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-08-15T12:31:28.377Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="canal-工作原理"><a href="#canal-工作原理" class="headerlink" title="canal 工作原理"></a>canal 工作原理</h1><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul><h1 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h1><p>90%的问题都能在issues找到</p><p><a href="https://github.com/alibaba/canal/issues" target="_blank" rel="noopener">https://github.com/alibaba/canal/issues</a></p><h1 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">srcDataSources:</span></span><br><span class="line">    <span class="attr">defaultDS:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/canal?useUnicode=true&amp;useSSL=false</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">canalAdapters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">instance:</span> <span class="string">example</span> <span class="comment"># canal instance Name or mq topic name</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line">      <span class="attr">outerAdapters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">es7</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">exampleKey</span></span><br><span class="line">        <span class="attr">hosts:</span> <span class="number">114.116</span><span class="number">.32</span><span class="number">.159</span><span class="string">:9200</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">rest</span> <span class="comment"># or rest</span></span><br><span class="line">          <span class="comment"># security.auth: test:123456 #  only used for rest mode</span></span><br><span class="line">          <span class="attr">cluster.name:</span> <span class="string">elasticssearch</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="配置conf-es7-xxx-yml"><a href="#配置conf-es7-xxx-yml" class="headerlink" title="配置conf/es7/xxx.yml"></a>配置conf/es7/xxx.yml</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataSourceKey:</span> <span class="string">defaultDS</span> <span class="comment">#和上面canal.conf.srcDataSources.defaultDS要一样</span></span><br><span class="line"><span class="attr">outerAdapterKey:</span> <span class="string">exampleKey</span> <span class="comment">#和上面canal.conf.canalAdapters.instance.groups.outerAdapters.key要一样</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">example</span> <span class="comment">#和上面canal.conf.canalAdapters.instance要一样</span></span><br><span class="line"><span class="attr">groupId:</span> <span class="string">g1</span> <span class="comment">#和上面canal.conf.canalAdapters.instance.groups.groupId要一样</span></span><br><span class="line"><span class="attr">esMapping:</span></span><br><span class="line">  <span class="attr">_index:</span> <span class="string">test</span> <span class="comment">#索引名称</span></span><br><span class="line">  <span class="attr">_id:</span> <span class="string">_id</span> <span class="comment">#documentid</span></span><br><span class="line">  <span class="attr">_type:</span> <span class="string">_doc</span> <span class="comment"># type</span></span><br><span class="line"><span class="comment">#  upsert: true</span></span><br><span class="line"><span class="comment">#  pk: id</span></span><br><span class="line">  <span class="attr">sql:</span> <span class="string">"select a.id as _id, a.name_cn, a.name_en, a.email</span></span><br><span class="line"><span class="string">        from user a"</span>  <span class="comment"># 查询的sql返回的结构要使用as别名和es的filed对应</span></span><br><span class="line"><span class="comment">#  objFields:</span></span><br><span class="line"><span class="comment">#    _labels: array:;</span></span><br><span class="line">  <span class="attr">commitBatch:</span> <span class="number">3000</span> <span class="comment">#批量提交数量</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="es创建索引"><a href="#es创建索引" class="headerlink" title="es创建索引"></a>es创建索引</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT http://114.116.32.159:9200/test</span><br><span class="line">{</span><br><span class="line">    <span class="attr">"settings"</span>: {</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span>: <span class="number">2</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"mappings"</span>: {</span><br><span class="line">        <span class="attr">"properties"</span>: {</span><br><span class="line">            <span class="attr">"name_cn"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"name_en"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"email"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h1><p><code>curl http://localhost:8081/etl/es7/exampleKey/mytest_user.yml -X POST</code></p><p>params即 p.id&gt;{}的参数<br><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152029118.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="究极踩坑指南"><a href="#究极踩坑指南" class="headerlink" title="究极踩坑指南"></a>究极踩坑指南</h1><blockquote><p>mysql链接异常：Host is blocked because of many connection errors</p></blockquote><p><a href="https://blog.csdn.net/weixin_50180533/article/details/125254466" target="_blank" rel="noopener">MySQL 报错ERROR 1129 Host is blocked because of many connection errors。_皱皱小菜鸡的博客-CSDN博客</a></p><blockquote><p>Es failed driuid异常</p></blockquote><p><a href="https://github.com/alibaba/canal/issues/3466#issuecomment-825494336" target="_blank" rel="noopener">github.com</a></p><p>大多数并不适用，更换alpha2的es7依赖是亲测有效</p><blockquote><p>全量更新Task not found </p></blockquote><p>url格式为<a href="http://localhost:8081/etl/es7/exampleKey/mytest_user.yml" target="_blank" rel="noopener">http://localhost:8081/etl/es7/exampleKey/mytest_user.yml</a></p><p>application.yml 的 key: exampleKey   和   xxxyml的 key对应</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/Day_Day_No_Bug/article/details/116748553?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-116748553-blog-120271777.pc_relevant_sortByStrongTime&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-116748553-blog-120271777.pc_relevant_sortByStrongTime&amp;utm_relevant_index=5" target="_blank" rel="noopener">CanalAdapter同步ES7(全量&amp; 增量)_如果悲伤有颜色，那么一定是黄昏的博客-CSDN博客_canal 首次全量同步</a></p><p><a href="https://blog.csdn.net/qq_32419139/article/details/125232695" target="_blank" rel="noopener">2022-06-10 通过canal将mysql数据同步到es中_寂寞旅行的博客-CSDN博客</a></p><p><a href="https://github.com/alibaba/canal/issues/3714" target="_blank" rel="noopener">全量同步任务提示找不到任务 · Issue #3714 · alibaba/canal</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal监听</title>
    <link href="http://raptor1998.top/2022/07/16/ByteStudy-canal%E7%9B%91%E5%90%AC/"/>
    <id>http://raptor1998.top/2022/07/16/ByteStudy-canal%E7%9B%91%E5%90%AC/</id>
    <published>2022-07-15T16:00:00.000Z</published>
    <updated>2022-08-15T12:31:34.976Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p> Canal 是用 Java 开发的基于数据库增量日志解析，提供增量数据订阅&amp;消费的中间件。目前。Canal 主要支持了 MySQL 的 Binlog 解析，解析完成后才利用 Canal Client 来处理获得的相关数据。</p><h1 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h1><p>它记录了所有的 DDL 和 DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。<br>见末尾</p><h1 id="canal安装配置"><a href="#canal安装配置" class="headerlink" title="canal安装配置"></a>canal安装配置</h1><h2 id="canal-properties"><a href="#canal-properties" class="headerlink" title="canal.properties"></a>canal.properties</h2><p>canal.destinations = example</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014912.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>example/instance.properties</p><p>伪装从节点</p><p><strong>canal.instance.mysql.slaveId=20</strong></p><p>mysql服务地址</p><p><strong>canal.instance.master.address=127.0.0.1:3306</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014888.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>伪装成 Slave</p><h3 id="mysql的主从复制"><a href="#mysql的主从复制" class="headerlink" title="mysql的主从复制"></a>mysql的主从复制</h3><ol><li>Master 主库将改变记录，写到二进制日志(BinLog)中;</li><li>Slave 从库向 MySQL Master 发送 dump 协议，将 Master 主库的 binary log events 拷贝<br>到它的中继日志(relay log);</li><li>Slave 从库读取并重做中继日志中的事件，将改变的数据同步到自己的数据库。</li></ol><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启binlog，并设置为ROW格式</span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">开启binlog日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog-format=Row</span><br></pre></td></tr></tbody></table></figure></div><p>查看模式<code>show variables like 'binlog_format'</code></p><p>给canal添加一个读角色</p><p><code>GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%' IDENTIFIED BY 'canal' ;</code></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>{</span><br><span class="line">    <span class="comment">//1.获取 canal 连接对象</span></span><br><span class="line">    CanalConnector canalConnector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">"114.116.32.159"</span>, <span class="number">11111</span>), <span class="string">"example"</span>, <span class="string">"canal"</span>, <span class="string">"canal"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        canalConnector.connect();</span><br><span class="line">        <span class="comment">// 3.指定要监控的数据库</span></span><br><span class="line">        <span class="comment">// 配指定数据库只监听到了事务结束开始，所以直接配置全部</span></span><br><span class="line">        canalConnector.subscribe(<span class="string">".*\\..*"</span>);</span><br><span class="line">        <span class="comment">//4.获取 Message</span></span><br><span class="line">        Message message = canalConnector.get(<span class="number">100</span>);</span><br><span class="line">        List&lt;CanalEntry.Entry&gt; entries = message.getEntries();</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &lt;= <span class="number">0</span>) {</span><br><span class="line">            System.out.println(<span class="string">"没有数据"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.Entry entry : entries) {</span><br><span class="line">                <span class="comment">//获取表名</span></span><br><span class="line">                String tableName = entry.getHeader().getTableName();</span><br><span class="line">                <span class="comment">//Entry 类型</span></span><br><span class="line">                CanalEntry.EntryType entryType = entry.getEntryType();</span><br><span class="line">                <span class="comment">//判断 entryType 是否为 ROWDATA</span></span><br><span class="line">                <span class="keyword">if</span> (CanalEntry.EntryType.ROWDATA.equals(entryType)) {</span><br><span class="line">                    <span class="comment">//序列化数据</span></span><br><span class="line">                    ByteString storeValue = entry.getStoreValue();</span><br><span class="line">                    <span class="comment">//反序列化</span></span><br><span class="line">                    CanalEntry.RowChange rowChange = CanalEntry.RowChange.parseFrom(storeValue);</span><br><span class="line">                    <span class="comment">//获取事件类型</span></span><br><span class="line">                    CanalEntry.EventType eventType = rowChange.getEventType();</span><br><span class="line">                    <span class="comment">//获取具体的数据</span></span><br><span class="line">                    List&lt;CanalEntry.RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">                    <span class="comment">//遍历并打印数据</span></span><br><span class="line">                    <span class="keyword">for</span> (CanalEntry.RowData rowData : rowDatasList) {</span><br><span class="line">                        JSONObject beforeData = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                        List&lt;CanalEntry.Column&gt; beforeColumnsList = rowData.getBeforeColumnsList();</span><br><span class="line">                        <span class="keyword">for</span> (CanalEntry.Column column : beforeColumnsList) {</span><br><span class="line">                            beforeData.put(column.getName(), column.getValue());</span><br><span class="line">                        }</span><br><span class="line">                        JSONObject afterData = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                        List&lt;CanalEntry.Column&gt; afterColumnsList = rowData.getAfterColumnsList();</span><br><span class="line">                        <span class="keyword">for</span> (CanalEntry.Column column : afterColumnsList) {</span><br><span class="line">                            afterData.put(column.getName(), column.getValue());</span><br><span class="line">                        }</span><br><span class="line">                        System.out.println(<span class="string">"TableName:"</span> + tableName + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"EventType:"</span> + eventType + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"before:"</span> + beforeData + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"After:"</span> + afterData);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    System.out.println(<span class="string">"操作类型为："</span> + entryType);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> course <span class="keyword">SET</span> course_name = <span class="string">"增量多个更新"</span>,chapter_num=<span class="number">3</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014928.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="监测不到ROWDATA类型"><a href="#监测不到ROWDATA类型" class="headerlink" title="监测不到ROWDATA类型"></a>监测不到ROWDATA类型</h2><p>修改instance.properties的正则</p><p><code>canal.instance.filter.black.regex=.*\\..*</code></p><p>客户端设置</p><p><code>CanalConnector.subscribe(".*\\..*")</code></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.kancloud.cn/wenshunbiao/wenshunbiao/1403850" target="_blank" rel="noopener">mysql查看binlog日志 · 小温笔记 · 看云</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">MySQL三大日志(binlog、redo log和undo log)详解</a></p><p><a href="https://www.csdn.net/tags/NtzacgysMDkyMjctYmxvZwO0O0OO0O0O.html" target="_blank" rel="noopener">canal.instance.filter.black.regex - CSDN</a></p><p><a href="https://blog.csdn.net/Watermelon1986/article/details/121536631" target="_blank" rel="noopener">Canal部署运行问题记录_Watermel0n丶的博客-CSDN博客_canal启动很慢</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Month 1</title>
    <link href="http://raptor1998.top/2022/07/10/ByteDance4/"/>
    <id>http://raptor1998.top/2022/07/10/ByteDance4/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:55.729Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h2><hr><p>呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p><hr><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142218372.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a><br>我的状态完全和樱木刚开始接触篮球一样，啥也不会，自己还挺有想法</p><blockquote><p>如何评价“樱木花道”这个人物？</p></blockquote><blockquote><p>樱木花道从一个自负、无知、单纯而且有点爱惹祸的小年轻，后来因为他心目中的女生晴子小姐而彻底改变了自己，成为一个刻苦上进，最终当上篮球手而且努力使自己做到了“灌篮高手”的境界。</p></blockquote><p>实习到目前已经一个月出头，前面两周都在看文档，熟悉业务，参与回归测试，其实对于自身技术上的成长可以说是几乎没有，只能靠自己探索内部基础工具的实现原理学习技术，毕竟业务这东西，对于目前的工作意义非凡，但对于个人成长来说，更多的还是业务背后的技术沉淀</p><p>第一次独立处理需求，PM是新加坡人，万幸的是她讲中文，还不算难理解，对于测试用例的编写还算有点新的理解，第一次写，更多的还是站在开发的角度去考虑事情，去扣一些极端操作，反而忽略了用户操作，对于功能测试来讲，更多的还是偏重于用户角度，这时其实就在思考测试岗位存在的意义了，毕竟之前在校内开发，写完代码，自测没问题就直接上了，并没有专门的同学把关</p><p>目前收获最大的的是学习需求上线流程，敏捷迭代的各时间点工作</p><h2 id="换线"><a href="#换线" class="headerlink" title="换线"></a>换线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142211306.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>本来高高兴兴，ld拉了一个群，群里只有ld、我、mentor和未来的新mentor，就说了一句话，长期支持一下非中机器人的方向，当我看到这个消息和上图表情一模一样，难顶。。。</p><p>SMB的业务还没完全理解，刚处理了两个需求，还都没有完全上线，一个外部依赖，另一个历史逻辑太多，理解的有点慢，现在又要去接触一个新的业务，我这短短几个月的实习里，若是按照目前的强度来看，我这实习期间可能并不会接触多过多的东西</p><h2 id="新业务线"><a href="#新业务线" class="headerlink" title="新业务线"></a>新业务线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142216915.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>SMB一共处理了两个需求，还有一个因为外部依赖没能上线，现在新业务线是基础服务，业务好理解，就是智能问答，多轮对话，提供工具，为客增赋能，让销售们更好的、更快的解决问题，类似于辅助型对话机器人</p><h3 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h3><p>问答：通过机器人发起提问，权限以及其他的一些校验通过后，将信息打包给KE，KE进行意图分析（KE可以理解为卧龙为KE提供了训练模型的数据，读书期间研究方向有部分nlp相关，目前在做的主要是自动构建领域KG），KE将分析的数据返回飞书卡片，测试根据会话人的部分、角色等判定是否返回某些FAQ的答案，然后根据用户的交互行为卧龙返回对应数据</p><p>人工：会话服务将从KE获取的用户意图以及用户部门等信息，发送给卧龙后台，卧龙后台查找符合条件的值班客服信息并返回给会话服务</p><p> 多轮对话：目前还没涉及，应该很有意思，根据之前的理解，对于NLP相关的，随着trans(E\H……)系列问世，再加上各类变形，bert等，有简单了解过基于知识图谱的KBQA</p><h3 id="新小组"><a href="#新小组" class="headerlink" title="新小组"></a>新小组</h3><p>随着业务线的更换，mentor也换了，看来是不用回去了，同时过来的还有之前租的rd同学，但是他支持一个月还要回去的。。。</p><p>换座位，周五开完最后一个smb的迭代总结会议，晚上就换座位了，都不认识，基本有问题就问新mentor和之前组的xiayan，最难受的是啥，就是我刚换完座位，立刻就有人坐在了我原来的位置，其实本来应该他过来这边，但是好像因为需求紧急，我来了有一点时间，已经熟悉的差不多了，换组的成本不大，就让我来了，那我只能一遍呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Week 4</title>
    <link href="http://raptor1998.top/2022/06/28/ByteDance2/"/>
    <id>http://raptor1998.top/2022/06/28/ByteDance2/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:44.861Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="入职第四周"><a href="#入职第四周" class="headerlink" title="入职第四周"></a>入职第四周</h1><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p> <a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142146986.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142128353.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>怎么说呢，除了有点卷，没什么个人时间，工作内容不符合我的预期，餐厅吃够了，天天当混子之外，其他的都还可以</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142148721.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142149703.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="业务线"><a href="#业务线" class="headerlink" title="业务线"></a>业务线</h2><p>万万没想到，目前最大的阻碍竟然是英语，面试的时候可没提过这个事，所在的团队是 Non-China 线，小组是 SMB，小微企业的跟进，PM 多是外国人，每日站会他们参与就要用英文，包括新的需求 PRD 以及迭代会议的总结，看我 mentor 之前说的英文不是事，再看看她在站会和迭代上讲的熟练程度，说她英语专业毕业我都信……</p><p>每天九点半左右去吃早餐，准备一下开始新一天的工作，十点半开每日站会，前面几天，每天都用同样的句式，</p><ul><li>Today I will continue to learn basic components and understand general business operations</li><li>Today I will continue to learn basic components and learn agile software development</li><li>learn develop and test process specification</li><li>Today I will write test case for pitch planner and understand interface logic</li><li>learn how to test</li><li>Contact other needs and sort out relevant businesses</li><li>“Living to death” related documents, and alarm learning</li></ul><p>“熟悉文档，学习说啥啥啥”，下迭代我要参与到站会的主持中去，难顶，这个迭代要记录 todo，后续还要参与到火车轮班，虽然现在还知道是啥，盲猜就是服务发布相关的东西</p><p>刚上没几天班，我旁边带我熟悉的军哥晋升奶爸，直接休假都七月多，（写到这赶紧停下来，去买个小礼物，过几天回来恭喜一下）此时就又换了一位组内成员夏嫣带我熟悉业务，前面一周多是以熟悉文档为主，包括几种平台的使用，非常枯燥，实际上的使用还得是在实践中了解，纸上谈兵的看意义不大，甚至没有真正理解；第二三周开始接触业务，跟着夏嫣、凤琳做一些回归测试，熟悉业务为主，目前针对业务的理解，实际上简单概括可以分为几个大角色，广告主、销售，因为是变现中台，按业务模块，简单概括用户管理，线索发现，商机管理，业务跟进，数据分析。目前在接触最多的业务属于定时任务的一块，将一些某些条件的广告主筛选出来，推进某些流程中，由业务进行跟进，可能没有 C 端产品好理解，但都是基于 C 端产品的，Tik Tok 等<br>截止到目前，处理了两个需求，都是和新加坡的 winter 对接的，pitch planner 相关的（这块原本是要我接受的，但是军哥陪产假，没人带着熟悉，所以后续嗯可能接手夏嫣 program 那块），后端改动不大的那种，多是一些前端的改造，通过 Charles 做一些断点即可</p><p>团队内的自动化测试工具，ate，基于 pytest 写的， 在 win 下安装出现了很多独占问题，为了避免后续我本地 win 可以运行，其他人或容器无法运行，又要重新 debug，非常低效，这周申请更换了 mac pro，其实入职申请的就是 mac，只不过不给我</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135241.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然了，虽然工作内容不符合预期，吃的还是不错的，疯狂炫零食饮料，包括其他也可以看很多其他东西的，内部的一些文章，架构都是可以学习的，QA 工作一部分也是要看 RD 代码，所以还是可惜学习一下如何设计的，比如在 shopify program 这块业务线，针对 cronjob 实际上，按照我预想的设计，就只是简单的在容器中设置一个定时任务，但是在实际此处的实现，还是与我想的有差别的，通过自定义注解，将所有将要执行的任务注册进容器中，然后在启动类中实现 CommandLineRunner，每次对定时任务的调度通过任务名实现，可以避免我们单个服务一直占用资源，而且可以随时对任务进行调度，说到这，我再次期间还犯了个错，在第一次进行定时任务测试的时候，将定时任务跑到了线上环境，造成当天的定时任务跑了两次，第二天策略同学火速赶来，应为数据对不上，还好没造成太大影响，不然直接因 P0 事故被开除。此次之后，我就小心了，每次操作前都反复跟组内的人确认，讲真，当时完全是认为工作枯燥，干完收工的一个心态</p><p>在实习期间，还要处理之前学校的项目，进入二期，讲给师弟，完全手把手交，人都麻了，又赶上服务器前移，溜了几个查询语句号让他们上手，将近一个月，毫无进展，当然，维护过程中，还是有收获，比如在 nginx 配置 https，但是此时服务不开放 443 如何解决等问题，说实话，对于此类项目，不该找连几行点吗都没写过的来维护，毕竟真实在用的业务，不断的新需求与更改，可能给后面接手的人造成更大的麻烦</p><h2 id="发钱了"><a href="#发钱了" class="headerlink" title="发钱了"></a>发钱了</h2><p>不说了，按天结算，算不错账<br>字节不打卡，考勤完全自己报，leader 审批通过了就行，问题很大，狗头……可能是怕打卡的话员工搞事，十点上班起点正常下班，but 实际大家上到九点十点，无脑卷，资本家的糖衣炮弹让人疯狂，我直接 反卷先锋 贴在飞书</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135561.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="春游"><a href="#春游" class="headerlink" title="春游"></a>春游</h2><p>竟然是死去的春游，实验室竟然还没忘记春游，现在夏天都快过完了<br>啥峡谷漂流来着，机智如我，有四个小机灵鬼没去，听说有人失温了，那天感觉是最近俩月最冷的一天，十几度吧，加上下雨，收集 n 张票，开了 n 次越野，攀岩 n 次，射击 n 次，</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142145894.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142136693.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance week 3</title>
    <link href="http://raptor1998.top/2022/06/25/ByteDance5/"/>
    <id>http://raptor1998.top/2022/06/25/ByteDance5/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-08-15T12:39:01.340Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h1><p>从高空看program这块业务，实际上通过cronjob的手段将符合预定条件的广告主添加进某个流程中（Handraiser、payment ready……），并赋予一些相关的状态标签，切换拥有者，为owner添加其目前的分配数量，判断条件来源于tcc</p><p>目前理解的tcc是类似spring cloud config </p><hr><p>从代码层面看，通过定时任务，检索配置，推进流程：实现ApplicationListener&lt; ContextRefreshedEvent&gt;一般被用于在项目初始化动作完成后执行的自己业务拓展动作，作为应用初始化完毕后执行的动作（先InitializingBean）获取加Schedule注解的类，将任务注册进taskRegMap中，实现CommandLineRunner接口，容器启动之后，加载实现类的逻辑资源，已达到完成资源初始化的任务，然后准备执行任务，调用TaskInvoker 的 invoke 方法，从taskRegisterListener中获取任务实例执行：获取TCC配置，不等步长获取需要检测的adv，对获取到的实体进行条件检测，符合条件进行下一步推进</p><h1 id="小组氛围"><a href="#小组氛围" class="headerlink" title="小组氛围"></a>小组氛围</h1><p>组内一共五个人，三位女生，另一位男生休陪产假目前接触还不是很多，前面一周都是跟着junge去吃的，现在恰饭都是我一个人，妈耶，孤单。。。mentor她们喜欢吃盒饭，我觉得有点难顶，所以都是自己去食堂，偶尔她们吃餐厅才会一起。</p><p>感觉mentor怀孕有点不喜欢说话，每次碰到我也不知道说啥玩意好，可能是因为是小组长，不能跟你嬉皮笑脸的吧（狗头保命）</p><p>业务都是我旁边的xiayan在带，人美心善就是她了，感觉还没我年龄大。<br>业务上关键是我啥也不会，问的我都不好意思再问了。。。这里要吐槽一下，字节这内部平台也太多了，而且感觉全是在市面上的工具的改版，功能上可能差不多，但是用法上可能会有很大差距</p><p>这边一般九点下班（2022.8.3半夜前来更新，还没下班。。。麻了），太难了，抛出房租、生活费，希望我的实习期间能剩下个学费的钱。。。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142254091.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>希望能在实习过程中，接触更多技术相关的东西，像樱木一样，从初学者到”灌篮高手“在短短几个月完成蜕变</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142253172.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Culture</title>
    <link href="http://raptor1998.top/2022/06/20/ByteDance3/"/>
    <id>http://raptor1998.top/2022/06/20/ByteDance3/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:50.362Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="始终创业"><a href="#始终创业" class="headerlink" title="始终创业"></a>始终创业</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142151560.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li><p>保持创业心态，始终开创而不守成，创新而非依赖资源</p></li><li><p>敏捷有效，最简化流程，避免简单事情复杂化</p></li><li><p>对外敏锐谦逊，避免自满或优越感</p><h1 id="多元兼容"><a href="#多元兼容" class="headerlink" title="多元兼容"></a>多元兼容</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200521.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></li><li><p>欣赏个体多样性，聚焦人的核心特质</p></li><li><p>全球视角，理解不同文化、观点和实践</p></li><li><p>善意假设，默认开放信任，有效合作</p></li></ul><h1 id="坦诚清晰"><a href="#坦诚清晰" class="headerlink" title="坦诚清晰"></a>坦诚清晰</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200247.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>表达真实想法，不怕暴露问题，反对”向上管理”</li><li>准确、简洁、直接，少用抽象、模糊、空泛的词</li><li>就事论事，理性沟通，避免主观臆测和情绪化表达</li></ul><h1 id="求真务实"><a href="#求真务实" class="headerlink" title="求真务实"></a>求真务实</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201517.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>独立思考，刨根问底，找到本质</li><li>直接体验，深入事实，拿一手数据或信息</li><li>不自嗨，注重实际效果</li></ul><h1 id="敢为极致"><a href="#敢为极致" class="headerlink" title="敢为极致"></a>敢为极致</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201235.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>敢于为了更好的结果明智地冒险，注重整体ROI</li><li>尝试多种可能性，在更大范围里找最优解</li><li>追求卓越，高标准，不仅做了，更要做好</li></ul><h1 id="共同成长"><a href="#共同成长" class="headerlink" title="共同成长"></a>共同成长</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201471.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>相信并认可使命和愿景，基于使命愿景自驱</li><li>面对短期波动有耐心、有韧性，共同解决问题</li><li>持续学习，不设边界，与组织一起成长</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
