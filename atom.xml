<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raptor&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raptor1998.top/"/>
  <updated>2022-02-24T09:39:06.705Z</updated>
  <id>http://raptor1998.top/</id>
  
  <author>
    <name>陳 ？</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM——垃圾回收篇</title>
    <link href="http://raptor1998.top/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"/>
    <id>http://raptor1998.top/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/</id>
    <published>2022-01-19T16:00:00.000Z</published>
    <updated>2022-02-24T09:39:06.705Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h1><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。 </p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：</p><ul><li><p>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</p></li><li><p>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173812.png" data-fancybox="group" data-caption="image-20200712102205795" class="fancybox"><img alt="image-20200712102205795" title="image-20200712102205795" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173812.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>{</span><br><span class="line">    <span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line">    <span class="comment">//java 使用的不是引用计数算法</span></span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173807.png" data-fancybox="group" data-caption="image-20200712103230349" class="fancybox"><img alt="image-20200712103230349" title="image-20200712103230349" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173807.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>“GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173803.png" data-fancybox="group" data-caption="image-20200712104149246" class="fancybox"><img alt="image-20200712104149246" title="image-20200712104149246" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173803.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（string Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize（）方法<ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>{</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173756.png" data-fancybox="group" data-caption="image-20220107153758261" class="fancybox"><img alt="image-20220107153758261" title="image-20220107153758261" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173756.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p><strong>标记</strong>：Collector从引用根节点开始遍历，</p><p>标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p><p><strong>标记的是引用的对象，不是垃圾！！</strong></p></li><li><p><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p></li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173750.png" data-fancybox="group" data-caption="image-20200712150935078" class="fancybox"><img alt="image-20200712150935078" title="image-20200712150935078" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173750.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候 提过</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173745.png" data-fancybox="group" data-caption="image-20200712151916991" class="fancybox"><img alt="image-20200712151916991" title="image-20200712151916991" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173745.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173740.png" data-fancybox="group" data-caption="image-20200712153236508" class="fancybox"><img alt="image-20200712153236508" title="image-20200712153236508" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173740.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h4><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul><li><p>Java虚拟机的堆内存设置不够。</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p></li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏</p><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p><blockquote><p>Java不同版本新特性</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li></ul></blockquote><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173734.png" data-fancybox="group" data-caption="image-20200713083030867" class="fancybox"><img alt="image-20200713083030867" title="image-20200713083030867" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173734.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173729.png" data-fancybox="group" data-caption="image-20200713083443486" class="fancybox"><img alt="image-20200713083443486" title="image-20200713083443486" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173729.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java堆区所占的内存大小。</li><li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h3 id="性能指标：吞吐量"><a href="#性能指标：吞吐量" class="headerlink" title="性能指标：吞吐量"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><blockquote><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173724.png" data-fancybox="group" data-caption="image-20200713084726176" class="fancybox"><img alt="image-20200713084726176" title="image-20200713084726176" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173724.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="性能指标：暂停时间"><a href="#性能指标：暂停时间" class="headerlink" title="性能指标：暂停时间"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p><p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173721.png" data-fancybox="group" data-caption="image-20200713085306400" class="fancybox"><img alt="image-20200713085306400" title="image-20200713085306400" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173721.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><p>那么，Java常见的垃圾收集器有哪些？</p><blockquote><p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p></blockquote><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li></ul><h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G11</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173715.png" data-fancybox="group" data-caption="image-20200713093551365" class="fancybox"><img alt="image-20200713093551365" title="image-20200713093551365" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173715.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173712.png" data-fancybox="group" data-caption="image-20200713093757644" class="fancybox"><img alt="image-20200713093757644" title="image-20200713093757644" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173712.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1；</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173703.png" data-fancybox="group" data-caption="image-20200713094745366" class="fancybox"><img alt="image-20200713094745366" title="image-20200713094745366" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173703.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li><li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li></ul><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial 0ld在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173700.png" data-fancybox="group" data-caption="image-20200713100703799" class="fancybox"><img alt="image-20200713100703799" title="image-20200713100703799" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173700.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><p>等价于新生代用Serial GC，且老年代用Serial old GC</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173653.png" data-fancybox="group" data-caption="image-20200713102030127" class="fancybox"><img alt="image-20200713102030127" title="image-20200713102030127" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p></li></ul><p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173650.png" data-fancybox="group" data-caption="image-20200713110359441" class="fancybox"><img alt="image-20200713110359441" title="image-20200713110359441" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173650.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p><p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p><p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p><p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173644.png" data-fancybox="group" data-caption="image-20200713205154007" class="fancybox"><img alt="image-20200713205154007" title="image-20200713205154007" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173644.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173638.png" data-fancybox="group" data-caption="image-20200713212230352" class="fancybox"><img alt="image-20200713212230352" title="image-20200713212230352" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173638.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="CMS为什么不使用标记整理算法？"><a href="#CMS为什么不使用标记整理算法？" class="headerlink" title="CMS为什么不使用标记整理算法？"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li></ul><p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p><ul><li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li></ul><p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><ul><li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li><li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li></ul><p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li></ul><h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><h3 id="为什么名字叫-Garbage-First-G1-呢？"><a href="#为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫 Garbage First(G1)呢？"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p><h3 id="G1垃圾收集器的优点"><a href="#G1垃圾收集器的优点" class="headerlink" title="G1垃圾收集器的优点"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173631.png" data-fancybox="group" data-caption="image-20200713215105293" class="fancybox"><img alt="image-20200713215105293" title="image-20200713215105293" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173631.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>而是这样的一个区域</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173628.png" data-fancybox="group" data-caption="image-20200713215133839" class="fancybox"><img alt="image-20200713215133839" title="image-20200713215133839" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173628.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p><h3 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p><ul><li>超过5e%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于e.5至1秒）</li></ul><p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p><p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173615.png" data-fancybox="group" data-caption="image-20200713223244886" class="fancybox"><img alt="image-20200713223244886" title="image-20200713223244886" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173615.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过指针碰撞来分配空间</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173609.png" data-fancybox="group" data-caption="image-20200713223509993" class="fancybox"><img alt="image-20200713223509993" title="image-20200713223509993" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173609.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173604.png" data-fancybox="group" data-caption="image-20200713224113996" class="fancybox"><img alt="image-20200713224113996" title="image-20200713224113996" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173604.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173558.png" data-fancybox="group" data-caption="image-20200713224716715" class="fancybox"><img alt="image-20200713224716715" title="image-20200713224716715" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173558.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173553.png" data-fancybox="group" data-caption="image-20200713225100632" class="fancybox"><img alt="image-20200713225100632" title="image-20200713225100632" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173553.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根</li></ul><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><ul><li>第二阶段，更新RSet</li></ul><p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li>第三阶段，处理RSet</li></ul><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><ul><li>第四阶段，复制对象。</li></ul><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><ul><li>第五阶段，处理引用</li></ul><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173547.png" data-fancybox="group" data-caption="image-20200713225810871" class="fancybox"><img alt="image-20200713225810871" title="image-20200713225810871" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173547.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p><p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="G1回收可选的过程4-Full-GC"><a href="#G1回收可选的过程4-Full-GC" class="headerlink" title="G1回收可选的过程4 - Full GC"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p><ul><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖</li></ul><p>暂停时间目标暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173542.png" data-fancybox="group" data-caption="image-20200714075738203" class="fancybox"><img alt="image-20200714075738203" title="image-20200714075738203" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173542.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173531.png" data-fancybox="group" data-caption="image-20200714080151020" class="fancybox"><img alt="image-20200714080151020" title="image-20200714080151020" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173531.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="推荐笔记"><a href="#推荐笔记" class="headerlink" title="推荐笔记"></a>推荐笔记</h1><p> <strong><a href="https://gitee.com/moxi159753" target="_blank" rel="noopener">陌溪</a> / <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">LearningNotes</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JVM
    
    </summary>
    
    
      <category term="JVM" scheme="http://raptor1998.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://raptor1998.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM——内存篇</title>
    <link href="http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/</id>
    <published>2021-12-14T16:00:00.000Z</published>
    <updated>2022-02-24T09:31:25.754Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="内存篇"><a href="#内存篇" class="headerlink" title="内存篇"></a>内存篇</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" data-fancybox="group" data-caption="image-20200705081813409" class="fancybox"><img alt="image-20200705081813409" title="image-20200705081813409" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" data-fancybox="group" data-caption="image-20200705082255746" class="fancybox"><img alt="image-20200705082255746" title="image-20200705082255746" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>完整的流程图如下所示</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" data-fancybox="group" data-caption="image-20200705082601441" class="fancybox"><img alt="image-20200705082601441" title="image-20200705082601441" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" data-fancybox="group" data-caption="image-20200705103636003" class="fancybox"><img alt="image-20200705103636003" title="image-20200705103636003" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己创建一个java.lang的包并创建String类</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"自定义的String类"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">   public static void main(String[] args)</span></span><br><span class="line"><span class="comment">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" data-fancybox="group" data-caption="image-20200705112416101" class="fancybox"><img alt="image-20200705112416101" title="image-20200705112416101" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" data-fancybox="group" data-caption="image-20200705112601211" class="fancybox"><img alt="image-20200705112601211" title="image-20200705112601211" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><p><strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h4><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" data-fancybox="group" data-caption="image-20200705161409533" class="fancybox"><img alt="image-20200705161409533" title="image-20200705161409533" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h4><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>栈是运行时的单位，而堆是存储的单位。</strong></p><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。<strong>是线程私有的。</strong></p><h3 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h3><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p><p><strong>可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" data-fancybox="group" data-caption="image-20211228155503154" class="fancybox"><img alt="image-20211228155503154" title="image-20211228155503154" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" data-fancybox="group" data-caption="image-20211228195446901" class="fancybox"><img alt="image-20211228195446901" title="image-20211228195446901" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" data-fancybox="group" data-caption="image-20211229144922052" class="fancybox"><img alt="image-20211229144922052" title="image-20211229144922052" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><p><a href="https://blog.csdn.net/weixin_43723712/article/details/92187693" target="_blank" rel="noopener">i++与++i在JVM层面上的分析</a></p><p><a href="https://blog.csdn.net/weixin_38405253/article/details/118470431" target="_blank" rel="noopener">从JVM层面来解释i++和++i的真正区别</a></p><h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><ul><li><p>举例栈溢出的情况？（StackOverflowError）</p><ul><li>通过 -Xss设置栈的大小</li></ul></li><li><p>调整栈大小，就能保证不出现溢出么？</p><ul><li>不能保证不溢出</li></ul></li><li><p>分配的栈内存越大越好么？</p><ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li><p>垃圾回收是否涉及到虚拟机栈？</p><ul><li>不会</li></ul></li><li><p>方法中定义的局部变量是否线程安全？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>{</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p>一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h3><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区 Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。  </p><p><strong>-Xms300m -Xmx300m -XX:+PrintGCDetails</strong></p><p><strong>设置为300M却不足，是因为幸存区只能有一个用来存储。</strong>  </p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" data-fancybox="group" data-caption="image-20211230203337495" class="fancybox"><img alt="image-20211230203337495" title="image-20211230203337495" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" data-fancybox="group" data-caption="image-20200707075847954" class="fancybox"><img alt="image-20200707075847954" title="image-20200707075847954" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p> 配置新生代与老年代在堆结构的占比。</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" data-fancybox="group" data-caption="image-20200707080154039" class="fancybox"><img alt="image-20200707080154039" title="image-20200707080154039" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：<strong>-Xx:MaxTenuringThreshold= N</strong>进行设置</p><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" data-fancybox="group" data-caption="image-20200707084714886" class="fancybox"><img alt="image-20200707084714886" title="image-20200707084714886" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" data-fancybox="group" data-caption="image-20200707085737207" class="fancybox"><img alt="image-20200707085737207" title="image-20200707085737207" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="幸存者区空间不足"><a href="#幸存者区空间不足" class="headerlink" title="幸存者区空间不足"></a>幸存者区空间不足</h4><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" data-fancybox="group" data-caption="image-20200707091058346" class="fancybox"><img alt="image-20200707091058346" title="image-20200707091058346" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><ul><li><p>Minor GC：新生代的GC</p></li><li><p>Major GC：老年代的GC</p></li><li><p>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ul><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h3 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h3><h4 id="Q-堆空间都是共享的吗"><a href="#Q-堆空间都是共享的吗" class="headerlink" title="Q: 堆空间都是共享的吗"></a>Q: 堆空间都是共享的吗</h4><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h4 id="为什么有TLAB"><a href="#为什么有TLAB" class="headerlink" title="为什么有TLAB"></a>为什么有TLAB</h4><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h4 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h4><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" data-fancybox="group" data-caption="image-20200707103547712" class="fancybox"><img alt="image-20200707103547712" title="image-20200707103547712" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h4 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h4><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" data-fancybox="group" data-caption="image-20200707104253530" class="fancybox"><img alt="image-20200707104253530" title="image-20200707104253530" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h3><ul><li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li><li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li><li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li><li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li><li>-Xmn：设置新生代的大小。（初始值及最大值）</li><li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li><li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li><li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li><li>-XX：+PrintGCDetails：输出详细的GC处理日志<ul><li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li></ul></li><li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li></ul><h3 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBufferON</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果想要StringBuffer sb不发生逃逸，可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBufferOFF</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h5><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="如何解决方法区的OOM"><a href="#如何解决方法区的OOM" class="headerlink" title="如何解决方法区的OOM"></a>如何解决方法区的OOM</h3><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h3><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" data-fancybox="group" data-caption="image-20200708211541300" class="fancybox"><img alt="image-20200708211541300" title="image-20200708211541300" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>JDK7的时候</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" data-fancybox="group" data-caption="image-20200708211609911" class="fancybox"><img alt="image-20200708211609911" title="image-20200708211609911" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" data-fancybox="group" data-caption="image-20200708211637952" class="fancybox"><img alt="image-20200708211637952" title="image-20200708211637952" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h4><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h2><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>给对象属性赋值的操作</p><ul><li>属性的默认初始化</li><li>显示初始化</li><li>代码块中的初始化</li><li>构造器初始化</li><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li></ul><h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h4 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul><li>String：字符串，使用一对 ”” 引起来表示<ul><li>String s1 = “mogublog” ; // 字面量的定义方式</li><li>String s2 = new String(“moxi”);</li></ul></li><li>string声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul><h4 id="JDK9改变了结构"><a href="#JDK9改变了结构" class="headerlink" title="JDK9改变了结构"></a>JDK9改变了结构</h4><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">private final char value[];</span><br><span class="line">// 之后</span><br><span class="line">private final byte[] value</span><br></pre></td></tr></tbody></table></figure></div><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h4 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h4><p>String：代表不可变的字符序列。简称：不可变性。</p><blockquote><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">"def"</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">'a'</span>, <span class="string">'m'</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//hello</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//abcdef</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//mbc</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>{</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = {<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>{</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);   <span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);    <span class="comment">//best</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h3><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><blockquote><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p></blockquote><p>Java8元空间，字符串常量在堆</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" data-fancybox="group" data-caption="image-20200711093546398" class="fancybox"><img alt="image-20200711093546398" title="image-20200711093546398" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" data-fancybox="group" data-caption="image-20200711093558709" class="fancybox"><img alt="image-20200711093558709" title="image-20200711093558709" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h4><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h3 id="拼接操作"><a href="#拼接操作" class="headerlink" title="拼接操作"></a>拼接操作</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String s1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;  <span class="comment">// 得到 abc的常量池</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>; <span class="comment">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true，因为存放在字符串常量池</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    String src = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        src += <span class="string">"a"</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        sb.append(<span class="string">"a"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><h4 id="new-String-“as”-会创建几个对象"><a href="#new-String-“as”-会创建几个对象" class="headerlink" title="new String(“as”)会创建几个对象"></a>new String(“as”)会创建几个对象</h4><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><h4 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h4><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_44259720/article/details/88237822" target="_blank" rel="noopener">Java 定义字符串时：String 和 new String() 的区别</a></p><h3 id="美团：深入解析String-intern"><a href="#美团：深入解析String-intern" class="headerlink" title="美团：深入解析String#intern"></a><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团：深入解析String#intern</a></h3><h3 id="intern题目"><a href="#intern题目" class="headerlink" title="intern题目"></a>intern题目</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" data-fancybox="group" data-caption="image-20220107101214463" class="fancybox"><img alt="image-20220107101214463" title="image-20220107101214463" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" data-fancybox="group" data-caption="image-20220107101237047" class="fancybox"><img alt="image-20220107101237047" title="image-20220107101237047" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" data-fancybox="group" data-caption="image-20220107101245959" class="fancybox"><img alt="image-20220107101245959" title="image-20220107101245959" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="idea安装jclasslib"><a href="#idea安装jclasslib" class="headerlink" title="idea安装jclasslib"></a>idea安装jclasslib</h2><p>选中字节码文件，view中show With Jclasslib即可查看字节码指令</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" data-fancybox="group" data-caption="image-20211227170720770" class="fancybox"><img alt="image-20211227170720770" title="image-20211227170720770" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="Notepad-字节码"><a href="#Notepad-字节码" class="headerlink" title="Notepad++字节码"></a>Notepad++字节码</h2><p><a href="https://github.com/chcg/NPP_HexEdit/releases/tag/0.9.5.11" target="_blank" rel="noopener">HexEdit下载地址</a></p><p>下载对应版本的dll文件，在notepad++插件文件夹创建HexEdit文件夹，将解压的dll文件放入，重启即可。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" data-fancybox="group" data-caption="image-20211227170551121" class="fancybox"><img alt="image-20211227170551121" title="image-20211227170551121" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="VisualVM插件GC安装"><a href="#VisualVM插件GC安装" class="headerlink" title="VisualVM插件GC安装"></a>VisualVM插件GC安装</h2><p><a href="https://blog.csdn.net/weixin_45759791/article/details/107332860" target="_blank" rel="noopener">VisualVM安装VisualGC插件</a></p><p> <a href="https://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">Plugins Centers 插件中心</a></p><h1 id="推荐笔记"><a href="#推荐笔记" class="headerlink" title="推荐笔记"></a>推荐笔记</h1><p> <strong><a href="https://gitee.com/moxi159753" target="_blank" rel="noopener">陌溪</a> / <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">LearningNotes</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JVM
    
    </summary>
    
    
      <category term="JVM" scheme="http://raptor1998.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://raptor1998.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>uploader</title>
    <link href="http://raptor1998.top/2021/11/29/uploader/"/>
    <id>http://raptor1998.top/2021/11/29/uploader/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2022-02-24T09:49:08.593Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p><strong><a href="https://github.com/Raptor1998/uploader" target="_blank" rel="noopener">https://github.com/Raptor1998/uploader</a></strong></p><h1 id="Uploader"><a href="#Uploader" class="headerlink" title="Uploader"></a>Uploader</h1><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li>Springboot 2.3.5 </li><li>Mybatis 1.3.2</li></ul><h2 id="content-path"><a href="#content-path" class="headerlink" title="content-path"></a>content-path</h2><p><code>/api/uploader</code></p><h2 id="upload-request-process"><a href="#upload-request-process" class="headerlink" title="upload request process"></a>upload request process</h2><h3 id="second-upload"><a href="#second-upload" class="headerlink" title="second upload"></a>second upload</h3><ol><li>计算文件的md5值，查询是否已经存在</li><li>是，根据文件名称和md5值实现秒传；否，直接上传</li></ol><h3 id="block-upload"><a href="#block-upload" class="headerlink" title="block upload"></a>block upload</h3><ol><li><p>计算文件md5值，根据需求切片，得到总片数</p></li><li><pre><code class="java"><span class="comment">/**</span><span class="comment"> * 分块上传</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> originalName 文件原名</span><span class="comment"> * <span class="doctag">@param</span> file         文件</span><span class="comment"> * <span class="doctag">@param</span> chunks       共分几块</span><span class="comment"> * <span class="doctag">@param</span> chunk        第几块</span><span class="comment"> * <span class="doctag">@param</span> size         文件总大小</span><span class="comment"> * <span class="doctag">@param</span> md5          文件的md5</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="meta">@PostMapping</span>(<span class="string">"/block/single"</span>)<span class="function"><span class="keyword">public</span> Result <span class="title">uploadBigSingleFile</span><span class="params">(@RequestParam(<span class="string">"originalName"</span>)</span> String originalName,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"chunks"</span>)</span> Integer chunks,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"chunk"</span>)</span> Integer chunk,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"size"</span>)</span> Long size,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"md5"</span>)</span> String md5) </span>{    uploaderService.uploadWithBlock(originalName, file, chunks, size, chunk, md5);    <span class="keyword">return</span> ResultUtil.success(<span class="keyword">null</span>);}&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for block_file</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`block_file`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`block_file`</span>  (</span><br><span class="line">                               <span class="string">`block_file_id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">                               <span class="string">`block_file_chunk`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第几块'</span>,</span><br><span class="line">                               <span class="string">`block_file_md5`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'md5'</span>,</span><br><span class="line">                               <span class="string">`upload_time`</span> <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">COMMENT</span> <span class="string">'上传时间'</span>,</span><br><span class="line">                               <span class="string">`temp_path`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'临时文件的存储位置'</span>,</span><br><span class="line">                               PRIMARY <span class="keyword">KEY</span> (<span class="string">`block_file_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">                               <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`block_file_chunk`</span>(<span class="string">`block_file_chunk`</span>, <span class="string">`block_file_md5`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for file_info</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`file_info`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`file_info`</span>  (</span><br><span class="line">                              <span class="string">`file_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'文件详情'</span>,</span><br><span class="line">                              <span class="string">`file_original_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'原文件名'</span>,</span><br><span class="line">                              <span class="string">`file_union_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一标识'</span>,</span><br><span class="line">                              <span class="string">`file_real_path`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'真实路径'</span>,</span><br><span class="line">                              <span class="string">`file_suffix`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'拓展名'</span>,</span><br><span class="line">                              <span class="string">`file_url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'网络地址'</span>,</span><br><span class="line">                              <span class="string">`file_size`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文件大小'</span>,</span><br><span class="line">                              <span class="string">`file_upload_time`</span> <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">COMMENT</span> <span class="string">'上传时间'</span>,</span><br><span class="line">                              <span class="string">`md5`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文件的md5值'</span>,</span><br><span class="line">                              PRIMARY <span class="keyword">KEY</span> (<span class="string">`file_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">                              <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`file_union_name`</span>(<span class="string">`file_union_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8 <span class="keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="keyword">Compact</span>;</span><br></pre></td></tr></tbody></table></figure></div><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.jianshu.com/p/d58d275ac1f4?ivk_sa=1024320u" target="_blank" rel="noopener">文件上传工具类（JAVA）</a></p><p><a href="https://github.com/gaoyuyue/MyUploader-Backend" target="_blank" rel="noopener">gaoyuyue/MyUploader-Backend</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://raptor1998.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>高频面试 Ι</title>
    <link href="http://raptor1998.top/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/"/>
    <id>http://raptor1998.top/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2022-02-24T09:34:06.337Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><h2 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h2><p>赋值=，最后计算<br>=右边的从左到右加载至一次压入操作数栈<br>实际先算那个，看远算符优先级<br>自增、自减操作都是字节修改变量的值，不经过操作数栈<br>最后额赋值之前，临时结果也存储在操作数栈中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//i=1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=1</span></span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="comment">// j =1 i = 2</span></span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="comment">// k=11 j=1 i=4</span></span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">    System.out.println(<span class="string">"j="</span> + j);</span><br><span class="line">    System.out.println(<span class="string">"k="</span> + k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有一个实例</span></span><br><span class="line"><span class="comment"> * 必须自行创建这个实例</span></span><br><span class="line"><span class="comment"> * 向整个系统提供这个实例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 饿汉式：直接创建对象，不存在线程安全问题</span></span><br><span class="line"><span class="comment"> * 1.直接实例化饿汉式</span></span><br><span class="line"><span class="comment"> * 2.枚举式</span></span><br><span class="line"><span class="comment"> * 3.静态代码块（适合复杂实例化）</span></span><br><span class="line"><span class="comment"> * 懒汉式：延迟创建对象</span></span><br><span class="line"><span class="comment"> * 4.线程不安全（使用单线程）</span></span><br><span class="line"><span class="comment"> * 5.线程安全</span></span><br><span class="line"><span class="comment"> * 6.静态内部类（使用多线程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Singleton2 {</span><br><span class="line">    INSTANCE</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当string需要动态获取</span></span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        String s1 = <span class="string">"xxx"</span>;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton3(s1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//部分逻辑  线程不安全</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton5();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态被不累不会自动随着外部类的加载和初始化而初始化，他是单独去加载和初始化的</span></span><br><span class="line">    <span class="comment">//因为实在内部类加载和初始化，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1.j=method()</span></span><br><span class="line"><span class="comment"> * 2.父类的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 父类实例化方法：</span></span><br><span class="line"><span class="comment"> * 1.super()（最前）</span></span><br><span class="line"><span class="comment"> * 2.i=test()</span></span><br><span class="line"><span class="comment"> * 3.父类的非静态代码块</span></span><br><span class="line"><span class="comment"> * 4.父类的无参构造（最后）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 非静态方法前面有一个默认地向this</span></span><br><span class="line"><span class="comment"> * this在构造器或&lt;init&gt;()它表示的是正在创建的对象，因为这里创建的Son对象，所以</span></span><br><span class="line"><span class="comment"> * test()执行的是子类重写的代码</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这里i=test()执行的是子类重写的test()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"(1)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Father() {</span><br><span class="line">        System.out.println(<span class="string">"(2)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"(3)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(4)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(5)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1.j=method()</span></span><br><span class="line"><span class="comment"> * 2.子类的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 先初始化父类  （5）（1）</span></span><br><span class="line"><span class="comment"> * 初始化子类 （10） （6）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 子类实例化方法：</span></span><br><span class="line"><span class="comment"> * 1.super()（最前）  （9） （3） （2）</span></span><br><span class="line"><span class="comment"> * 2.i=test()          （9）</span></span><br><span class="line"><span class="comment"> * 3.子类的非静态代码块    （8）</span></span><br><span class="line"><span class="comment"> * 4.子类的无参构造（最后）   （7）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 因为创建了两个Son对象，因此实例化方法&lt;init&gt;()执行两次</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * （9） （3） （2） （9） （8） （7）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 哪些方法不能被重写：</span></span><br><span class="line"><span class="comment"> * final方法</span></span><br><span class="line"><span class="comment"> * 静态方法</span></span><br><span class="line"><span class="comment"> * private等子类中不可见方法</span></span><br><span class="line"><span class="comment"> * 对象的多态：</span></span><br><span class="line"><span class="comment"> * 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</span></span><br><span class="line"><span class="comment"> * 非静态方法默认的调用对象是this</span></span><br><span class="line"><span class="comment"> * this对象在构选器或者说&lt;init&gt;方法中就是正在创建的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"(6)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Son() {</span><br><span class="line">        <span class="comment">//super();   写或不写，在子类构造器中一定会调用父类的构造器</span></span><br><span class="line">        System.out.println(<span class="string">"(7)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"(8)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(9)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(10)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 类初始化过程：</span></span><br><span class="line"><span class="comment">         * 1.一个类的创建实例需要先加载初始化该类</span></span><br><span class="line"><span class="comment">         *      main方法所在的类需要先加载和初始化</span></span><br><span class="line"><span class="comment">         *      仅发生类初始化 ，不发生实例初始化 （5）（1）（10）（6）</span></span><br><span class="line"><span class="comment">         * 2.一个子类要初始化需要先初始化父类</span></span><br><span class="line"><span class="comment">         * 3.一个类初始化就是执行&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;clinit&gt;方法由静态类变量显示赋值代码和静态代码块组成</span></span><br><span class="line"><span class="comment">         *      类变量显式赋值代码和静态代码块代码从上到下顺序执行</span></span><br><span class="line"><span class="comment">         *      &lt;clinit&gt;方法只执行一次</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 实例初始化过程：</span></span><br><span class="line"><span class="comment">         * 1.实力初始化就是执行&lt;init&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;()方法可能重在有多个，有几个构造器就有几个&lt;init&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</span></span><br><span class="line"><span class="comment">         *      非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行</span></span><br><span class="line"><span class="comment">         *      每次创建实例对象，调用对应构造器，执行的就是对应的&lt;init&gt;方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;方法的首行是super()或super(实参列表)，即对应父类的&lt;init&gt;方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Son son1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son son2 = <span class="keyword">new</span> Son();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>方法重载的规则？</strong></p><p>方法名一致，参数列表中参数的顺序，类型，个数不同。</p><p>重载与方法的返回值无关，存在于父类和子类，同类中。</p><p>可以抛出不同的异常，可以有不同修饰符。</p><p><strong>方法重写的规则？</strong></p><p>参数列表、方法名、返回值类型必须完全一致，构造方法不能被重写；</p><p>声明为 final 的方法 不能被重写；</p><p>声明为 static 的方法不存在重写(重写和多态联合才有意义);</p><p>访问权限不能比 父类更低;重写之后的方法不能抛出更宽泛的异常</p><p><strong>重载和重写的区别？</strong></p><p>方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。</p><p>重写 Overriding 是父类与子类之间多态性的一种表现，</p><p>重载 Overloading 是一个类中多态性的一种表现。</p><p>如 果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽” 了。</p><p>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型， 则称为方法的重载(Overloading)。</p><h2 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"num="</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">"my.a="</span> + my.a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实参给形参赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 基本数据类型  数据值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 引用数据类型  地址值     String、包装类等对象不可变性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>{</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">"world"</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println( m.a);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="E:%5Cmaterial%5Cmd%5Cimage-20211109105042940.png" data-fancybox="group" data-caption="image-20211109105042940" class="fancybox"><img alt="image-20211109105042940" title="image-20211109105042940" data-src="E:%5Cmaterial%5Cmd%5Cimage-20211109105042940.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="E:%5Cmaterial%5Cmd%5Cimage-20211109105119544.png" data-fancybox="group" data-caption="image-20211109105119544" class="fancybox"><img alt="image-20211109105119544" title="image-20211109105119544" data-src="E:%5Cmaterial%5Cmd%5Cimage-20211109105119544.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h2><p>n个台阶，一次只能走一阶或两阶，问有多少种走法？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    System.out.println(go(<span class="number">4</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> go(n - <span class="number">2</span>) + go(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam6</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量：每个线程，每次调用执行的都是新的声明周期</span></span><br><span class="line"><span class="comment">     * 实例变量：随着对象的创建而初始化，随着对象的回收而消亡，每一个实例变量都是独立的</span></span><br><span class="line"><span class="comment">     * 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量：栈</span></span><br><span class="line"><span class="comment">     * 实例变量：堆</span></span><br><span class="line"><span class="comment">     * 类变量：方法去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//就近原则</span></span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//作用域</span></span><br><span class="line">        i++;</span><br><span class="line">        s++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Exam6 obj1 = <span class="keyword">new</span> Exam6();</span><br><span class="line">        Exam6 obj2 = <span class="keyword">new</span> Exam6();</span><br><span class="line">        obj1.test(<span class="number">10</span>);</span><br><span class="line">        obj1.test(<span class="number">20</span>);</span><br><span class="line">        obj2.test(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        i=2,j=1,s=5</span></span><br><span class="line"><span class="comment">        i=1,j=1,s=5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"i="</span> + obj1.i + <span class="string">",j="</span> + obj1.j + <span class="string">",s="</span> + s);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + obj2.i + <span class="string">",j="</span> + obj2.j + <span class="string">",s="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul><li><p>事务的属性</p><p>propagation：用来设置事务的传播行为</p><p>事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务</p><ul><li>Propagation.REQUIRED：默认值，使用原来的事务</li><li>Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务</li></ul></li><li><p>isolation：用来设置事物的隔离级别</p><ul><li><p>Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别</p></li><li><p>Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，并发誓通常使用的隔离级别 </p></li></ul></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>B2C电商实践</title>
    <link href="http://raptor1998.top/2021/10/15/B2C%E7%94%B5%E5%95%86/"/>
    <id>http://raptor1998.top/2021/10/15/B2C%E7%94%B5%E5%95%86/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2021-12-29T09:53:55.342Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="B2C"><a href="#B2C" class="headerlink" title="B2C"></a>B2C</h1><p>尚硅谷谷粒商城的demo及部分解决方法笔记，<strong>不是完整的代码</strong>。</p><p><a href="https://gitee.com/agoni_no/gulimall?_from=gitee_search" target="_blank" rel="noopener">夏沫止水/gulimall</a></p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="Nacos集群启动问题"><a href="#Nacos集群启动问题" class="headerlink" title="Nacos集群启动问题"></a>Nacos集群启动问题</h2><h3 id="数据库配置-bin"><a href="#数据库配置-bin" class="headerlink" title="数据库配置(bin/)"></a>数据库配置(bin/)</h3><p><code>将nacos-mysql.sql执行</code></p><h3 id="配置文件-conf"><a href="#配置文件-conf" class="headerlink" title="配置文件(conf/)"></a>配置文件(conf/)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################最后追加###################</span></span><br><span class="line"><span class="string">spring.datasource.platform=mysql</span></span><br><span class="line"></span><br><span class="line"><span class="string">db.num=1</span></span><br><span class="line"><span class="string">db.url.0=jdbc:mysql://127.0.0.1:3306/cloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="string">db.user=root</span></span><br><span class="line"><span class="string">db.password=****</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="配置cluster-conf"><a href="#配置cluster-conf" class="headerlink" title="配置cluster.conf"></a>配置cluster.conf</h3><p><strong>这个IP不能写127.0.0.1,必须是Linux命令hostname -i能够识别的IP</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp cluster.conf.example cluster.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置集群信息</span></span><br><span class="line">vim cluster.conf</span><br><span class="line"></span><br><span class="line">182.154.146.46:3333</span><br><span class="line">182.154.146.46:4444</span><br><span class="line">182.154.146.46:5555</span><br></pre></td></tr></tbody></table></figure></div><h3 id="启动脚本-bin"><a href="#启动脚本-bin" class="headerlink" title="启动脚本(bin/)"></a>启动脚本(bin/)</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175846.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175846.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175847.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175847.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p><strong>./startup.sh -p 3333</strong></p><h3 id="内存不足启动解决"><a href="#内存不足启动解决" class="headerlink" title="内存不足启动解决"></a>内存不足启动解决</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">standalone：表示单机模式运行，非集群模式</span><br><span class="line">-Xms: 设定程序启动时占用内存大小</span><br><span class="line">-Xmx: 设定程序运行期间最大可占用的内存大小</span><br><span class="line">-Xmn：新生代大小</span><br></pre></td></tr></tbody></table></figure></div><p><strong>JAVA_OPT=”${JAVA_OPT} -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m”</strong></p><p>更改为，比如，可根据机器调整</p><p><strong>JAVA_OPT=”${JAVA_OPT} -server -Xms300m -Xmx300m -Xmn100m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=160m”</strong></p><h3 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream cluster{                                                        </span><br><span class="line">    server 127.0.0.1:3333;</span><br><span class="line">    server 127.0.0.1:4444;</span><br><span class="line">    server 127.0.0.1:5555;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server{                       </span><br><span class="line">    listen 1111;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location /{</span><br><span class="line">         proxy_pass http://cluster;                                               </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="renren-fast-oss-报错问题"><a href="#renren-fast-oss-报错问题" class="headerlink" title="renren-fast oss 报错问题"></a>renren-fast oss 报错问题</h1><p><strong>依赖改为继承自root项目</strong></p><h1 id="idea热部署不生效"><a href="#idea热部署不生效" class="headerlink" title="idea热部署不生效"></a>idea热部署不生效</h1><ul><li><p><strong>File-Settings-Compiler-Build project automatically</strong></p></li><li><p><strong>ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running</strong></p></li></ul><h1 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h1><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="meta">@NotBlank</span>(message = <span class="string">"品牌名必须提交"</span>,groups = {AddGroup<span class="class">.<span class="keyword">class</span>,<span class="title">UpdateGroup</span>.<span class="title">class</span>})</span></span><br><span class="line"><span class="class">   给校验直接添加分组</span></span><br><span class="line"><span class="class">2. @<span class="title">Validated</span>(</span>{UpdateGroup<span class="class">.<span class="keyword">class</span>}) </span></span><br><span class="line"><span class="class">   标注校验的分组</span></span><br><span class="line"><span class="class">   默认没有指定的分组的注解，分组校验的情况下不会生效</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 编写自定义校验注解</span><br><span class="line"><span class="number">2</span>. 编写自定义校验器</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = {ListValueConstrainValidation<span class="class">.<span class="keyword">class</span>})</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>{ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue {</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>{com.raptor.common.valid.ListValue.message}<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default {};</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default {};</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] vals() default {};</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class ListValueConstrainValidation implements ConstraintValidator&lt;ListValue, Integer&gt; {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public void initialize(ListValue constraintAnnotation) {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        int[] vals = constraintAnnotation.vals();</span></span><br><span class="line"><span class="string">        for (int val : vals) {</span></span><br><span class="line"><span class="string">            set.add(val);</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    //判断是否校验成功</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public boolean isValid(Integer s, ConstraintValidatorContext constraintValidatorContext) {</span></span><br><span class="line"><span class="string">        return set.contains(s);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">3. 编写自定义的返回信息 ValidationMessages.properties</span></span><br><span class="line"><span class="string">com.raptor.common.valid.ListValue.message=必须是指定的值</span></span><br><span class="line"><span class="string">4. 关联自定义的校验器和自定义的注解</span></span><br><span class="line"><span class="string">@Constraint(validatedBy = {ListValueConstrainValidation.class})</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><h2 id="docker安装elasticsearch"><a href="#docker安装elasticsearch" class="headerlink" title="docker安装elasticsearch"></a>docker安装elasticsearch</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. 下载镜像</span><br><span class="line">docker pull elasticsearch:7.6.2</span><br><span class="line">2. 创建一个挂载目录</span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line">echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line">3. 启动</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300  -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx128m" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line">其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件</span><br><span class="line"></span><br><span class="line">4. 权限问题</span><br><span class="line">docker logs elasticsearch 查看日志 发现报无权限错误</span><br><span class="line">"Caused by: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes"</span><br><span class="line">添加权限</span><br><span class="line">chmod -R 777 /mydata/elasticsearch/</span><br><span class="line"></span><br><span class="line">-e "discovery.type=single-node" 设置为单节点</span><br><span class="line">-e ES_JAVA_OPTS="-Xms256m -Xmx256m" \ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 访问http://your ipadress:9200/   说明启动成功</span><br><span class="line">{</span><br><span class="line">  "name" : "26e50cad52d5",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "RrKY3rRZRW2nh7Ap-rIjvQ",</span><br><span class="line">  "version" : {</span><br><span class="line">    "number" : "7.6.2",</span><br><span class="line">    "build_flavor" : "default",</span><br><span class="line">    "build_type" : "docker",</span><br><span class="line">    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    "build_date" : "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "8.4.0",</span><br><span class="line">    "minimum_wire_compatibility_version" : "6.8.0",</span><br><span class="line">    "minimum_index_compatibility_version" : "6.0.0-beta1"</span><br><span class="line">  },</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="docker安装Kibana"><a href="#docker安装Kibana" class="headerlink" title="docker安装Kibana"></a>docker安装Kibana</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.6.2</span><br><span class="line"></span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://your ipaddress:9200 -p 5601:5601 -d kibana:7.6.2</span><br></pre></td></tr></tbody></table></figure></div><h1 id="nginx转发到网关时请求的host丢失"><a href="#nginx转发到网关时请求的host丢失" class="headerlink" title="nginx转发到网关时请求的host丢失"></a>nginx转发到网关时请求的host丢失</h1><p>xxx</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存溢出问题"><a href="#缓存溢出问题" class="headerlink" title="缓存溢出问题"></a>缓存溢出问题</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 性能优化  改为一次查询数据库</span></span><br><span class="line"><span class="comment">// 堆外内存溢出  springboot 2.0默认使用lettuce操作redis客户端  使用netty进行网络通信</span></span><br><span class="line"><span class="comment">// lettuce的bug导致netty堆外内存溢出   -Xmx300m  netty如果乜有指定堆外内存 默认使用 -Xmx300m 不能使用 可以通过 -Dio.netty.maxDirectMeory去调到堆外内存</span></span><br><span class="line"><span class="comment">// 解决方案：升级lettuce客户端    切换使用jedis</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>只查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，数据库无此记录，没有将null写到缓存，导致每次请求都要取存储层查询。</p><p>可以利用不存在的数据进行攻击，数据库压力增大，最终导致崩溃</p><p>解决方案：null结果缓存，并加入短暂过期时间</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>值设置缓存是key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到db，cb压力过大雪崩</p><p>原有的时效基础上增加一个随机值，比如1-5分钟随机，这样每个缓存的过期时间重复率就会降低，很难引发集体失效时间。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被炒高并发访问，是一种热点数据，如果这个key在大量请求同时进来前刚好失效，所有对这个key 的查询都落到db</p><p>解决：加锁，大量并发只让一个人去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据。</p><h2 id="redis的分布式锁"><a href="#redis的分布式锁" class="headerlink" title="redis的分布式锁"></a>redis的分布式锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占分布式锁</span></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>,TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock) {</span><br><span class="line">    System.out.println(<span class="string">"获取分布式锁成功"</span>);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//加锁成功</span></span><br><span class="line">        dataFromDb = getDataFromDb();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        <span class="comment">//删锁</span></span><br><span class="line">        stringRedisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList("lock"), uuid);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//只删除自己的锁</span></span><br><span class="line">    <span class="comment">//获取值对比，对比成功删除=原子性 lua脚本解锁</span></span><br><span class="line">    <span class="comment">//可能会出现删除其他线程锁的情况   在业务执行尾，获取到自己的数据后，传输过程中锁过期，执行删除锁命令，将其他线程锁删除</span></span><br><span class="line">    <span class="comment">// String lockValue = stringRedisTemplate.opsForValue().get("lock");</span></span><br><span class="line">    <span class="comment">// if (uuid.equals(lockValue)) {</span></span><br><span class="line">    <span class="comment">//     //只能删除我自己的锁</span></span><br><span class="line">    <span class="comment">//     stringRedisTemplate.delete("lock");</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataFromDb;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    System.out.println(<span class="string">"获取分布式锁失败"</span>);</span><br><span class="line">    <span class="comment">//加锁失败</span></span><br><span class="line">    <span class="keyword">try</span> { TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); } <span class="keyword">catch</span> (InterruptedException e) { e.printStackTrace(); }</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> getCatalogJsonFromDbWithRedisLock();     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><h3 id="双写模式（更新完数据更新缓存）"><a href="#双写模式（更新完数据更新缓存）" class="headerlink" title="双写模式（更新完数据更新缓存）"></a>双写模式（更新完数据更新缓存）</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171156.png" data-fancybox="group" data-caption="双写模式" class="fancybox"><img alt="双写模式" title="双写模式" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171156.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="失效模式（更新完数据缓存失效）"><a href="#失效模式（更新完数据缓存失效）" class="headerlink" title="失效模式（更新完数据缓存失效）"></a>失效模式（更新完数据缓存失效）</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171157.png" data-fancybox="group" data-caption="失效模式" class="fancybox"><img alt="失效模式" title="失效模式" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171157.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171350.png" data-fancybox="group" data-caption="缓存一致性解决方案" class="fancybox"><img alt="缓存一致性解决方案" title="缓存一致性解决方案" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171350.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h1><p>xxx</p><h1 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175322.png" data-fancybox="group" data-caption="image-20211119191231370" class="fancybox"><img alt="image-20211119191231370" title="image-20211119191231370" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175322.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175329.png" data-fancybox="group" data-caption="image-20211119191430478" class="fancybox"><img alt="image-20211119191430478" title="image-20211119191430478" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175329.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175335.png" data-fancybox="group" data-caption="image-20211119191131013" class="fancybox"><img alt="image-20211119191131013" title="image-20211119191131013" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175335.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175342.png" data-fancybox="group" data-caption="image-20211119191741406" class="fancybox"><img alt="image-20211119191741406" title="image-20211119191741406" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175342.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="异步-amp-线程池"><a href="#异步-amp-线程池" class="headerlink" title="异步&amp;线程池"></a>异步&amp;线程池</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集成Thread</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> * 实现Callable接口+futureTask</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Thread01 thread01 = new Thread01();</span></span><br><span class="line"><span class="comment">//thread01.start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Runnable01 runnable01 = new Runnable01();</span></span><br><span class="line"><span class="comment">//new Thread(runnable01).start();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable01());</span></span><br><span class="line"><span class="comment">//new Thread(futureTask).start();</span></span><br><span class="line"><span class="comment">////阻塞等待</span></span><br><span class="line"><span class="comment">//Integer integer = futureTask.get();</span></span><br><span class="line"><span class="comment">//System.out.println(integer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该将所有的异步任务都交给线程池执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int corePoolSize,  核心线程数，线程池创建号以后就准备就绪的线程数量，就等待接受异步任务去执行</span></span><br><span class="line"><span class="comment"> * 只要线程池不销毁，就一直存在   除非奢姿了这个allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * int maximumPoolSize,  最大的线程数量  控制资源并发</span></span><br><span class="line"><span class="comment"> * long keepAliveTime,  存活时间，当正在运行线程数量大于核心数量，回释放空闲的线程，</span></span><br><span class="line"><span class="comment"> * 只要线程空闲大于执行的存活时间，释放的线程等于maximumPoolSize-corePoolSize</span></span><br><span class="line"><span class="comment"> * TimeUnit unit, 时间单位</span></span><br><span class="line"><span class="comment"> * BlockingQueue&lt;Runnable&gt; workQueue, 阻塞队列 如果任务很多，将多余的任务放在队列里，有现成空闲就回去队列里取新的任务</span></span><br><span class="line"><span class="comment"> * ThreadFactory threadFactory,  线程创建工厂，</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler handler   如果队列满了，按照指定的拒绝策略，拒绝执行任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作顺序：</span></span><br><span class="line"><span class="comment"> * 1. 线程池创建号，准备好core的核心线程数量，准备接受任务</span></span><br><span class="line"><span class="comment"> * 2. 新的任务进来，用core准备好的空闲线程去执行</span></span><br><span class="line"><span class="comment"> *  （1）core满了，将再进来的任务放到阻塞队列中，空闲的core就会自己去阻塞队列获取任务</span></span><br><span class="line"><span class="comment"> *  （2）阻塞队列满了，就直接开新的线程执行，最大只能开到max指定的数量</span></span><br><span class="line"><span class="comment"> *  （3）max都执行好了，Max-core数量空闲的线程会在keepAliveTime指定的时间后自动销毁，最终保持到core大小</span></span><br><span class="line"><span class="comment"> *  （4）如果线程开到了max的数量，还有新任务进来，就会使用reject指定的拒绝策略进行处理</span></span><br><span class="line"><span class="comment"> * 3.所有的线程创建都是由指定的factory创建的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  一个线程池 core 7，max 20 ，queue 50   100并发进来怎么分配</span></span><br><span class="line"><span class="comment"> *  先执行7个，后续50个请求进队列，然后创建13个新线程执行，</span></span><br><span class="line"><span class="comment"> *  现在执行了 7 + 13 个  50个在队列中   剩下30执行拒绝策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  new LinkedBlockingDeque&lt;&gt;()  默认integer的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">7</span>,</span><br><span class="line">                <span class="number">20</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"当前执行的线程是："</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }, String.valueOf(i)));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main....end"</span>);</span><br><span class="line">        executor.shutdown();</span><br></pre></td></tr></tbody></table></figure></div><h1 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h1><p>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。</p><ul><li><p>token机制</p><ol><li>服务端提供了发送token接口。那些业务存在幂等问题，就必须在这之前执行，先去获取token，服务器把token保存到redis</li><li>然后调用业务接口请求时，把token携带过去，一般放在请求头部</li><li>服务器判断是否存在redis中，存在表示第一次请求，然后删除token，继续执行业务</li><li>如果判断token不存在redis中，则表示是重复操作，直接返回重读标记给client</li></ol><p>危险性：</p><ul><li><p>先删除还是后删除token</p><ul><li><p>先删除可能导致，业务确实没有执行，重试还带上之前的token，由于防虫设计导致，接口还是不能执行</p><p>即分布式系统中两次请求同时从redis中取得token，服务端均校验通过，同时执行了业务</p></li><li><p>后删可能导致，业务处理成功，但是服务闪断，出现超时，没有删除token，继续重试，导致业务被执行两次+</p></li><li><p>最好设计为先删除token，如果业务嗲用失败，就重新获取token在此请求</p></li></ul></li><li><p>token获取、比较和删除必须是原子性</p><ul><li><p>redis.get(token)、token.equals、redis.del(token)如果这两个操作不是院子，可能导致，高并发下，都得到同样的token，判断都成功，继续业务并发执行</p></li><li><p>可以再redis使用lua脚本完成这个操作</p><p>if redis.call(‘get’,KEYS[1]) == ARGV[1] then return redis.call(‘del’,KEYS[1]) else return 0 end</p></li></ul></li></ul></li><li><p>锁机制</p><ul><li><p>数据库悲观锁</p><p>悲观锁使用时一般伴随事务一起使用,数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id字段一定是主键或者唯一索引不然可能造成锁表的结息，处理起来会非常麻烦。</p></li><li><p>数据库乐观锁</p><p>这种方法适合在更新的场景中,</p><p>updatet_goods set count = count -1 , version = version + 1 where good_id=2 and version= 1根据version 版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version 变成了2;但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行:因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</p><p>乐观锁主要使用于处理读多写少的问题</p></li><li><p>业务层分布式锁</p><p>如果多个机器可能在同一时间同时处理相同的数据,比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</p></li></ul></li><li><p>各种唯一约束</p><ul><li><p>数据库唯一约束</p><p>插入数据,应该按照唯一索引进行插入，比如订单号,相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。<br>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键,这样就需要业务生成全局唯一的主键。<br>如果是分库分表场景下，路由规则要保证相同请求下,落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p></li><li><p>redis set 防重</p><p>很多数据需要处理，只能被处理一次,比如我们可以计算数据的 MD5将其放入redis 的 set,每次处理数据,先看这个MD5是否已经存在,存在就不处理。</p></li></ul></li><li><p>防重表<br>  使用订单号 orderNo做为去重表的唯一索引,把唯一索引插入去重表,再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败,避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p></li><li><p>全局请求唯一id<br>调用接口时,生成一个唯一id,redis 将数据保存到集合中（去重)，存在即处理过。可以使用 nginx设置每一个请求的唯一 id;</p><p>proxy_set_header X-Request-ld Srequest_id;</p></li></ul><h1 id="本地事务与分布式事务"><a href="#本地事务与分布式事务" class="headerlink" title="本地事务与分布式事务"></a>本地事务与分布式事务</h1><p>事务保证：</p><ol><li><p>订单服务异常，库存锁定不运行，全部回滚，撤销操作</p></li><li><p>库存服务事务自制，锁定失败全部回滚，订单感受到继续回滚</p></li><li><p>库存服务锁定成功，但是网络原因返回数据途中问题</p><p>远程服务调用失败，远程服务成功，却由于网络故障等原因，没有返回，导致订单回滚，库存却扣减</p></li><li><p>库存服务锁定成功，库存服务下面的逻辑发生故障，订单回滚</p><p>远程服务执行完成，当前订单服务中调用远程服务的其他地方却发生故障，已执行的远程服务无法回滚</p></li></ol><p>利用消息队列实现最终一致，库存服务锁定成功后给消息队列消息，过段时间自动解锁，甲所示先查询订单的支付状态，解锁成功修改库存工作单详情状态为已解锁</p><h2 id="事务的基本特质"><a href="#事务的基本特质" class="headerlink" title="事务的基本特质"></a>事务的基本特质</h2><p>数据库事务的ACID特性：原子性（Atomicity）、已执行（Consistency）、隔离性或独立性（Isolation）、持久性（Durability）</p><ul><li><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</p></li><li><p>一致性：数据在事务的前后，业务整体一致</p><p>A（1000）给B（1000）转账200，事务成功则A（800）、B(1200)</p></li><li><p>隔离性：事务之间相互隔离</p></li><li><p>持久性：一旦事务成功，数据一定会落在数据库</p></li></ul><p>在单体应用中，多个业务操作使用同一条连接操作不同的数据表，一旦出现异常，很同意进行整体回滚。一个事务开始：代表一笑的所有操作都在一个连接里面。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p><p>3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>1、PROPAGATION_REQUIRED:如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>2、PROPAGATION_SUPPORTS:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>3、PROPAGATION_MANDATORY:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>4、PROPAGATION_REQUIRES_NEW:创建新事务，无论当前存不存在事务，都创建新事务。5、PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>6、PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。<br>7、PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h3 id="Springboot中事务传播的坑"><a href="#Springboot中事务传播的坑" class="headerlink" title="Springboot中事务传播的坑"></a>Springboot中事务传播的坑</h3><p><strong>同一个对象内事务方法互相调用默认失效，同一个类下的方法相互调用，即使设置了事务的隔离界别注解，依然以第一个执行的方法的事务为准。</strong></p><p><strong>原因：绕过了代理对象事务使用代理对象来执行的</strong>。</p><p>解决：使用代理对象来调用方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引入aspectj</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启aspectj动态代理功能，所有的动态代理都是aspectj创建的（即使没有接口也可以创建动态代理）</span><br><span class="line">    exposeProxy = <span class="keyword">true</span> 对外暴露代理对象</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(exposeProxy = <span class="keyword">true</span>)</span><br><span class="line">    </span><br><span class="line">从aopcontext中获取当前代理对象实现事务的传播</span><br></pre></td></tr></tbody></table></figure></div><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP原则指的实在一个分布式系统中：</p><ul><li><p>一致性（Consistency）</p><p>在分布式系统中的所有数据备份，在同一时刻是否同样的值，等同于所有接待您访问同一份最新的数据副本</p></li><li><p>可用性（Availablity）</p><p>在集群中一部分节点故障后，集群整体是否还能影响客户端的读写请求。（对数据更新具备更高的可用性）</p></li><li><p>分区容错性（Partition tolerance）</p><p>大多数人分布式系统都分布在多个子网络，每个子网络叫做一个区，分区容错的意思就是，区间通信可能失败，。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，他们之间可能无法通信。</p></li></ul><p>CAP原则指的是，这三个要素最多只能同时实现两点，不能三者兼顾。</p><p><strong>分布式系统中实现一致性的raft算法、paxos</strong></p><p><strong><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></strong></p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>是对CAP的延伸，思想史计时无法做到强一致性（CAP的一致性就是强一致性），也可以适当的采取弱一致性，即最终一致性。</p><ul><li><p>基本可用（Basically Available）</p><p>基本可用是指分布式系统在出现故障的时候,允许损失部分可用性(例如响应时间、功能上的可用性)，允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</p><p>响应时间上的损失:正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了1~2秒。</p><p>功能上的损失:购物网站在购物高峰(如双十一)时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</p></li><li><p>软状态（Soft State）</p><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p></li><li><p>最终一致性（Eventual Consistency）</p><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li></ul><h2 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h2><p>从客户端角度，多进程并发访间时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性</p><h2 id="分布式事务的几种方案"><a href="#分布式事务的几种方案" class="headerlink" title="分布式事务的几种方案"></a>分布式事务的几种方案</h2><p><a href="https://zhuanlan.zhihu.com/p/183753774" target="_blank" rel="noopener">分布式事务的解决方案</a></p><p>柔性事务+可靠消息+最终一致性方案</p><p>业务处理服务在业务事务提交之前，向实时消息.服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后:向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><h1 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h1><p><a href="https://github.com/Raptor1998/SpringCloud-Basic" target="_blank" rel="noopener">Springcloud基础</a></p><p><a href="https://github.com/Raptor1998/SpringCloud-Basic/blob/master/SpringCloud%20%E7%AC%AC%E4%BA%8C%E5%AD%A32020.03.05.mmap" target="_blank" rel="noopener">Springcloud笔记文档</a></p><h1 id="rabbit延迟队列释放库存"><a href="#rabbit延迟队列释放库存" class="headerlink" title="rabbit延迟队列释放库存"></a>rabbit延迟队列释放库存</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175349.png" data-fancybox="group" data-caption="image-20211208190908469" class="fancybox"><img alt="image-20211208190908469" title="image-20211208190908469" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175349.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="消息的可靠性"><a href="#消息的可靠性" class="headerlink" title="消息的可靠性"></a>消息的可靠性</h1><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><ul><li><p>消息发送出去，由于网络问题没有抵达服务器</p><ul><li><p>做好容错方法(try-catch)，发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</p></li><li><p>做好日志记录，每个消息状态是否都被服务器收到都应该记录</p></li><li><p>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</p></li></ul></li><li><p>消息抵达Broker，Broker要将消息写入磁盘(持久化)才算成功。此时Broker尚未持久化完成，宕机.</p><ul><li>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</li></ul></li><li><p>自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机</p><ul><li>一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</li></ul></li></ul><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><ul><li><p>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者</p></li><li><p>消息消费失败，由于重试机制，自动又将消息发送出去</p></li><li><p>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送</p><ul><li>消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志</li><li>使用防重表（redis/mysql)，发送消息每一个都有业务的唯一标识，处理过就不用处理</li><li>rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</li></ul></li></ul><h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><ul><li>消费者宕机积压</li><li>消费者消费能力不足宕机</li><li>发送者发送流量太大<ul><li>上线更多的消费者，进行正常消费</li><li>上线专门的队列消费服务，将消息先批量的取出来，记录数据库，离线慢慢处理</li></ul></li></ul><h1 id="收单"><a href="#收单" class="headerlink" title="收单"></a>收单</h1><ol><li><p>订单在支付页，不支付，一直刷新，订单过期了才支付，订单状态改为已经支付，但是库存已经释放了</p><p>可使用支付宝的自动收单功能，只要一段时间不支付，就不能支付了</p></li><li><p>由于时延等问题 ，订单解锁完成，正在等待锁库存的时候，异步通知才到</p><p>订单解锁，手动调用收单</p></li><li><p>网络阻塞问题，订单支付成功的异步通知一直不到达</p><p>查询订单列表时，ajax获取当前未支付的订单状态，查询订单状态时，再获取一下支付宝此订单的状态</p></li><li><p>其他各种问题</p><p>每天晚上闲时下载支付宝对账单，——进行对账</p></li></ol><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流＋异步＋缓存（页面静态化)＋独立部署。</p><p><strong>限流方式:</strong></p><ol><li><p>前端限流，一些高并发的网站直接在前端页面开始限流，例如:小米的验证码设计</p></li><li><p>nginx限流，直接负载部分请求到错误的静态页面:令牌算法漏斗算法</p></li><li><p>网关限流，限流的过滤器</p></li><li><p>代码中使用分布式信号量</p></li></ol><h2 id="Spring定时任务"><a href="#Spring定时任务" class="headerlink" title="Spring定时任务"></a>Spring定时任务</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="comment">//开启异步任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSchedule</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. Spring的corn由6位组成，不予许第七位的年</span></span><br><span class="line"><span class="comment">     * 2. 在周几的位置，1-7代表周一到周日，MON-SUN</span></span><br><span class="line"><span class="comment">     * 3. 定时任务不应该阻塞。默认是阻塞的</span></span><br><span class="line"><span class="comment">     *  1） 可以让业务运行以异步的方式，提交到自己的线程池</span></span><br><span class="line"><span class="comment">     *        CompletableFuture.runAsync(()-&gt;{</span></span><br><span class="line"><span class="comment">     *         }.executor);</span></span><br><span class="line"><span class="comment">     *  2) 支持异步线程池；设置spring.task.schedule.pool.size=5</span></span><br><span class="line"><span class="comment">     *  3) 异步任务  <span class="doctag">@EnableAsync</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"* * * ? * 4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        log.info(<span class="string">"hello ..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="商品上架的幂等性保证"><a href="#商品上架的幂等性保证" class="headerlink" title="商品上架的幂等性保证"></a>商品上架的幂等性保证</h2><p>在分布式环境中，多个应用的上架时间都一样，只需要保证有一台机器执行即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒杀商品上架功能的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String upload_lock = <span class="string">"seckill:upload:lock"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 保证幂等性问题</span></span><br><span class="line"><span class="comment">// @Scheduled(cron = "*/5 * * * * ? ")</span></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 1/1 * * ? "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadSeckillSkuLatest3Days</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//1、重复上架无需处理</span></span><br><span class="line">    log.info(<span class="string">"上架秒杀的商品..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分布式锁</span></span><br><span class="line">    RLock lock = redissonClient.getLock(upload_lock);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//上架商品逻辑 </span></span><br><span class="line">        seckillService.uploadSeckillSkuLatest3Days();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      SpringCloudAlibaba
    
    </summary>
    
    
      <category term="SpringCloudAlibaba" scheme="http://raptor1998.top/categories/SpringCloudAlibaba/"/>
    
    
      <category term="SpringCloudAlibaba" scheme="http://raptor1998.top/tags/SpringCloudAlibaba/"/>
    
  </entry>
  
  <entry>
    <title>NGINX配置HTTPS</title>
    <link href="http://raptor1998.top/2021/08/27/nginx%E4%B9%8Bhttps/"/>
    <id>http://raptor1998.top/2021/08/27/nginx%E4%B9%8Bhttps/</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-10-11T09:22:49.130Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="NGINX配置HTTPS"><a href="#NGINX配置HTTPS" class="headerlink" title="NGINX配置HTTPS"></a>NGINX配置HTTPS</h1><h2 id="域名解析到主机"><a href="#域名解析到主机" class="headerlink" title="域名解析到主机"></a>域名解析到主机</h2><h2 id="申请ssl证书"><a href="#申请ssl证书" class="headerlink" title="申请ssl证书"></a>申请ssl证书</h2><ol><li><p>到域名管理开启ssl证书</p></li><li><p><strong>为了解决免费证书近期存在的吊销、统计等问题，自2021年起，免费证书申请将切换到证书资源包下</strong></p><p>进入<strong>证书资源包</strong></p><p>选择免费版购买</p></li><li><p>进入ssl证书控制台，创建证书</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213255.png" data-fancybox="group" data-caption="创建证书" class="fancybox"><img alt="创建证书" title="创建证书" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213255.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>填写信息</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213256.png" data-fancybox="group" data-caption="信息填写" class="fancybox"><img alt="信息填写" title="信息填写" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213256.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>NDS验证</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213257.png" data-fancybox="group" data-caption="验证" class="fancybox"><img alt="验证" title="验证" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213257.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>等待审核通过后即可下载</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213258.png" data-fancybox="group" data-caption="证书类型" class="fancybox"><img alt="证书类型" title="证书类型" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213258.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li></ol><h2 id="NGINX配置"><a href="#NGINX配置" class="headerlink" title="NGINX配置"></a>NGINX配置</h2><ol><li><p>nginx 的 ssl 模块安装</p><p><strong>/usr/local/nginx/sbin/nginx -V</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214255.png" data-fancybox="group" data-caption="ssl模块" class="fancybox"><img alt="ssl模块" title="ssl模块" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214255.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>如果未安装则</p><ul><li><p><strong>wget <a href="http://nginx.org/download/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.16.1.tar.gz</a></strong></p></li><li><p><strong>tar -zxvf nginx-1.16.1.tar.gz</strong></p></li><li><p><strong>cd nginx-1.16.1 $ ./configure –prefix=/usr/local/nginx –with-http_ssl_module</strong></p></li><li><p>使用 <code>make</code> 命令编译（<strong>使用<code>make install</code>会重新安装nginx</strong>），此时当前目录会出现 <code>objs</code> 文件夹。</p></li><li><p>用新的 nginx 文件覆盖当前的 nginx 文件。</p><p><strong>cp ./objs/nginx /usr/local/nginx/sbin/</strong></p></li><li><p>再次查看安装的模块（<code>configure arguments: --with-http_ssl_module</code>说明ssl模块已安装）</p></li></ul></li><li><p>配置SSL证书</p><p>在<code>/usr/local/nginx</code>下创建文件夹cert，将两个证书文件放入</p></li><li><p><strong>配置 https server</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/cert/xxx.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        root /disabled/admin;</span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">}</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>将 http 重定向 https</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>重启nginx</p></li><li><p>无法访问，此类情况稍等一会，具体原因未知</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214857.png" data-fancybox="group" data-caption="无法访问" class="fancybox"><img alt="无法访问" title="无法访问" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>成功</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827215334.png" data-fancybox="group" data-caption="success" class="fancybox"><img alt="success" title="success" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827215334.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li></ol><h2 id="完整配置demo"><a href="#完整配置demo" class="headerlink" title="完整配置demo"></a>完整配置demo</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    fastcgi_intercept_errors on;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    server {</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key  /usr/local/nginx/cert/xxx.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        root /disabled/admin;</span><br><span class="line">        #location / {</span><br><span class="line">        #    root   html;</span><br><span class="line">        #    index  index.html index.htm;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # 管理员页面</span><br><span class="line">        location / {</span><br><span class="line">            try_files $uri $uri/ @router;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">         }</span><br><span class="line">        location @router {</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /images {</span><br><span class="line">            root /disabled/files;</span><br><span class="line">            # 目录索引权限</span><br><span class="line">            autoindex on;</span><br><span class="line">            autoindex_exact_size on;</span><br><span class="line">            autoindex_localtime on;</span><br><span class="line">        }</span><br><span class="line">        location /mobile {</span><br><span class="line">            root   /disabled;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /wechat {</span><br><span class="line">            root   /disabled;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /api/mobiles {</span><br><span class="line">            rewrite ^/(.*)$ /$1 break;</span><br><span class="line">            proxy_pass   http://127.0.0.1:8081;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="NGINX的mater和worker"><a href="#NGINX的mater和worker" class="headerlink" title="NGINX的mater和worker"></a>NGINX的mater和worker</h1><ul><li><p><strong>一个</strong> <strong>master</strong> <strong>和多个</strong> <strong>woker</strong> <strong>有好处</strong></p><p>（1）可以使用<code>nginx –s reload</code> 热部署，利用 nginx 进行热部署操作</p><p>（2）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 独立的，继续进行争抢，实现请求过程，不会造成服务中断</p></li><li><p><strong>设置多少个</strong> <strong>woker</strong> <strong>合适</strong></p><p>worker 数和服务器的cpu数相等是最为适宜的</p></li><li><p><strong>连接数</strong> <strong>worker_connection</strong></p><ul><li><p><strong>第一个：发送请求，占用了</strong> <strong>woker</strong> <strong>的几个连接数？</strong></p><p>静态资源2个、反向代理4个</p></li><li><p><strong>nginx有一个master，有四个 woker，每个woker 支持最大的连接数1024，支持的</strong></p><p><strong>最大并发数是多少？</strong></p><p>普通的静态访问最大并发数是： worker_connections * worker_processes /2</p><p>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。</p></li></ul></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      NGINX
    
    </summary>
    
    
      <category term="NGINX" scheme="http://raptor1998.top/categories/NGINX/"/>
    
    
      <category term="NGINX" scheme="http://raptor1998.top/tags/NGINX/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程基础</title>
    <link href="http://raptor1998.top/2021/07/29/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://raptor1998.top/2021/07/29/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-08-20T01:18:03.712Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>真实对象和代理对象都要实现同一个接口，代理对象要代理真实角色</strong></p><p><strong>好处：代理对象可以做很多真是对象做不了的事情，真实对象专注做自己的事情</strong></p><p><code>线程体（也就是我们要执行的具体任务）实现了Runnable接口和run方法。同时Thread类也实现了Runnable接口。此时，线程体就相当于目标角色，Thread就相当于代理角色。当程序调用了Thread的start()方法后，Thread的run()方法会在某个特定的时候被调用。thread.run()方法</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ProxyImage(<span class="keyword">new</span> RealImage(<span class="string">"happy"</span>)).display();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"sad"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(RealImage realImage)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.realImage = realImage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//真是对象的方法</span></span><br><span class="line">        realImage.display();</span><br><span class="line">        after();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyTarget run..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/dennyzhangdd/p/7280032.html" target="_blank" rel="noopener">Thread类源码剖析</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="noopener">Java并发编程：Thread类的使用</a></p><p><a href="https://www.cnblogs.com/jamesvoid/p/10011694.html" target="_blank" rel="noopener">Thread类源码解析</a></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="jvm线程状态"><a href="#jvm线程状态" class="headerlink" title="jvm线程状态"></a>jvm线程状态</h3><p><strong>线程中断或者结束，一旦进入死亡状态，就不能再次启动。</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210729144111.png" data-fancybox="group" data-caption="jvm线程状态" class="fancybox"><img alt="jvm线程状态" title="jvm线程状态" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210729144111.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>如上图，可见：<strong>RUNNABLE = 正在JVM中运行的（Running）+ 可能在等待操作系统级别的资源（Ready）</strong>，例如CPU时间片</p><p>　　线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源），只有线程运行需要的所有条件满足了，才进入就绪状态。</p><p>　　当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。</p><p>　　线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。</p><p>　　当由于突然中断或者子任务执行完毕，线程就会被消亡。</p><ol><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li><li>t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。</li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li><li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li></ol><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_22771739/article/details/82529874" target="_blank" rel="noopener">Java线程的6种状态及切换(透彻讲解)</a></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行。</p><p>线程的优先级用数字表示范围1~10,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>低优先级只意味着获得调度的概率低，并不是优先级低的就不会被调用了，这都取决于CPU的调度</strong></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>线程分为用户线程和守护线程</p><p>虚拟机必须确保用户线程执行完毕</p><p>虚拟机不用等待守护线程执行完毕，如后台记录操作日志、监控内存、垃圾回收等</p><p><strong>两者的区别：</strong></p><p><strong>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Human human = <span class="keyword">new</span> Human();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        <span class="comment">//默认为false表示用户线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(human).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"god still alive !"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">365</span> * <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"human alive "</span> + i);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"dead"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><strong>synchronized方法控制着“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</strong></p><p><strong>缺陷：若将一个打的方法声明为synchronized将会影响效率</strong></p><p><strong>synchronized（obj）{}，obj称之为同步监视器，可以使任何对象，但是推荐使用共享资源作为同步监视器，同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身或者是class</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="comment">//锁住list对象  变为安全的</span></span><br><span class="line">                <span class="keyword">synchronized</span> (list){</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                    System.out.println(<span class="string">"now size:"</span>+list.size());</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><span id="jump"><strong>同步锁 锁的对象</strong></span></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802093658.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802093658.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><span id="deadLock">死锁</span></h2><p>死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><blockquote><p>必要条件</p></blockquote><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源关系</li></ul><blockquote><p>预防死锁——破坏任意一个或多个条件</p></blockquote><ul><li>破坏请求保持：一次性申请所有的资源，这样就不存在等待了。</li><li>不可抢占，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>循环等待，靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化申请后就不存在循环了。</li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="显示定义"><a href="#显示定义" class="headerlink" title="显示定义"></a>显示定义</h3><p>通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当</p><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</p><p>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) {</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="synchronized与lock对比"><a href="#synchronized与lock对比" class="headerlink" title="synchronized与lock对比"></a>synchronized与lock对比</h3><ul><li>lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放。</li><li>Lock锁只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用lock锁，JVM将花费较少的时间来调度进程，性能更高，并且具有更好的拓展性（提供更多的子类）</li><li>使用优先顺序  Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</li></ul><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="可用方法"><a href="#可用方法" class="headerlink" title="可用方法"></a>可用方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高于线程的优先调度</td></tr></tbody></table><p><strong>均是Object类中的方法，都只能在同步方法或者同步代码块中使用，否则异常</strong></p><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class TestPC {</span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Container container = new Container();</span><br><span class="line">        Provider provider = new Provider(container);</span><br><span class="line">        Consumer consumer = new Consumer(container);</span><br><span class="line">        provider.start();</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生产者</span><br><span class="line"> */</span><br><span class="line">class Provider extends Thread {</span><br><span class="line">    Container container;</span><br><span class="line"></span><br><span class="line">    public Provider(Container container) {</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println("生产者启动");</span><br><span class="line">        try {</span><br><span class="line">            for (int i = 1; i &lt;= 100; i++) {</span><br><span class="line">                container.push(new Product(i));</span><br><span class="line">                System.out.println("生产了第" + i + "个产品");</span><br><span class="line">            }</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> */</span><br><span class="line">class Consumer extends Thread {</span><br><span class="line">    Container container;</span><br><span class="line"></span><br><span class="line">    public Consumer(Container container) {</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println("消费者启动");</span><br><span class="line">        try {</span><br><span class="line">            for (int i = 1; i &lt;= 100; i++) {</span><br><span class="line">                System.out.println("---------消费了第" + container.pop().getId() + "个产品");</span><br><span class="line">            }</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓冲区</span><br><span class="line"> */</span><br><span class="line">class Container {</span><br><span class="line"></span><br><span class="line">    private Product[] products = new Product[100];</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public synchronized void push(Product product) throws InterruptedException {</span><br><span class="line">        //容器满了</span><br><span class="line">        if (count == products.length) {</span><br><span class="line">            //通知消费者消费，生产者等待</span><br><span class="line">            this.wait();</span><br><span class="line">        }</span><br><span class="line">        //缓冲区没有满  加入产品</span><br><span class="line"></span><br><span class="line">        products[count] = product;</span><br><span class="line">        count++;</span><br><span class="line">        //通知消费者消费</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public synchronized Product pop() throws InterruptedException {</span><br><span class="line">        //缓冲区是否存在产品</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            //等待生产者生产</span><br><span class="line">            this.wait();</span><br><span class="line">        }</span><br><span class="line">        count--;</span><br><span class="line">        Product product = products[count];</span><br><span class="line"></span><br><span class="line">        //通知生产者生产</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        return product;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 产品</span><br><span class="line"> */</span><br><span class="line">class Product {</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Product(int id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int getId() {</span><br><span class="line">        return id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setId(int id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730103700.png" data-fancybox="group" data-caption="管程" class="fancybox"><img alt="管程" title="管程" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730103700.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line">        Actor actor = <span class="keyword">new</span> Actor(program);</span><br><span class="line">        Audience audience = <span class="keyword">new</span> Audience(program);</span><br><span class="line">        actor.start();</span><br><span class="line">        audience.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Program program;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(Program program)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.program = program;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">this</span>.program.show(<span class="string">"男子乒乓球单打决赛"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">this</span>.program.show(<span class="string">"团体赛决赛"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audience</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Program program;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audience</span><span class="params">(Program program)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.program = program;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">this</span>.program.watching();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String perform;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String perform)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!flag) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"表演等待..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"表演了："</span> + perform);</span><br><span class="line">        <span class="comment">//通知观众</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.perform = perform;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watching</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"观看等待..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"观看了："</span> + perform);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730110949.png" data-fancybox="group" data-caption="信号量" class="fancybox"><img alt="信号量" title="信号量" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730110949.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p><p>提前创建好朵儿线程池，放入线程池中没使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复利用。</p><blockquote><p>好处</p></blockquote><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低了资源消耗（重复利用线程中的线程，不需要每次都创建）</li><li>便于线程管理</li></ul><blockquote><p>简单使用</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">"   "</span>+ i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a><strong>JUC</strong>并发编程</h1><h2 id="JUC概述"><a href="#JUC概述" class="headerlink" title="JUC概述"></a>JUC概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p><p><strong>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程— —资源分配的最小单位。</strong></p><p><strong>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</strong></p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.新建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor. 准备就绪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> Object#wait() Object.wait}.阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait() Object.wait} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #join() Thread.join} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#park() LockSupport.park}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #sleep Thread.sleep}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait(long) Object.wait} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #join(long) Thread.join} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;限时等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.终结</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="wait-sleep-的区别"><a href="#wait-sleep-的区别" class="headerlink" title="wait/sleep 的区别"></a><strong>wait/sleep 的区别</strong></h3><p>（1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。</p><p>（2）sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)。 </p><p>（3）它们都可以被 interrupted 方法中断。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><h4 id="串行模式"><a href="#串行模式" class="headerlink" title="串行模式"></a>串行模式</h4><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p><p><strong>串行是一次只能取得一个任务，并执行这个任务</strong>。</p><h4 id="并行模式"><a href="#并行模式" class="headerlink" title="并行模式"></a>并行模式</h4><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核 CPU。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行</strong>。</p><p><strong>并发：</strong>同一时刻多个线程在访问同一个资源，多个线程对一个点</p><p><strong>并行：</strong>多项工作一起执行，之后再汇总</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p><p>管程（Monitor）监视器，平时我们所说的锁，是一种同步的机制，保证同一时间，只有一个线程能对被保护的数据或者代码进行访问</p><p>jvm同步基于进入和退出，使用管程对象实现的</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><ul><li><p>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</p></li><li><p>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p></li></ul><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在两个线程的情况下，没有问题，当增加线程数之后，会出现问题。<strong>加入ABCD四个线程，分别作+1，-1，+1，-1，操作A先做+1，此时随机唤醒BCD，例如C得到，发现num不为0，则等待，此时ABD再抢，A抢到，直接等待，在此时，C又抢到了，此时C在this.wait();这一行等待，二wait方法有一个特点，“在那里睡就在那里醒”，此时C直接向下执行做+1操作。</strong></p><p><strong>避免：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p><ul><li>await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行。</li><li>signal()用于唤醒一个等待的线程。</li></ul><p>在调用 Condition 的 await()/signal()方法前，也需要线程持有相关的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><h3 id="线程定制化通信"><a href="#线程定制化通信" class="headerlink" title="线程定制化通信"></a>线程定制化通信</h3><p><strong>案例: A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮</strong></p><p><strong>通用：通过标志位实现</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print5(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print10(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print15(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h2><h3 id="ArrayList、HashSet、HashMap安全问题"><a href="#ArrayList、HashSet、HashMap安全问题" class="headerlink" title="ArrayList、HashSet、HashMap安全问题"></a>ArrayList、HashSet、HashMap安全问题</h3><h4 id="异常：ConcurrentModificationException"><a href="#异常：ConcurrentModificationException" class="headerlink" title="异常：ConcurrentModificationException"></a>异常：ConcurrentModificationException</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802100946.png" data-fancybox="group" data-caption="并发修改异常" class="fancybox"><img alt="并发修改异常" title="并发修改异常" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802100946.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="synchronizedList-or-Vector"><a href="#synchronizedList-or-Vector" class="headerlink" title="synchronizedList or Vector"></a>synchronizedList or Vector</h5><p>可以使用<code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());或者List&lt;String&gt; list =new Vector();</code>解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//vector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//synchronizedList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><ol><li><p>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</p></li><li><p>它是线程安全的。</p></li><li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。</p></li><li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p></li><li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></li></ol><p><strong>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写会内存，其他的线程就会读到了脏数据。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure></div><p>集合类型中存在线程安全与线程不安全的两种,常见例如: <strong>ArrayList —– Vector，HashMap —–HashTable</strong>，但是以上都是通过 synchronized 关键字实现,效率较低</p><h2 id="多线程锁演示"><a href="#多线程锁演示" class="headerlink" title="多线程锁演示"></a>多线程锁演示</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！</a></p><p><a href="https://www.cnblogs.com/heyouxin/p/13037146.html" target="_blank" rel="noopener">【并发编程】公平锁与非公平锁的区别</a></p><p><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></p><h3 id="synchronized锁演示"><a href="#synchronized锁演示" class="headerlink" title="synchronized锁演示"></a>synchronized锁演示</h3><p><strong><a href="#jump">查看synchronized锁对象图</a></strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone1.sendSMS();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//                phone1.sendEmail();</span></span><br><span class="line"><span class="comment">//                phone1.getHello()s;</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//停留 4 秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 8 锁</span></span><br><span class="line"><span class="comment"> * 1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 2 停 4 秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 3 新增普通的 hello 方法，是先打短信还是 hello</span></span><br><span class="line"><span class="comment"> * ------getHello</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 5 两个静态同步方法，1 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 6 两个静态同步方法，2 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 7 1 个静态同步方法,1 个普通同步方法，1 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 8 1 个静态同步方法,1 个普通同步方法，2 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p><p>加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p><p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p><p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p><p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p><p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h3 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h3><h4 id="偏向锁-、-轻量级锁-、-重量级锁"><a href="#偏向锁-、-轻量级锁-、-重量级锁" class="headerlink" title="偏向锁 、 轻量级锁 、 重量级锁"></a>偏向锁 、 轻量级锁 、 重量级锁</h4><blockquote><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p></blockquote><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>非公平锁：可能出现线程饿死，效率高</p><p>公平锁：阳光普照，效率相对较低</p><p>公平锁是多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序</strong>来一次得到锁(默认的是不公平锁)；</p><p>非公平锁就是一种获取锁的抢占机制，是<strong>随机得到锁的</strong>，和公平锁不同的就是先来的不必定先获得锁。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>{</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line"> sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到非公平锁里，判断当前锁占用状态==0直接会进行compareAndSetState尝试获取锁。若此时有线程排队，可能争夺不过资源。所以这是非公平的</span></span><br><span class="line"><span class="comment">在非公平锁里，因为可以直接compareAndSetState来获取锁，不需要加入队列，然后等待队列头线程唤醒再获取锁这一步骤，所以效率较快</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在公平锁里，判断当前锁占用状态==0后，会继续判断hasQueuedPredecessors，即当前队列是否有排队的情况，如果没有才会尝试获取锁</span></span><br><span class="line"><span class="comment">这样可以保证遵循FIFO的原则，每一个先来的线程都可以最先获取到锁，但是增加了上下文切换与等待线程的状态变换时间。所以效率相较于非公平锁较慢。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p><strong>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</strong></p><p>synchronized（隐式）和Lock（显示）都是可重入锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>{</span><br><span class="line">    add();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">           <span class="keyword">synchronized</span> (o) {</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"外层"</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (o){</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">"中层"</span>);</span><br><span class="line">                   <span class="keyword">synchronized</span> (o){</span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"内层"</span>);</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }, <span class="string">"t1"</span>).start();</span><br></pre></td></tr></tbody></table></figure></div><p><strong>ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样</strong></p><h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><p><strong><a href="#deadLock">死锁产生</a></strong></p><h4 id="死锁验证"><a href="#死锁验证" class="headerlink" title="死锁验证"></a>死锁验证</h4><h5 id="死锁演示代码"><a href="#死锁演示代码" class="headerlink" title="死锁演示代码"></a>死锁演示代码</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Number number1 = <span class="keyword">new</span> Number(<span class="number">10</span>);</span><br><span class="line">Number number2 = <span class="keyword">new</span> Number(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span> (number1) {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number1锁"</span>);</span><br><span class="line">        number1.setA(<span class="number">11</span>);</span><br><span class="line">        System.out.println(number1);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (number2) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number2锁"</span>);</span><br><span class="line">            number2.setA(<span class="number">21</span>);</span><br><span class="line">            System.out.println(number2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"小明"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span> (number2) {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number2锁"</span>);</span><br><span class="line">        number2.setA(<span class="number">22</span>);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (number1) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number1锁"</span>);</span><br><span class="line">            number1.setA(<span class="number">12</span>);</span><br><span class="line">            System.out.println(number1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"小红"</span>).start();</span><br></pre></td></tr></tbody></table></figure></div><h5 id="死锁验证-1"><a href="#死锁验证-1" class="headerlink" title="死锁验证"></a>死锁验证</h5><p><strong>jps是用于查看有权访问的hotspot虚拟机的进程. 当未指定hostid时，默认查看本机jvm进程，否者查看指定的hostid机器上的jvm进程，此时hostid所指机器必须开启jstatd服务。 jps可以列出jvm进程lvmid，主类类名，main函数参数, jvm参数，jar名称等信息。</strong></p><p><strong>jstack是java虚拟机自带的一种堆栈跟踪工具。</strong></p><ol><li>jps查看进程id</li></ol><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173215.png" data-fancybox="group" data-caption="jps查看进程号" class="fancybox"><img alt="jps查看进程号" title="jps查看进程号" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173215.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ol start="2"><li>jstack查看结果</li></ol><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173312.png" data-fancybox="group" data-caption="jstack结果" class="fancybox"><img alt="jstack结果" title="jstack结果" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173312.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程</p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p><p>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</p><p>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p><p>一旦计算完成，就不能再重新开始或取消计算</p><p>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完</p><p>成状态，然后会返回结果或者抛出异常get 只计算一次,因此 get 方法放到最后</p><h3 id="Callable创建线程"><a href="#Callable创建线程" class="headerlink" title="Callable创建线程"></a>Callable创建线程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        FutureTask futureTask1 = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        FutureTask futureTask2 = <span class="keyword">new</span> FutureTask(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  come in callable"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        });</span><br><span class="line"><span class="comment">//        new Thread(futureTask1, "A").start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask2, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!futureTask2.isDone()){</span><br><span class="line">            System.out.println(<span class="string">"wait..."</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  is over"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  hello callable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   out: </span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">B  come in callable</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">main  is over</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="JUC-辅助类"><a href="#JUC-辅助类" class="headerlink" title="JUC-辅助类"></a>JUC-辅助类</h2><h3 id="CountDownLatch-减少计数"><a href="#CountDownLatch-减少计数" class="headerlink" title="CountDownLatch: 减少计数"></a>CountDownLatch: 减少计数</h3><blockquote><p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p><p>用给定的<em>计数</em> 初始化 <code>CountDownLatch</code>。由于调用了<code>awaitawait</code> 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。</p></blockquote><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p><ul><li><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这些线程会阻塞</p></li><li><p>其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程不会阻塞) </p></li><li><p>当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 号"</span>);</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" ok"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">0 号</span></span><br><span class="line"><span class="comment">4 号</span></span><br><span class="line"><span class="comment">2 号</span></span><br><span class="line"><span class="comment">3 号</span></span><br><span class="line"><span class="comment">1 号</span></span><br><span class="line"><span class="comment">5 号</span></span><br><span class="line"><span class="comment">main ok</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier: 循环栅栏"></a>CyclicBarrier: 循环栅栏</h3><blockquote><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为<em>循环</em> 的 barrier。</p></blockquote><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; {</span><br><span class="line">        System.out.println(<span class="string">"集齐七龙珠"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 星 get"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">1 星 get</span></span><br><span class="line"><span class="comment">7 星 get</span></span><br><span class="line"><span class="comment">6 星 get</span></span><br><span class="line"><span class="comment">5 星 get</span></span><br><span class="line"><span class="comment">4 星 get</span></span><br><span class="line"><span class="comment">2 星 get</span></span><br><span class="line"><span class="comment">3 星 get</span></span><br><span class="line"><span class="comment">集齐七龙珠</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore: 信号灯"></a>Semaphore: 信号灯</h3><blockquote><p>一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 <code>acquire()</code>，然后再获取该许可。每个 <code>release()</code> 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，<code>Semaphore</code> 只对可用许可的号码进行计数，并采取相应的行动。</p></blockquote><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//抢占</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ------离开"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                semaphore.release();</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">2 抢到</span></span><br><span class="line"><span class="comment">0 抢到</span></span><br><span class="line"><span class="comment">1 抢到</span></span><br><span class="line"><span class="comment">1 ------离开</span></span><br><span class="line"><span class="comment">3 抢到</span></span><br><span class="line"><span class="comment">3 ------离开</span></span><br><span class="line"><span class="comment">4 抢到</span></span><br><span class="line"><span class="comment">0 ------离开</span></span><br><span class="line"><span class="comment">5 抢到</span></span><br><span class="line"><span class="comment">2 ------离开</span></span><br><span class="line"><span class="comment">4 ------离开</span></span><br><span class="line"><span class="comment">5 ------离开</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></strong></p><p><strong><a href="https://blog.csdn.net/yanyan19880509/article/details/52435135" target="_blank" rel="noopener">轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理</a></strong></p><h3 id="读写锁案例"><a href="#读写锁案例" class="headerlink" title="读写锁案例"></a>读写锁案例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                cache.put(finalI + <span class="string">""</span>, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> finalI2 = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                cache.get(finalI2 + <span class="string">""</span>);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String o)</span> </span>{</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---is writing: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.put(key, o);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---finished writing: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        String o = <span class="keyword">null</span>;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is reading: "</span> + key);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" finished reading: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cache{"</span> +</span><br><span class="line">                <span class="string">"map="</span> + map +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><blockquote><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 </p><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210803113617.png" data-fancybox="group" data-caption="属性" class="fancybox"><img alt="属性" title="属性" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210803113617.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p></li><li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p></li><li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//三种常见分类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池多线程</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        ExecutorService pool2 = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池可扩容线程</span></span><br><span class="line">        ExecutorService pool3 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                pool3.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            pool3.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 能容纳的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//存活的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//存放提交但未执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//创建线程的工厂类</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span><span class="comment">//等待队列满后的拒绝策略</span></span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> <strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p>在创建了线程池后，线程池中的线程数为零</p></li><li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： </p><p>2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p>2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p><p>2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p><p>4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</p><p>4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p></li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p><p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p><p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p><p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210809105702.png" data-fancybox="group" data-caption="阿里开发手册" class="fancybox"><img alt="阿里开发手册" title="阿里开发手册" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210809105702.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></tbody></table></figure></div><h2 id="分之合并框架"><a href="#分之合并框架" class="headerlink" title="分之合并框架"></a>分之合并框架</h2><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JUC并发编程
    
    </summary>
    
    
      <category term="JUC" scheme="http://raptor1998.top/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://raptor1998.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper案例</title>
    <link href="http://raptor1998.top/2021/07/28/Zookeeper-plus/"/>
    <id>http://raptor1998.top/2021/07/28/Zookeeper-plus/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-07-28T07:19:34.281Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="服务器动态上下线监听案例"><a href="#服务器动态上下线监听案例" class="headerlink" title="服务器动态上下线监听案例"></a>服务器动态上下线监听案例</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728090857.png" data-fancybox="group" data-caption="服务器动态上下线监听案例" class="fancybox"><img alt="服务器动态上下线监听案例" title="服务器动态上下线监听案例" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728090857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="DistributeServer"><a href="#DistributeServer" class="headerlink" title="DistributeServer"></a>DistributeServer</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>{</span><br><span class="line">        DistributeServer server = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">        <span class="comment">//1. 连接zk</span></span><br><span class="line">        server.getConnect();</span><br><span class="line">        <span class="comment">//2. 注册服务到zk集群</span></span><br><span class="line">        server.register(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//3. 启动业务逻辑</span></span><br><span class="line">        server.business();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        String s = zkClient.create(<span class="string">"/servers/"</span> + hostname, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + <span class="string">"is online!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="DistributeClient"><a href="#DistributeClient" class="headerlink" title="DistributeClient"></a>DistributeClient</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>{</span><br><span class="line">        DistributeClient distributeClient = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">        distributeClient.getConnect();</span><br><span class="line">        <span class="comment">//监听、servers下节点的上下线</span></span><br><span class="line">        distributeClient.getServerList();</span><br><span class="line"></span><br><span class="line">        distributeClient.business();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/servers"</span>, <span class="keyword">true</span>);</span><br><span class="line">        ArrayList&lt;Object&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String child : children) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/servers/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    getServerList();</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><blockquote><p>什么叫做分布式锁?</p></blockquote><p>比如说”进程 1”在使用该资源的时候，会先去获得锁，”进程 1”获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，”进程 1”用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁.</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728100139.png" data-fancybox="group" data-caption="Zookeeper分布式锁" class="fancybox"><img alt="Zookeeper分布式锁" title="Zookeeper分布式锁" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728100139.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h2><h3 id="DistributeLock"><a href="#DistributeLock" class="headerlink" title="DistributeLock"></a>DistributeLock</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> String waitPath;</span><br><span class="line">    <span class="keyword">private</span> String currentNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributeLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>{</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line">                <span class="comment">//connectLatch  已经连接上  可以释放</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected) {</span><br><span class="line">                    connectLatch.countDown();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//waitLatch 需要释放</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted &amp;&amp; watchedEvent.getPath().equals(waitPath)) {</span><br><span class="line">                    waitLatch.countDown();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待zk连接成功再继续执行</span></span><br><span class="line">        connectLatch.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断根结点/locks是否存在</span></span><br><span class="line">        Stat stat = zkClient.exists(<span class="string">"/locks"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"创建/locks"</span>);</span><br><span class="line">            <span class="comment">//创建根结点</span></span><br><span class="line">            zkClient.create(<span class="string">"/locks"</span>, <span class="string">"locks"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkLock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">//创建对应的临时带序号的节点</span></span><br><span class="line"></span><br><span class="line">        currentNode = zkClient.create(<span class="string">"/locks/"</span> + <span class="string">"seq-"</span>, <span class="keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//先判断创建的节点是否是最小的节点，如果是  获取到锁  不是的话 监听他序号前一个节点</span></span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/locks"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//如果只有一个节点  那就直接获取锁  如果有多个节点 需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (children.size() == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Collections.sort(children);</span><br><span class="line">            <span class="comment">//获取对应的节点名称  seq-000000000</span></span><br><span class="line">            String thisNode = currentNode.substring(<span class="string">"/locks/"</span>.length());</span><br><span class="line">            <span class="comment">// 通过seq-0000000在 集合中的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = children.indexOf(thisNode);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) {</span><br><span class="line">                System.out.println(<span class="string">"数据异常"</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//只有一个几点  直接获取锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//获取前一个节点变化</span></span><br><span class="line">                waitPath = <span class="string">"/locks/"</span> + children.get(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] data = zkClient.getData(waitPath, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//等待监听</span></span><br><span class="line">                waitLatch.await();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkUnlock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        zkClient.delete(currentNode, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="LockTest"><a href="#LockTest" class="headerlink" title="LockTest"></a>LockTest</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException, KeeperException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DistributeLock lock1 = <span class="keyword">new</span> DistributeLock();</span><br><span class="line">        <span class="keyword">final</span> DistributeLock lock2 = <span class="keyword">new</span> DistributeLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.zkLock();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 启动  获取到锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    lock1.zkUnlock();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock2.zkLock();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 启动  获取到锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    lock2.zkUnlock();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Curator实现、"><a href="#Curator实现、" class="headerlink" title="Curator实现、"></a>Curator实现、</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="CuratorTest"><a href="#CuratorTest" class="headerlink" title="CuratorTest"></a>CuratorTest</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建分布式锁1</span></span><br><span class="line">        InterProcessMutex lock1 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">"/locks"</span>);</span><br><span class="line">        <span class="comment">//创建分布式锁2</span></span><br><span class="line">        InterProcessMutex lock2 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">"/locks"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 获取到锁"</span>);</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 再次获取到锁"</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 释放锁"</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 再次释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 获取到锁"</span>);</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 再次获取到锁"</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 释放锁"</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 再次释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CuratorFramework <span class="title">getCuratorFramework</span><span class="params">()</span> </span>{</span><br><span class="line">        ExponentialBackoffRetry policy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">                .retryPolicy(policy).build();</span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">"zookeeper 启动成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p><strong>半数机制，超过半数的投票通过，即通过。</strong></p><p>（1）第一次启动选举规则：</p><p><strong>投票过半数时，服务器 id 大的胜出</strong></p><p>（2）第二次启动选举规则：</p><p><strong>①EPOCH 大的直接胜出</strong></p><p><strong>②EPOCH 相同，事务 id 大的胜出</strong></p><p><strong>③事务 id 相同，服务器 id 大的胜出</strong></p><h2 id="生产集群安装多少-zk-合适？"><a href="#生产集群安装多少-zk-合适？" class="headerlink" title="生产集群安装多少 zk 合适？"></a><strong>生产集群安装多少</strong> <strong>zk</strong> 合适？</h2><p><strong>安装奇数台</strong></p><ul><li><p>生产经验：</p><p>10 台服务器：3 台 zk； </p><p>20 台服务器：5 台 zk；</p><p>100 台服务器：11 台 zk； </p><p>200 台服务器：11 台 zk</p></li></ul><p><strong>服务器台数多：好处，提高可靠性；坏处：提高通信延时</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      Zookeeper基础
    
    </summary>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://raptor1998.top/2021/07/22/zookeeper-base/"/>
    <id>http://raptor1998.top/2021/07/22/zookeeper-base/</id>
    <published>2021-07-21T16:00:00.000Z</published>
    <updated>2021-07-28T00:58:39.603Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Zookeeper工作机制"><a href="#Zookeeper工作机制" class="headerlink" title="Zookeeper工作机制"></a>Zookeeper工作机制</h2><p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注 册，一旦这些数据的状态发生变化，Zookeeper就 将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><h2 id="Zookeeper特点"><a href="#Zookeeper特点" class="headerlink" title="Zookeeper特点"></a>Zookeeper特点</h2><ol><li><p>Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。 </p></li><li><p>集群中只要有<strong>半数以上</strong>节点存活，Zookeeper集群就能正常服务。所 以Zookeeper适合安装奇数台服务器。 </p></li><li><p>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 </p></li><li><p>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。 </p></li><li><p>数据更新原子性，一次数据更新要么成功，要么失败。 </p></li><li><p>实时性，在一定时间范围内，Client能读到最新数据。 </p></li></ol><h2 id="Zookeeper本地模式安装、启动"><a href="#Zookeeper本地模式安装、启动" class="headerlink" title="Zookeeper本地模式安装、启动"></a>Zookeeper本地模式安装、启动</h2><p><strong>需JDK</strong></p><h3 id="zoo-cfg"><a href="#zoo-cfg" class="headerlink" title="zoo.cfg"></a>zoo.cfg</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that the initial </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that can pass between </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta">#</span><span class="bash"> the directory <span class="built_in">where</span> the snapshot is stored.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">do</span> not use /tmp <span class="keyword">for</span> storage, /tmp here is just </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> example sakes.</span></span><br><span class="line">dataDir=/usr/local/zookeeper/zookeeper-3.5.7/zkData</span><br><span class="line"><span class="meta">#</span><span class="bash"> the port at <span class="built_in">which</span> the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> the maximum number of client connections.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> increase this <span class="keyword">if</span> you need to handle more clients</span></span><br><span class="line"><span class="meta">#</span><span class="bash">maxClientCnxns=60</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Be sure to <span class="built_in">read</span> the maintenance section of the </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://zookeeper.apache.org/doc/current/zookeeperAdmin.html<span class="comment">#sc_maintenance</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of snapshots to retain <span class="keyword">in</span> dataDir</span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Purge task interval <span class="keyword">in</span> hours</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set to <span class="string">"0"</span> to <span class="built_in">disable</span> auto purge feature</span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.purgeInterval=1</span></span><br><span class="line">admin.serverPort=8081</span><br></pre></td></tr></tbody></table></figure></div><h3 id="端口冲突（踩坑）"><a href="#端口冲突（踩坑）" class="headerlink" title="端口冲突（踩坑）"></a>端口冲突（踩坑）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-6-centos bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">[root@VM-0-6-centos bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></tbody></table></figure></div><p>在启动之后，查看状态时发现未正常启动。日志报错  端口冲突</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.net.BindException: Address already in use</span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:444)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:436)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:225)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)</span><br><span class="line">at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:342)</span><br><span class="line">... 12 more</span><br></pre></td></tr></tbody></table></figure></div><h2 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h2><ol><li><p>tickTime = 2000<strong>：通信心跳时间，</strong>Zookeeper<strong>服务器与客户端心跳时间，单位毫秒</strong></p></li><li><p>initLimit = 10<strong>：</strong>LF<strong>初始通信时限</strong></p><p>Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）</p></li><li><p>syncLimit = 5<strong>：</strong>LF<strong>同步通信时限</strong></p><p>Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死</p><p>掉，从服务器列表中删除Follwer。 </p></li><li><p>dataDir<strong>：</strong>保存Zookeeper中的数据</p><p>注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。</p></li><li><p>clientPort = 2181<strong>：客户端连接端口，通常不做修改。</strong></p></li></ol><h1 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h1><h2 id="ssh免密连接"><a href="#ssh免密连接" class="headerlink" title="ssh免密连接"></a>ssh免密连接</h2><p><strong>在所有虚拟机上执行 <code>ssh-keygen</code>一路回车生成本地公钥和私钥，文件在/root/.ssh下，在/root/.ssh下创建<code>authorized_keys</code>授权文件，此文件内容为各机器生成的公钥，然后将此授权文件复制到各台机器</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727142826.png" data-fancybox="group" data-caption="生成公私钥" class="fancybox"><img alt="生成公私钥" title="生成公私钥" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727142826.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>ssh连接各虚拟机，<code>known_hosts</code>文件是记录你通过ssh连接过的虚拟机的公钥，此时连接需要密码</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727142939.png" data-fancybox="group" data-caption="know_hosts" class="fancybox"><img alt="know_hosts" title="know_hosts" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727142939.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>将<code>known_hosts</code>拷贝至各机器即可成功</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143354.png" data-fancybox="group" data-caption="配置成功" class="fancybox"><img alt="配置成功" title="配置成功" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143354.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p><strong>如何使用别名登录</strong></p></blockquote><p><strong>修改/etc/hosts</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143954.png" data-fancybox="group" data-caption="hosts" class="fancybox"><img alt="hosts" title="hosts" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143954.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143904.png" data-fancybox="group" data-caption="ssh别名登录" class="fancybox"><img alt="ssh别名登录" title="ssh别名登录" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727143904.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="分发脚本"><a href="#分发脚本" class="headerlink" title="分发脚本"></a>分发脚本</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">校验参数是否合法</span></span><br><span class="line"><span class="meta">if(($</span><span class="bash"><span class="comment">#==0))</span></span></span><br><span class="line">then</span><br><span class="line">        echo 请输入要分发的文件!</span><br><span class="line">        exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> -P 如果是软连接也能获取分发文件的绝对路径</span></span><br><span class="line">dirpath=$(cd `dirname $1`; pwd -P)</span><br><span class="line">filename=`basename $1`</span><br><span class="line"></span><br><span class="line">echo 要分发的文件的路径是:$dirpath/$filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">循环执行rsync分发文件到集群的每条机器</span></span><br><span class="line">for((i=133;i&lt;=134;i++))</span><br><span class="line">do</span><br><span class="line">        echo ---------------------centos$i---------------------</span><br><span class="line">        rsync -rvlt $dirpath/$filename  root@centos$i:$dirpath</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure></div><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>在集群中保存Zookeeper中的数据zkData（此处为自定义的目录）目录下添加myid并添加server对应的编号</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727145134.png" data-fancybox="group" data-caption="myid" class="fancybox"><img alt="myid" title="myid" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727145134.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.131.132:2888:3888</span><br><span class="line">server.2=192.168.131.133:2888:3888</span><br><span class="line">server.3=192.168.131.134:2888:3888</span><br></pre></td></tr></tbody></table></figure></div><p><strong>将内容分发至集群并修改myid，不可重复</strong></p><h3 id="配置解读"><a href="#配置解读" class="headerlink" title="配置解读"></a>配置解读</h3><p><strong>server.A=B:C:D</strong></p><p><strong>A</strong> 是一个数字，表示这个是第几号服务器；集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。 </p><p><strong>B</strong> 是这个服务器的地址；</p><p><strong>C</strong> 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口；</p><p><strong>D</strong> 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><h3 id="SID、ZXID、Epoch"><a href="#SID、ZXID、Epoch" class="headerlink" title="SID、ZXID、Epoch"></a>SID、ZXID、Epoch</h3><p><strong>SID</strong>：服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。</p><p><strong>ZXID</strong>：事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关。</p><p><strong>Epoch</strong>：每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</p><h3 id="Zookeeper——第一次启动"><a href="#Zookeeper——第一次启动" class="headerlink" title="Zookeeper——第一次启动"></a>Zookeeper——第一次启动</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727105240.png" data-fancybox="group" data-caption="zookeeper第一次启动选举" class="fancybox"><img alt="zookeeper第一次启动选举" title="zookeeper第一次启动选举" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727105240.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ol><li><p>服务器1启 动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING； </p></li><li><p>服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1） </p></li></ol><p>大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING</p><ol start="3"><li>服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服</li></ol><p>务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p><ol start="4"><li><p>服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为 1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING； </p></li><li><p>服务器5启动，同4一样当小弟。</p></li></ol><h3 id="Zookeeper——非第一次启动"><a href="#Zookeeper——非第一次启动" class="headerlink" title="Zookeeper——非第一次启动"></a>Zookeeper——非第一次启动</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727105724.png" data-fancybox="group" data-caption="Zookeeper——非第一次启动" class="fancybox"><img alt="Zookeeper——非第一次启动" title="Zookeeper——非第一次启动" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727105724.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ol><li>当ZooKeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：</li></ol><ul><li><p>服务器初始化启动。 </p></li><li><p>服务器运行期间无法和Leader保持连接。 </p></li></ul><ol start="2"><li>而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：</li></ol><ul><li><p>集群中本来就已经存在一个Leader。</p><p>对于第一种已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和Leader机器建立连接，并进行状态同步即可。</p></li><li><p><strong>集群中确实不存在</strong>Leader<strong>。</strong></p><p>假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。</p><p>SID为1、2、4的机器投票情况： </p><p>SID   <strong>（EPOCH，ZXID，SID ）</strong></p><p>1        <strong>（1，8，1）</strong> </p><p>2        <strong>（1，8，2）</strong> </p><p>4         <strong>（1，7，4）</strong> </p><p><strong>选举</strong>Leader<strong>规则：</strong> </p><p><strong><em>①EPOCH大的直接胜出</em></strong> </p><p><strong><em>②EPOCH相同，事务id大的胜出</em></strong> </p><p><strong><em>③事务id相同，服务器id大的胜出</em></strong></p></li></ul><h2 id="集群启动脚本"><a href="#集群启动脚本" class="headerlink" title="集群启动脚本"></a>集群启动脚本</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line"> "start"){</span><br><span class="line">        for i in 192.168.131.132 192.168.131.133 192.168.131.134</span><br><span class="line">        do</span><br><span class="line">                echo -----------zookeeper $i start-----------</span><br><span class="line">                ssh $i "/usr/local/zookeeper-3.5.7/bin/zkServer.sh start"</span><br><span class="line">        done</span><br><span class="line">};;</span><br><span class="line">"stop"){</span><br><span class="line">        for i in 192.168.131.132 192.168.131.133 192.168.131.134</span><br><span class="line">        do</span><br><span class="line">                echo -----------zookeeper $i stop-----------</span><br><span class="line">                ssh $i "/usr/local/zookeeper-3.5.7/bin/zkServer.sh stop"</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">};;</span><br><span class="line"></span><br><span class="line">"status"){</span><br><span class="line">        for i in 192.168.131.132 192.168.131.133 192.168.131.134</span><br><span class="line">        do</span><br><span class="line">                echo -----------zookeeper $i status-----------</span><br><span class="line">                ssh $i "/usr/local/zookeeper-3.5.7/bin/zkServer.sh status"</span><br><span class="line">        done</span><br><span class="line">};;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727145612.png" data-fancybox="group" data-caption="集群启动脚本" class="fancybox"><img alt="集群启动脚本" title="集群启动脚本" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727145612.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h1><h2 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a>命令行语法</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><strong>./zkCli.sh -server centos132:2181</strong></p><h3 id="znode-节点数据信息"><a href="#znode-节点数据信息" class="headerlink" title="znode 节点数据信息"></a><strong>znode</strong> 节点数据信息</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: centos132:2181(CONNECTED) 1] ls -s /</span><br><span class="line">[zookeeper]cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure></div><p>（1）czxid：创建节点的事务 </p><p>zxid每次修改 ZooKeeper 状态都会产生一个 ZooKeeper 事务 ID。事务 ID 是 ZooKeeper 中所有修改总的次序。每次修改都有唯一的 zxid，如果zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。</p><p>（2）ctime：znode 被创建的毫秒数（从 1970 年开始）</p><p>（3）mzxid：znode 最后更新的事务 zxid</p><p>（4）mtime：znode 最后修改的毫秒数（从 1970 年开始）</p><p>（5）pZxid：znode 最后更新的子节点 zxid</p><p>（6）cversion：znode 子节点变化号，znode 子节点修改次数</p><p>（7）dataversion：znode 数据变化号</p><p>（8）aclVersion：znode 访问控制列表的变化号</p><p>（9）ephemeralOwner：如果是临时节点，这个是 znode 拥有者的 session id。如果不是</p><p>临时节点则是 0。 </p><p>（10）dataLength：znode 的数据长度</p><p>（11）numChildren：znode 子节点数量</p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul><li><p>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</p></li><li><p>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</p></li></ul><p>（1）持久化目录节点</p><p>​    客户端与Zookeeper断开连接后，该节点依旧存在</p><p>（2）持久化顺序编号目录节点</p><p>​    客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><p>（3）临时目录节点</p><p>​    客户端与Zookeeper断开连接后，该节点被删除</p><p>（4）临时顺序编号目录节点</p><p>​    客户端与 Zookeeper 断开连接后 ， 该 节 点 被 删 除 ， 只 是Zookeeper给该节点名称进行顺序编号。</p><hr><p>创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数</p><p>器，由父节点维护</p><p><strong>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</strong></p><blockquote><p>创建普通节点</p></blockquote><p><strong>create /sanguo “diaochan”</strong></p><p><strong>create /sanguo/shuguo “liubei”</strong></p><hr><blockquote><p>获得节点的值</p></blockquote><p><strong>get -s /sanguo</strong></p><hr><blockquote><p>创建带序号的节点</p></blockquote><p><strong>create /sanguo/weiguo “caocao”</strong></p><p><strong>create -s /sanguo/weiguo/zhangliao “zhangliao”</strong></p><hr><blockquote><p>创建短暂节点</p></blockquote><p><strong>创建短暂的不带序号的节点 create -e /sanguo/wuguo “zhouyu”</strong></p><p><strong>创建短暂的带序号的节点 create -e -s /sanguo/wuguo “zhouyu”</strong></p><hr><blockquote><p>修改节点数据值</p></blockquote><p> <strong>set /sanguo/weiguo “simayi”</strong></p><h2 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727155601.png" data-fancybox="group" data-caption="监听器原理" class="fancybox"><img alt="监听器原理" title="监听器原理" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727155601.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>1）首先要有一个main()线程</p><p>2）在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 </p><p>3）通过connect线程将注册的监听事件发送给Zookeeper。 </p><p>4）在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。 </p><p>5）Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。 </p><p>6）listener线程内部调用了process()方法。 </p><p><strong>常见的监听</strong></p><p>1）监听节点数据的变化</p><p><strong>get path [watch]</strong></p><p>2）监听子节点增减的变化<br><strong>ls path [watch]</strong></p><p><strong>注册一次，只能监听一次。想再次监听，需要再次注册。</strong></p><h2 id="节点删除与查看"><a href="#节点删除与查看" class="headerlink" title="节点删除与查看"></a>节点删除与查看</h2><p><strong>删除节点 delete [path]</strong></p><hr><p><strong>递归删除 deleteall  [path]</strong></p><h2 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">context</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    System.out.println(<span class="string">"创建客户端连接"</span>);</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">            List&lt;String&gt; children = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                children = zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (String child : children) {</span><br><span class="line">                    System.out.println(child);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>{</span><br><span class="line">    String nodeCreated = zkClient.create(<span class="string">"/hdu"</span>, <span class="string">"cwh"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) {</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    }</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><h3 id="写入请求直接发给Leader节点"><a href="#写入请求直接发给Leader节点" class="headerlink" title="写入请求直接发给Leader节点"></a>写入请求直接发给Leader节点</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727181017.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727181017.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="写入请求直接发给Follower节点"><a href="#写入请求直接发给Follower节点" class="headerlink" title="写入请求直接发给Follower节点"></a>写入请求直接发给Follower节点</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727181219.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210727181219.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      Zookeeper基础
    
    </summary>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://raptor1998.top/2021/07/14/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://raptor1998.top/2021/07/14/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-07-14T03:08:12.794Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="具备条件"><a href="#具备条件" class="headerlink" title="具备条件"></a>具备条件</h3><p> 1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</p><p>2、高可用的获取锁与释放锁</p><p>3、高性能的获取锁与释放锁</p><p>4、具备可重入特性； </p><p>5、具备锁失效机制，防止死锁</p><p> 6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</p><h2 id="synchronized-this"><a href="#synchronized-this" class="headerlink" title="synchronized (this)"></a>synchronized (this)</h2><p><strong>Java中的锁，只能保证在同一个JVM进程内中执行。在分布式环境下失效</strong></p><h2 id="redis实现简单分布式锁"><a href="#redis实现简单分布式锁" class="headerlink" title="redis实现简单分布式锁"></a>redis实现简单分布式锁</h2><p>通过redis的<strong>SETNX</strong>命令：如果键不存在则新增,存在则不改变已经有的值。、</p><blockquote><p>控制库存场景模拟</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">"product_01"</span>;</span><br><span class="line">String clientId = UUID.randomUUID().toString();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    Boolean result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//不等锁，直接返回失败</span></span><br><span class="line">    <span class="comment">//            if (!result) {</span></span><br><span class="line">    <span class="comment">//                return "error";</span></span><br><span class="line">    <span class="comment">//            }</span></span><br><span class="line">    <span class="comment">//等待锁</span></span><br><span class="line">    <span class="keyword">while</span> (!result) {</span><br><span class="line">        result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> surplus = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">"shangpin"</span>));</span><br><span class="line">    <span class="keyword">if</span> (surplus &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">double</span> random = Math.random();</span><br><span class="line">        <span class="keyword">int</span> time = (<span class="keyword">int</span>) (random * <span class="number">1000</span>);</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        <span class="keyword">int</span> temp = surplus - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"shangpin"</span>, temp + <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"扣减成功，当前剩余"</span> + temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"成功"</span>;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"扣减失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"失败"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) {</span><br><span class="line">        stringRedisTemplate.delete(lockKey);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">synchronized (this)</span></span><br><span class="line"><span class="comment">1. 在分布式环境下  多个jvm  进程级别锁</span></span><br><span class="line"><span class="comment">Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "lalal");</span></span><br><span class="line"><span class="comment">stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);</span></span><br><span class="line"><span class="comment">stringRedisTemplate.delete(lockKey);</span></span><br><span class="line"><span class="comment">1. 进程执行到  设置过期时间, 服务挂掉，则无法解锁</span></span><br><span class="line"><span class="comment">2. 若A需要执行 15s, 代码未执行完成，锁过期，则后续请求B进入，加B锁，5s后，A执行到删除锁，删掉B加的锁</span></span><br><span class="line"><span class="comment">    同理，C进来，上锁，B此时执行了5s，  套娃下去，总会出现，多个请求，同时在做库存相关操作</span></span><br><span class="line"><span class="comment">String clientId = UUID.randomUUID().toString();</span></span><br><span class="line"><span class="comment">if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) {</span></span><br><span class="line"><span class="comment">        stringRedisTemplate.delete(lockKey);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">1. 引入进程识别，只能删除我自己加的锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在主线程处理业务逻辑时，开辟新的timer线程，强行为locakKey续命，最好设置为过期时间的1/3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><blockquote><p><a href="https://redisson.org/" target="_blank" rel="noopener">Redisson</a>是架设在<a href="http://redis.cn/" target="_blank" rel="noopener">Redis</a>基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210714100409.png" data-fancybox="group" data-caption="redisson分布式锁" class="fancybox"><img alt="redisson分布式锁" title="redisson分布式锁" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210714100409.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>{</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    config.setLockWatchdogTimeout(<span class="number">4000</span>);</span><br><span class="line">    <span class="keyword">long</span> lockWatchdogTimeout = config.getLockWatchdogTimeout();</span><br><span class="line">    System.out.println(lockWatchdogTimeout);</span><br><span class="line">    <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">"product_01"</span>;</span><br><span class="line">String clientId = UUID.randomUUID().toString();</span><br><span class="line">RLock redissonLock = redisson.getLock(lockKey);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//            redissonLock.lock();</span></span><br><span class="line">    <span class="comment">//等待100s就放弃等待</span></span><br><span class="line">    <span class="keyword">boolean</span> b = redissonLock.tryLock(<span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">false</span>) {</span><br><span class="line">        System.out.println(<span class="string">"等待时间超时"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"失败了"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> surplus = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">"shangpin"</span>));</span><br><span class="line">    <span class="keyword">if</span> (surplus &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">double</span> random = Math.random();</span><br><span class="line">        <span class="keyword">int</span> time = (<span class="keyword">int</span>) (random * <span class="number">1000</span>);</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        <span class="keyword">int</span> temp = surplus - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"shangpin"</span>, temp + <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"扣减成功，当前剩余"</span> + temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"成功"</span>;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"扣减失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"失败"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">"异常"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"异常"</span>;</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    <span class="keyword">if</span> (redissonLock.isLocked()) {  <span class="comment">//是否锁定状态</span></span><br><span class="line">        <span class="keyword">if</span> (redissonLock.isHeldByCurrentThread()) {  <span class="comment">//是否当前执行线程的锁</span></span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"不是当前线程锁"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"锁已经过期"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="redisson-lock"><a href="#redisson-lock" class="headerlink" title="redisson lock"></a>redisson lock</h3><p><strong>详见<a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a></strong></p><hr><blockquote><p>RLock redissonLock = redisson.getLock(lockKey);    获取锁实例</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个RLock对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(<span class="keyword">this</span>.connectionManager.getCommandExecutor(), name);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">        <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">        <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">        <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>redissonLock.lock();</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">//获取当前线程id</span></span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    Long ttl = <span class="keyword">this</span>.tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl != <span class="keyword">null</span>) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ttl不为空，则获取锁失败，订阅到对应的锁channel</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = <span class="keyword">this</span>.subscribe(threadId);</span><br><span class="line">        <span class="keyword">this</span>.commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">                <span class="comment">//再次尝试获取</span></span><br><span class="line">                ttl = <span class="keyword">this</span>.tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">//如果ttl为空，则获取锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ttl大于0  则等待ttk时间后继续尝试</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span>) {</span><br><span class="line">                    <span class="keyword">this</span>.getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">this</span>.getEntry(threadId).getLatch().acquire();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//取消对channel的订阅</span></span><br><span class="line">            <span class="keyword">this</span>.unsubscribe(future, threadId);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>获取锁</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">//带有过期时间，则按照普通方式获取</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//按照带有过期时间的方式获取</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="keyword">this</span>.tryLockInnerAsync(<span class="keyword">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还持有这个锁，则开启定时任务不断刷新锁的过期时间</span></span><br><span class="line">        ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) {</span><br><span class="line">                    Long ttlRemaining = (Long)future.getNow();</span><br><span class="line">                    <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) {</span><br><span class="line">                        RedissonLock.<span class="keyword">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit,     </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                  <span class="comment">//如果锁不存在，则通过hset设置它的值，并设置过期时间</span></span><br><span class="line">                  <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="comment">//如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span></span><br><span class="line">                  <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="comment">//如果锁已存在，但并非本线程，则返回过期时间ttl</span></span><br><span class="line">                  <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">        Collections.&lt;Object&gt;singletonList(getName()), </span><br><span class="line">                internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>通过exists判断，如果锁不存在，则设置值和过期时间，加锁成功</strong></p><p><strong>通过hexists判断，如果锁已存在，并且锁的是当前线程，则证明是重入锁，加锁成功</strong></p><p><strong>如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。返回当前锁的过期时间，加锁失败</strong></p><h3 id="redisson-unlock"><a href="#redisson-unlock" class="headerlink" title="redisson unlock"></a>redisson unlock</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解锁方法</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line"></span><br><span class="line">    future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line">                cancelExpirationRenewal(threadId);</span><br><span class="line">                result.tryFailure(future.cause());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//获取返回值</span></span><br><span class="line">            Boolean opStatus = future.getNow();</span><br><span class="line">            <span class="comment">//如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) {</span><br><span class="line">                IllegalMonitorStateException cause = </span><br><span class="line">                    <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"</span></span><br><span class="line"><span class="string">                        attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                        + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">                result.tryFailure(cause);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解锁成功，取消刷新过期时间的那个定时任务</span></span><br><span class="line">            <span class="keyword">if</span> (opStatus) {</span><br><span class="line">                cancelExpirationRenewal(<span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">            result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//如果锁已经不存在， 发布锁释放的消息</span></span><br><span class="line">            <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="comment">//如果释放锁的线程和已存在锁的线程不是同一个线程，返回null</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">//通过hincrby递减1的方式，释放一次锁</span></span><br><span class="line">            <span class="comment">//若剩余次数大于0 ，则刷新过期时间</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="comment">//否则证明锁已经释放，删除key并发布锁释放的消息</span></span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">    Arrays.&lt;Object&gt;asList(getName(), getChannelName()), </span><br><span class="line">        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>如果锁已经不存在，通过publish发布锁释放的消息，解锁成功</strong></p><p><strong>如果解锁的线程和当前锁的线程不是同一个，解锁失败，抛出异常</strong></p><p><strong>通过hincrby递减1，先释放一次锁。若剩余次数还大于0，则证明当前锁是重入锁，刷新过期时间；若剩余次数小于0，删除key并发布锁释放的消息，解锁成功</strong></p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><blockquote><p>看门狗失效</p></blockquote><p>lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</p><p>默认值：<code>30000</code></p><p>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用<code>leaseTimeout</code>参数的情况。如果该看门口未使用<code>lockWatchdogTimeout</code>去重新调整一个分布式锁的<code>lockWatchdogTimeout</code>超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</p><p>你设置了失效时间，所以这个看门狗设置是无效的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/youngdeng/p/12883790.html" target="_blank" rel="noopener"></a><a href="https://www.cnblogs.com/youngdeng/p/12883790.html" target="_blank" rel="noopener">redis 分布式锁的 5个坑，真是又大又深</a></p><p><a href="https://blog.csdn.net/lzhcoder/article/details/88387751" target="_blank" rel="noopener">Redis分布式锁的原理以及如何续期</a></p><p><a href="https://mp.weixin.qq.com/s/RLeujAj5rwZGNYMD0uLbrg" target="_blank" rel="noopener">每秒上千订单场景下的分布式锁高并发优化实践！</a></p><p><a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a></p><p><a href="https://blog.csdn.net/qq_35843095/article/details/109815062" target="_blank" rel="noopener">redisson watchdog 使用和原理</a></p></body></html>]]></content>
    
    <summary type="html">
    
      redis分布式锁的超卖场景
    
    </summary>
    
    
      <category term="Redis" scheme="http://raptor1998.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://raptor1998.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 死信队列</title>
    <link href="http://raptor1998.top/2021/07/10/mq%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    <id>http://raptor1998.top/2021/07/10/mq%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2021-07-20T11:33:25.125Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="死信概念"><a href="#死信概念" class="headerlink" title="死信概念"></a>死信概念</h2><blockquote><p>概念</p></blockquote><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理</p><p>解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息</p><p>进行消费，但某些时候由于特定的<strong>原因导致</strong> <strong>queue</strong> <strong>中的某些消息无法被消费</strong>，这样的消息如果没有</p><p>后续的处理，就变成了死信，有死信自然就有了死信队列。</p><blockquote><p>应用场景</p></blockquote><p>为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p><h2 id="死信来源"><a href="#死信来源" class="headerlink" title="死信来源"></a>死信来源</h2><ul><li><p>消息 TTL 过期</p></li><li><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p></li><li><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false</p></li></ul><h1 id="JAVA案例"><a href="#JAVA案例" class="headerlink" title="JAVA案例"></a>JAVA案例</h1><h2 id="队列声明"><a href="#队列声明" class="headerlink" title="队列声明"></a>队列声明</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqStatementConfig</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_EXCHANGE = <span class="string">"PRODUCT_EXCHANGE"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_QUEUE = <span class="string">"PRODUCT_QUEUE"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_ROUTINE_KEY = <span class="string">"PRODUCT_EXCHANGE_PRODUCT_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="string">"DEAD_LETTER_EXCHANGE"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明死信队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">"DEAD_LETTER_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ROUTINE_KEY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_ROUTINE_KEY = <span class="string">"DEAD_LETTER_EXCHANGE_DEAD_LETTER_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通订单交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"productExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">PRODUCT_EXCHANGE_STATEMENT</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(PRODUCT_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"deadExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">PRODUCT_DEAD_LETTER_EXCHANGE_STATEMENT</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列ttl并与死信绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"productQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>{</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">"x-dead-letter-exchange"</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">"x-dead-letter-routing-key"</span>, DEAD_LETTER_ROUTINE_KEY);</span><br><span class="line">        <span class="comment">//声明队列的 TTL  十五分钟未付款自动取消订单  下文15s</span></span><br><span class="line">        args.put(<span class="string">"x-message-ttl"</span>, <span class="number">15000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(PRODUCT_QUEUE).withArguments(args).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"deadQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明订单与普通交换机绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">productQueueBindingProductExchange</span><span class="params">(@Qualifier(<span class="string">"productQueue"</span>)</span> Queue productQueue,</span></span><br><span class="line"><span class="function">                                                      @<span class="title">Qualifier</span><span class="params">(<span class="string">"productExchange"</span>)</span> DirectExchange productExchange) </span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(productQueue).to(productExchange).with(PRODUCT_ROUTINE_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadQueueBindingDeadExchange</span><span class="params">(@Qualifier(<span class="string">"deadQueue"</span>)</span> Queue deadQueue,</span></span><br><span class="line"><span class="function">                                                @<span class="title">Qualifier</span><span class="params">(<span class="string">"deadExchange"</span>)</span> DirectExchange deadExchange) </span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deadQueue).to(deadExchange).with(DEAD_LETTER_ROUTINE_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>{</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"DEAD_LETTER_QUEUE"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message, Channel channel)</span> </span>{</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"收到死信队列的消息"</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      RabbitMQ实现延迟队列
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://raptor1998.top/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://raptor1998.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MySQL误删恢复</title>
    <link href="http://raptor1998.top/2021/06/24/mysql%E8%AF%AF%E5%88%A0%E6%81%A2%E5%A4%8D/"/>
    <id>http://raptor1998.top/2021/06/24/mysql%E8%AF%AF%E5%88%A0%E6%81%A2%E5%A4%8D/</id>
    <published>2021-06-24T06:21:30.211Z</published>
    <updated>2021-06-24T08:29:31.342Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="MySQL误删恢复"><a href="#MySQL误删恢复" class="headerlink" title="MySQL误删恢复"></a>MySQL误删恢复</h1><h2 id="MySQL的binlog日志"><a href="#MySQL的binlog日志" class="headerlink" title="MySQL的binlog日志"></a>MySQL的binlog日志</h2><blockquote><p>作用</p></blockquote><ul><li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li><li>用于数据库的基于时间点的还原。</li></ul><blockquote><p>binlog的三种模式</p></blockquote><ol><li><p>statement：记录每一条修改数据的sql。</p><p>优点：日志文件比较小，节约io操作，性能较好。</p><p>缺点：只记录执行语句，所以还需要保证在主从执行的得到相同的结果。所以准确性差。</p></li><li><p>row：保存哪条记录被修改。</p><p>优点：准确性强。</p><p>缺点:日志文件比较大。</p></li><li><p>mixed：兼顾前两者的优点。</p></li></ol><blockquote><p>如何查看是否开启</p></blockquote><p>*<em>SHOW VARIABLES LIKE ‘log_bin%’; *</em></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624160512.png" data-fancybox="group" data-caption="binlog是否开启" class="fancybox"><img alt="binlog是否开启" title="binlog是否开启" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624160512.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>如何配置？</p></blockquote><p>在<strong>[mysqld]</strong>节点下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">binlog_format="ROW"</span><br></pre></td></tr></tbody></table></figure></div><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p><strong>SHOW MASTER LOGS;</strong> 查看有哪些binlog文件</p><p><strong>show master status\G</strong> 查看当前是在那个日志文件中</p><p><strong>FLUSH LOGS;</strong>可以阶段日志文件，重定向到新的日志文件中</p><p><strong>show variables like ‘%datadir%’;</strong>查看日志文件位置</p><p>*<em>mysqlbinlog –no-defaults /var/lib/mysql/mysql-bin.000008 *</em>查看日志文件</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="模拟数据录入和删除"><a href="#模拟数据录入和删除" class="headerlink" title="模拟数据录入和删除"></a>模拟数据录入和删除</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624161712.png" data-fancybox="group" data-caption="模拟删除" class="fancybox"><img alt="模拟删除" title="模拟删除" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624161712.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>*<em>mysqlbinlog –no-defaults /var/lib/mysql/mysql-bin.000008 *</em>查看dangq日志的内容</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624162105.png" data-fancybox="group" data-caption="binlog日志内容" class="fancybox"><img alt="binlog日志内容" title="binlog日志内容" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624162105.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="根据起始时间"><a href="#根据起始时间" class="headerlink" title="根据起始时间"></a>根据起始时间</h4><p><strong>mysqlbinlog –no-defaults –start-datetime=’2021-06-24 16:14:01’ –stop-datetime=’2021-06-24 16:15:47’ /var/lib/mysql/mysql-bin.000008 | mysql -u root -p</strong></p><h4 id="根据起始点"><a href="#根据起始点" class="headerlink" title="根据起始点"></a>根据起始点</h4><p><strong>mysqlbinlog –no-defaults –start-position=445 –stop-position=1521 /var/lib/mysql/mysql-bin.000008 | mysql -u root -p</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624162728.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210624162728.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://raptor1998.top/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://raptor1998.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>md渲染HTML测试</title>
    <link href="http://raptor1998.top/2021/06/01/md%E6%B8%B2%E6%9F%93HTML%E6%B5%8B%E8%AF%95/"/>
    <id>http://raptor1998.top/2021/06/01/md%E6%B8%B2%E6%9F%93HTML%E6%B5%8B%E8%AF%95/</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2021-06-01T06:55:45.714Z</updated>
    
    <content type="html"><![CDATA[<html lang="en"><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>记事本</title>    <!-- 开发环境版本，包含了有帮助的命令行警告 -->    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="raptor's blog" type="application/atom+xml"></head><body>    <div class="app">        <input type="text" v-model="todo" @keyup.enter="addtodo">        <section class="main">            <ul class="todo-list">                <li class="todo" v-for="(item,index) in list">                    <div class="view">                           <span class="index" v-text="index+1+'.'"></span>                        <label v-text="item"></label>                        <button class="destory" @click="deleteTODO(index)">x</button>                    </div>                </li>            </ul>        </section>        <br>        <strong v-if="this.list.length != 0" v-text="list.length+'items'"></strong>        <input type="button" value="clear" @click="clear" v-show="this.list.length!=0">    </div><script>    new Vue({        el: ".app",        data: {            todo: "",            list: []        },        methods: {            addtodo(){                console.log(this.todo);                this.list.push(this.todo)                this.todo=""            },            deleteTODO(index){                this.list.splice(index,1)            },            clear(){                this.list=[]            }        }    })</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://raptor1998.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://raptor1998.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Hologres：云原生HSAP服务</title>
    <link href="http://raptor1998.top/2021/05/24/Hologres%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://raptor1998.top/2021/05/24/Hologres%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-05-23T16:00:00.000Z</published>
    <updated>2021-05-27T02:43:43.726Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="Hologres：云原生HSAP服务"><a href="#Hologres：云原生HSAP服务" class="headerlink" title="Hologres：云原生HSAP服务"></a>Hologres：云原生HSAP服务</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>通过大量数据进行商业洞察，从而驱动业务发展已经成为当前商业发展的主流趋势。在阿里内部有着成熟的大数据技术栈与业务场景，给我们构建服务提供了宝贵的经验。例如为了支持业务实时决策制定能力，后台服务会使用大数据的技术栈进行数据的收集，将购买交易记录和用户点击等日志进行持续的统计，产出最新的结果供决策使用。然而随着业务的发展，传统的OLAP(Online Analytical Processing)系统已经无法满足需求。</strong></p><ol><li><strong>分析能力与服务能力的融合</strong>：在传统的OLAP系统中，大量的数据通过离线的计算完成数据的分析，然后将分析结果传递给在线服务进行使用。而实时决策制定不仅是一个在线服务，在服务的同时，也要进行复杂的数据分析，不能将其割裂。</li><li><strong>实时分析与离线分析的融合</strong>：当前的业务需要持续的进行数据更新，并快速产出最新的分析结果，供决策使用。高频写入的数据要在秒级别可读。传统OLAP的离线ETL所造成的的延迟已经不符合业务的要求。OLTP系统虽然支持了实时写入，但是覆盖场景有限。如在点击日志这种高频数据写入的同时，提供高效的查询服务，OLTP系统是无法完全支持的。</li></ol><p>针对上述场景，本文提出了<strong>HSAP(hybrid serving/analytical processing，服务分析一体化)</strong>的概念。</p><h2 id="关键性设计"><a href="#关键性设计" class="headerlink" title="关键性设计"></a>关键性设计</h2><h3 id="HSAP提出"><a href="#HSAP提出" class="headerlink" title="HSAP提出"></a>HSAP提出</h3><p>实时业务正在对数据的存储和计算提出越来越多的要求，这里以一个电商平台的推荐系统为例子，解释了这些需求，重点关注数据导入和查询模式两个维度。</p><h4 id="实时业务需求场景"><a href="#实时业务需求场景" class="headerlink" title="实时业务需求场景"></a>实时业务需求场景</h4><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="推荐系统业务场景" class="fancybox"><img alt="推荐系统业务场景" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210522160950.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="推荐系统业务场景"></a></p><p>当用户和我们的平台做交互的时候，用户的行为首先会被存储在像kafka或datahub这类消息队列当中，这些消息队列中的数据会经过实时清洗，沉淀到我们的系统当中作为事件表，这些事件表当中的事件往往并不包含完整的信息，比如说，当用户点击一个商品的时候，这个事件可能包含了这个用户的id，我们需要用用户的id去找到用户的其他信息，为了做到这一点，我们经常需要把OLTP数据库当中的数据同步到系统中，作为一个尾表。</p><p>比如说在这个案例中，可能或有商品表和用户表，当有了这些尾表之后，就可以把这些事件和尾表做一个关联，关联完的数据作为一个实时特征被传到下游的推荐系统当中，这个关联的过程需要非常高效的点查和服务型的查询。</p><p>除了这些基础的特征之外，还有一些派生出的特征，比如说在过去五分钟一个商品的点击、过去七天一个网页的浏览，依赖于这些窗口的粒度，我们可能采取流式或者批的方式进行聚合，聚合出来的派生的特征也会发送给下游的推荐系统。</p><p>除了这些之外，算法工程师和运营也需要对存在表里的数据做交互式的分析，从而对用户的行为有更好的理解，从而帮助调整模型或者运维的决策。</p><h4 id="复杂的业务架构"><a href="#复杂的业务架构" class="headerlink" title="复杂的业务架构"></a>复杂的业务架构</h4><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="复杂度业务架构" class="fancybox"><img alt="复杂度业务架构" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210522174627.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="复杂度业务架构"></a></p><p>所以我们可以看到，一个实时的推荐业务，对大数据系统有着非常复杂和多样化的需求，为了满足这些需求，业务架构变得越来越复杂。不得不借用多个系统，比如说，我们的业务往往会借用Hbase和Cassandra[kəˈsændrə]数据库来满足点查或者服务型查询的这些需求，使用druid和clickhouse来满足多维分析的需求，使用maxcompute和hive满足批处理的需求，同时，有些系统需要去查询和关联存在多个系统中的数据，所以又不得不用Drill和presto这样的系统，去对多个系统当中的数据做联邦查询，或者离线加速，还有一部分应用有一些服务型的需求，这些对延时的要求很高，对QPS的要求也很高，所以还需要引入类似于redis和mysql这样的缓存系统来满足需求。</p><p>可以看出，这个架构非常复杂，而且不得不吧数据存放在多个系统当中，当这样做的时候，就会自然而然的形成数据孤岛，数据孤岛一旦形成，开发人员就不得不在各个系统之间同步数据，这无疑给系统带来了复杂度，也带来了不必要的成本，同时，工程师需要学习多个系统，增加了学习成本 。</p><p><strong>综上，HSAP则是包含了上述全部的能力，提供服务分析一体化的数据处理服务。</strong></p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524092149.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>Hologres采用了存储计算分离的架构，全部的数据文件和日志文件都默认保存在盘古系统中，当然也支持选择开源的HDFS，存储和计算引擎都在worker节点当中。</p><p>这样存储层和计算层都可以独自根据系统负载和资源现状，进行灵活扩展，可以充分利用云上资源的弹性，当需要更多存储空间时，可以增加存储节点来增大存储空间，当需要更多的计算能力的时候，可以水平的增加worker节点提高计算能力。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>Hologres中存在两种存储类型的表，行存表主要服务于延迟低的行数据点查场景，列存表则主要服务于复杂分析的高吞吐列扫描场景。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524104116.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>数据库中所有的<strong>数据表(Table)</strong>被划分到<strong>表组(Table Group)</strong>中。每个Table Group被划分成多个<strong>Table Group shard(TGS,表组分片)</strong>。所以TGS（表组分片）将每张表的数据部分和索引部分都划分成了多个分片，每个分片被称为<strong>Tablet</strong>。Tablet同样分为行存(用于点查)、列存(用于列扫描)两种类型</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>它的一个设计思路就是，根据过往经验，发现大多数写操作只会涉及到一些关系比较密切的表。每个表的写入会涉及数据和索引同时改动。于是将这些关系密切的表放在一个表组中，通过TGS（表组分片）来横向操作一组tablet，TGS的一次写入就可以视为一次原子操作，并只持久化一条日志。这样的设计不仅减少了日志的写入量，同时也减少了表之间的数据的洗牌</p><h3 id="Table-Group-shard-TGS-表组分片"><a href="#Table-Group-shard-TGS-表组分片" class="headerlink" title="Table Group shard(TGS,表组分片)"></a>Table Group shard(TGS,表组分片)</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524110628.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>TGS是Hologres的数据管理单元。一个TGS包含1个WAL(Write-Ahead Logging, 预写日志系统) Manager和多个Tablet。</p><h4 id="写原理"><a href="#写原理" class="headerlink" title="写原理"></a>写原理</h4><p>如上图所示，当写入请求到来时，经过以下几个步骤</p><ol><li>分配一个<strong>LSN(Log sequence number，版本号)</strong>, 这个版本号由时间戳和一个递增序列值构建而成</li><li>WAL（预写日志系统）构建一条数据注入的日志，并持久化到log file中</li><li>Tablet对应的内存表接收并完成这次写请求，该次写入的内容对读可见</li></ol><p>如果内存表满了，则数据刷新到Shard File中，并新建一个内存表。Shard File会在后台异步完成整合与压缩。</p><blockquote><ul><li>内存表：就是一个数据中转表。数据写入时会首先写入内存表，内存表会定期(或写满时)将数据刷新到Shard File中进行持久化。</li><li>Shard File: 分片文件被组织成为多层结构。L0层，每个shard file对应一个内存表。从L1开始，所有的数据被拆分成多份到不同的shard file中，并通过key进行排序，保证每个shard file的key所在的范围均不重叠。因为每个shard file容量有限，每层文件数量有限，于是随着数据的增多，层数也逐步增多。我们可以手动规定shard file的最大容量M，和第i层与(i+1)层文件数量的倍数K。LSM Tree的算法策略是append操作，底层文件是只能追加无法修改的，于是HOS会持续将shard文件做整合以避免文件数量膨胀，该操作是异步后台完成的，读写均无需关心。</li><li>当TGS出现故障时，系统会根据Log重新构建内存表，结合shard文件从而完成整张表的重新恢复。</li></ul></blockquote><h3 id="行存-列存"><a href="#行存-列存" class="headerlink" title="行存\列存"></a>行存\列存</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524111120.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>Hologres底层支持行存储和列存储两种文件格式，行存适用于基于PK的点查场景，列存适用于OLAP复杂查询场景。对于两种存储格式Hologres在底层处理也有略微不同，如图所示。数据写入的时候先写log，log存储在分布式文件系统，保证整个服务的数据不会丢失，因为即便服务器挂掉也可以从分布式系统中恢复。Log写完之后再写MemTable，就是内存表，这样系统才认为是数据写入成功。MemTable有一定的大小，写满了之后会将其中的数据逐渐Flush到文件中，文件是存储在分布式系统中的。而对于行存储和列存储的区别就在Flush到文件的这个过程中，这个过程会将行存表Flush成行存储的文件，列存表会Flush成列存文件。在Flush的过程中会产生很多小文件，后台会将这些小文件合并成一个大文件。</p><h2 id="执行和调度引擎"><a href="#执行和调度引擎" class="headerlink" title="执行和调度引擎"></a>执行和调度引擎</h2><h3 id="高并发查询"><a href="#高并发查询" class="headerlink" title="高并发查询"></a>高并发查询</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524162408.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>一次请求的全部执行过程如上图所示。</p><p><strong>步骤一</strong>：在一次请求提交之后，FE中的<strong>Query Optimizer</strong>产出一份执行计划图，并将执行计划转换成执行分片(fragments)。执行分片分为3种：读、写和查询。</p><ul><li><p>read/write fragments：包含了读写表的算子</p></li><li><p>query fragments：包含非读写的其他处理算子</p><p>fragments进一步会被划为多个fragment instance(分片实例)，每个分片实例操作一个TGS。</p></li></ul><p><strong>步骤二</strong>：FE（前端接收节点）将请求发送到Coordinator（协调器），分片实例会被Coordinator分发到不同的worker中执行。</p><ul><li><p>read/write实例：被分配到操作对应的TGS的worker中执行</p></li><li><p>query实例：可以被分配到任意worker中执行。存储管理器和资源管理器同步了各个worker的位置和集群工作负载的信息。根据当前的集群负载来分配query实例到对应的worker，以达到集群的负载均衡。</p></li></ul><p><strong>步骤三：</strong>在每个Worker Node中，fragment instances（分片实例）被映射到多个<strong>Work Units</strong>。<strong>WU是Hologres的基本执行单元。</strong>WU会进一步动态生成多个WUs。</p><ul><li><p>read fragment instance<br>首先，产出一个同步读WU，主要工作是从tablet获取当前的版本号和元数据信息。元数据信息包含内存表的读快照和shard文件列表。<br>然后，同步WU会产出多个读接收WU，并行执行内存表和shard文件的读取，并完成相关的数据处理工作(如udf)</p></li><li><p>write fragment instance: 写分片实例中的非写的相关计算会被分配的Query WU中执行。写入的部分会产出一个写同步WU完成WAL的log持久化，然后产出多个写接收WU用于并行更新各个Tablet。</p></li><li><p>query fragment instance: 产出Query WU。</p></li></ul><h3 id="调度和隔离"><a href="#调度和隔离" class="headerlink" title="调度和隔离"></a>调度和隔离</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210524200154.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>当系统支持这么高并发的时候，传统的系统往往使用操作系统提供的线程来实现这种并发，但是当并发度特别高的时候，操作系统的调度带来的开销会越来越大，为了解决这个问题，引入了Execution Context这个概念，Execution Context是一个用户态的线程，Hologres会利用Execution Context协助式的调度刚才提到的工作单元（WU），同时Execution Context本身能够被操作系统线程协助式的调度，Hologres还有一个HOS的调度器，他会负责在系统的线程间，去负载均衡Execution Context ，有了Execution Context这个概念，可以让系统获得非常高的并发，并且能够有很少的额外开销。</p><p>出了Execution Context还引入了调度组的概念，一个调度组由一些相关的EC组成，会为每一个查询创建一个调度组，有了调度组之后，调度器就理解了查询的slo（ service level objectives服务水平目标），从而做出更加优化的调度决定。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>论文后面主要讲述Hologres在实验环境下的具体表现效果以及未来规划。2020双十一，Hologres顶住了5.96亿每秒的实时数据洪峰，单表存储高达2.5PB。基于万亿级数据对外提供多维分析和服务，99.99%的查询可以在80ms以内返回结果，真正做到数据的实时及离线一体化，支持在线应用服务，为商家和消费者带来了更加智能的消费体验。</p><h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p><a href="https://zhuanlan.zhihu.com/p/360750135" target="_blank" rel="noopener">云原生HSAP产品Hologres原理论文解读</a></p><p>VLDB2020丨Hologres-云原生HSAP服务</p><p><a href="https://help.aliyun.com/video_list/173039.html?spm=a2c4g.11186623.6.846.16ad174atQLBZP" target="_blank" rel="noopener">交互式分析Hologres</a></p><p><a href="https://zhuanlan.zhihu.com/p/364121970" target="_blank" rel="noopener">新一代Hologres实时数仓大揭秘</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="论文简述" scheme="http://raptor1998.top/categories/%E8%AE%BA%E6%96%87%E7%AE%80%E8%BF%B0/"/>
    
    
      <category term="Hologres" scheme="http://raptor1998.top/tags/Hologres/"/>
    
  </entry>
  
  <entry>
    <title>BigTable简述</title>
    <link href="http://raptor1998.top/2021/05/17/BIgTable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://raptor1998.top/2021/05/17/BIgTable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-05-16T16:00:00.000Z</published>
    <updated>2021-05-24T08:41:02.268Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>​        论文是<strong>Bigtable: A Distributed Storage System for Structured Data</strong>，用于结构化数据的分布式存储系统。</p><p>​        Bigtable是一个分布式的结构化数据存储系统，它被设计用来处理海量数据：通常是分布在数千台普通服务器上的PB级的数据。Google的很多项目使用Bigtable存储数据，包括Web索引、Google Earth。这些应用对Bigtable提出的要求差异非常大，无论是在数据量上（从URL到网页到卫星图像）还是在响应速度上（从后端的批量处理到实时数据服务）。尽管应用需求差异很大，但是，针对Google的这些产品，Bigtable还是成功的提供了一个灵活的、高性能的解决方案。这篇论文描述了Bigtable提供的简单的数据模型，利用这个模型，可以动态的控制数据的分布和格式；此外，还描述Bigtable的设计和实现。</p><h1 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h1><p>​        首先，bigtable在逻辑上的意义。</p><p>​        Bigtable是一个稀疏的、分布式的、持久化存储的多维度排序Map。Map的索引是行关键字、列关键字以及时间戳。</p><p>​        <strong>(row:string, column:string,time:int64)-&gt;string</strong></p><blockquote><p>图示</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family con tains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3, t5, and t6" class="fancybox"><img alt="A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family con tains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3, t5, and t6" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210517101919.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family con tains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3, t5, and t6"></a></p><p>​        A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family contains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3, t5, and t6（一个存储Web网页的例子的表的片断。行名是一个反向URL。contents列族存放的是网页的内容，anchor列族存放引用该网页的锚链接文本。CNN的主页被Sports Illustrater和MY-look的主页引用，因此该行包含了名为“anchor:cnnsi.com”和 “anchhor:my.look.ca”的列。每个锚链接只有一个版本（注意时间戳标识了列的版本，t9和t8分别标识了两个锚链接的版本）；而contents列则有三个版本，分别由时间戳t3，t5，和t6标识。）</p><p>​        这样做的好处，将相同的key聚合到一块，相当于把相同key的数据放到一起，这是一种nosql数据库经典的做法，因此很多的nosql天然的不支持join操作。</p><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>​        表中的行关键字可以是任意的字符串。对同一个行关键字的读或者写操作都是原子的（不管读或者写这一行里多少个不同列），这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p><p>​        Bigtable通过行关键字的字典顺序来组织数据。表中的每个行都可以动态分区。每个分区叫做一个”Tablet”，Tablet是数据分布和负载均衡调整的最小单位。这样做的结果是，当操作只读取行中很少几列的数据时效率很高，通常只需要很少几次机器间的通信即可完成。用户可以通过选择合适的行关键字，在数据访问时有效利用数据的位置相关性，从而更好的利用这个特性。举例来说，在Webtable里，通过反转URL中主机名的方式，可以把同一个域名下的网页聚集起来组织成连续的行。具体来说，我们可以把maps.google.com/index.html的数据存放在关键字com.google.maps/index.html下。把相同的域中的网页存储在连续的区域可以让基于主机和域名的分析更加有效。</p><h2 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h2><p>​        列族是Bigtable中访问控制的基本单元，也就是说，访问权限的设置是在列族这一级别上进行的。</p><p>​        列关键字的命名语法如下：列族：限定词。比如，Webtable有个列族language，language列族用来存放撰写网页的语言。我们在language列族中只使用一个列关键字，用来存放每个网页的语言标识ID。</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>​        在Bigtable中，表的每一个数据项都可以包含同一份数据的不同版本；不同版本的数据通过时间戳来索引。</p><p>​        在Webtable的举例里，contents:列存储的时间戳信息是网络爬虫抓取一个页面的时间。</p><h1 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h1><h2 id="BigTable构件"><a href="#BigTable构件" class="headerlink" title="BigTable构件"></a>BigTable构件</h2><ul><li><p>BigTable使用Google的分布式文件系统(GFS)存储日志文件和数据文件。</p></li><li><p>BigTable内部存储数据的文件是Google SSTable格式的。SSTable是一个持久化的、排序的、不可更改的Map结构，而Map是一个key-value映射的数据结构，key和value的值都是任意的Byte串。</p></li><li><p>BigTable还依赖一个高可用的、序列化的分布式锁服务组件，叫做Chubby。Chubby 是一个分布式锁服务，底层的核心算法为 Paxos。</p></li></ul><h2 id="Tablet位置"><a href="#Tablet位置" class="headerlink" title="Tablet位置"></a>Tablet位置</h2><p>​        我们使用一个三层的、类似Ｂ+树的结构存储Tablet的位置信息。</p><p>​        Bigtable 包含三种类型的表格：用户表、元数据表和根表。其中，用户表存储用户实际数据；元数据表存储用户表的元数据；如子表位置信息、Sstable 及操作日志文件编号、日志回放点等，根表用来存储元数据表的元数据；根表的元数据，也就是根表的位置信息，又称为 Bigtable 引导信息，存放在 Chubby 系统中</p><p>​        METADATA的每一行都存储了大约1KB的内存数据。在一个大小适中的、容量限制为128MB的METADATA Tablet中，采用这种三层结构的存储模式，可以标识2^34个Tablet的地址（如果每个Tablet存储128MB数据，那么一共可以存储2^61字节数据）。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210517165319.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="Tablet分配"><a href="#Tablet分配" class="headerlink" title="Tablet分配"></a>Tablet分配</h2><p>在任何一个时刻，一个Tablet只能分配给一个Tablet服务器。Master服务器记录了当前有哪些活跃的Tablet服务器、哪些Tablet分配给了哪些Tablet服务器、哪些Tablet还没有被分配。当一个Tablet还没有被分配、并且刚好有一个Tablet服务器有足够的空闲空间装载该Tablet时，Master服务器会给这个Tablet服务器发送一个装载请求，把Tablet分配给这个服务器。</p><p>BigTable使用Chubby跟踪记录Tablet服务器的状态。当一个Tablet服务器启动时，它在Chubby的一个指定目录下建立一个有唯一性名字的文件，并且获取该文件的独占锁。</p><h2 id="Tablet服务"><a href="#Tablet服务" class="headerlink" title="Tablet服务"></a>Tablet服务</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210517194245.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中。在这些更新操作中，最近提交的那些存放在一个排序的缓存中，我们称这个缓存为 memtable；较早的更新存放在一系列SSTable 中。</p><p>随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个门限值的时候，这个 memtable就会被冻结，然后创建一个新的 memtable；被冻结住 memtable 会被转换成 SSTable，然后写入GFS。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>上述各种操作已经可以实现Bigtable的所有功能了，但是这些基本的功能很多时候并不是很符合用户的使用习惯，或者执行的效率较低。有些功能Bigtable自身已经进行了优化，包括使用缓存、共享式的提交日志以及利用系统的不变性。除此之外，Bigtable还允许用户个人在基本操作基础上对系统进行一些优化。</p><h2 id="局部性群组"><a href="#局部性群组" class="headerlink" title="局部性群组"></a>局部性群组</h2><p>​        Bigtable允许用户将原本并不存储在一起的数据以列族为单位，根据需要组织在一个单独的SSTable中，以构成一个局部性群组。这实际上就是数据库中垂直分区技术的一个应用。结合数据模型图来看，在被Bigtable保存的网页列关键字中，有的用户可能只对网页内容感兴趣，那么它可以通过设置局部性群组只看内容这一列。有的则会对诸如网页语言、网站排名等可以用于分析的信息比较感兴趣，他也可以将这些列设置到一个群组中。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210517201038.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>通过设置局部性群组用户可以只看自己感兴趣的内容，对某个用户来说的大量无用信息无须读取。对于一些较小的且会被经常读取的局部性群组，用户可以将其SSTable文件直接加载进内存，这可以明显地改善读取效率。</p><h3 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h3><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p><blockquote><p>适用场景和优点</p></blockquote><p>（1）如果一个表中某些列常用，另外一些列不常用</p><p>（2）可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>Bigtable向用户提供了一种称为布隆过滤器的工具。布隆过滤器实际上它是一个很长的二进制向量和一系列随机映射函数，在读操作中确定子表的位置时非常有用。布隆过滤器的速度快，省空间。而且它有一个最大的好处是它绝不会将一个存在的子表判定为不存在。不过布隆过滤器也有一个缺点，那就是在某些情况下它会将不存在的子表判断为存在。不过这种情况出现的概率非常小，跟它带来的巨大好处相比这个缺点是可以忍受的。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>目前包括Google Analytics、Google Earth、个性化搜索在内的几十个项目都使用了Bigtable。这些应用对Bigtable的要求以及使用的集群机器数量都是各不相同的，但是从实际运行来看，Bigtable完全可以满足这些不同需求的应用，而这一切都得益于其优良的构架以及恰当的技术选择。与此同时Google还在不断地对Bigtable进行一系列的改进，通过技术改良和新特性的加入提高系统运行效率及稳定性。</p></body></html>]]></content>
    
    <summary type="html">
    
      May I love you!
    
    </summary>
    
    
      <category term="论文简述" scheme="http://raptor1998.top/categories/%E8%AE%BA%E6%96%87%E7%AE%80%E8%BF%B0/"/>
    
    
      <category term="BigTable" scheme="http://raptor1998.top/tags/BigTable/"/>
    
  </entry>
  
  <entry>
    <title>mybatis-plus</title>
    <link href="http://raptor1998.top/2021/04/20/mybatis-plus/"/>
    <id>http://raptor1998.top/2021/04/20/mybatis-plus/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-07-14T02:55:45.321Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><h2 id="插件原理（未完）"><a href="#插件原理（未完）" class="headerlink" title="插件原理（未完）"></a>插件原理（未完）</h2><p>执行器Executor、参数处理器ParameterHandler、结果集处理器ResultSetHandler、SQL语法构建器StatementHandler四大对象创建的时候，不是直接返回的，而是<strong>InterceptorChain.pluginAll（）拦截；然后获取到所有的InterceptorChain（拦截器）（插件需要实现的接口），调用pluginAll(Object target)；返回target包装后的对象</strong>，插件机制，我们可以为目标对象创建一个代理对象，AOP</p><p><code>创建动态代理的时候，是按照插件配置顺序创建层层代理对象。执行目标方法的之后，按照逆向顺序执行</code></p><h2 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、编写Interceptor的实现类</span></span><br><span class="line"><span class="comment">    2、使用@Intercepts注解完成插件签名</span></span><br><span class="line"><span class="comment">    3、将写好的插件注册到全局配置文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    完成插件签名：</span></span><br><span class="line"><span class="comment">        告诉mybatis当前插件用来拦截那个对象的那个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts</span>({</span><br><span class="line">        <span class="meta">@Signature</span>(type = StatementHandler<span class="class">.<span class="keyword">class</span>,<span class="title">method</span> </span>= <span class="string">"parameterize"</span>,args = java.sql.Statement<span class="class">.<span class="keyword">class</span> )</span></span><br><span class="line"><span class="class">})</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PluginDemo</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拦截目标对象的执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"PluginDemo intercept-------"</span>+invocation.getMethod());</span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        MetaObject metaObject = SystemMetaObject.forObject(target);</span><br><span class="line">        Object value = metaObject.getValue(<span class="string">"parameterHandler.parameterObject"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"疏忽转"</span>);</span><br><span class="line">        map.put(<span class="string">"id"</span>,<span class="number">3</span>);</span><br><span class="line">        metaObject.setValue(<span class="string">"parameterHandler.parameterObject"</span>,map);</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        <span class="comment">//返回执行后的返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        包装目标对象，为目标创建一个代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"PluginDemo plugin-----"</span>+target);</span><br><span class="line">        <span class="comment">//可以借助Plugin.wrap方法来使用当前Interceptor包装我们目标对象</span></span><br><span class="line">        Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//返回为当前target创建的动态代理</span></span><br><span class="line">        <span class="keyword">return</span> wrap;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将插件注册时的properties属性设置进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"插件配置信息："</span>+properties);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.hdu.plugin.PluginDemo"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="Mybatis拓展"><a href="#Mybatis拓展" class="headerlink" title="Mybatis拓展"></a>Mybatis拓展</h1><ol><li><p>PageHelper插件进行分页</p></li><li><p>批量操作</p></li><li><p>存储过程</p></li><li><p>typeHandler处理枚举</p></li></ol><h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><p><a href="https://mp.baomidou.com/" target="_blank" rel="noopener">官方文档</a></p><h1 id="spring-MP-HelloWorld"><a href="#spring-MP-HelloWorld" class="headerlink" title="spring-MP-HelloWorld"></a>spring-MP-HelloWorld</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;3.5.0&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;2.0.6&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--log4j2日志依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--log4j2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用于slf4j与log4j2桥接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--commons-logging与log4j2桥接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config,xml"></a>mybatis-config,xml</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;settings&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="lazyLoadingEnabled" value="true"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="aggressiveLazyLoading" value="false"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="cacheEnabled" value="true"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/settings&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;environments default="development"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;environment id="development"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;transactionManager type="JDBC"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;dataSource type="POOLED"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="driver" value="${jdbc.driverClassName}"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="url" value="${jdbc.url}"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="username" value="${jdbc.username}"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name="password" value="${jdbc.password}"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/dataSource&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/environment&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/environments&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;mappers&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource="mapping/BookMapper.xml"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/mappers&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"NULL"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="spring-config-xml"><a href="#spring-config-xml" class="headerlink" title="spring-config,xml"></a>spring-config,xml</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mybatis-spring</span>=<span class="string">"http://mybatis.org/schema/mybatis-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.hdu"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库连接池配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driverClassName}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring事务管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启基于注解的事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis   org.mybatis.spring.SqlSessionFactoryBean  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatisPlus   com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建出SqlSessionFactory对象  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configLocation指定全局配置文件的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mapperLocations: 指定mapper文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"mapping/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalConfig"</span> <span class="attr">ref</span>=<span class="string">"globalConfig"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  MP全局配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalConfig"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.core.config.GlobalConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dbConfig"</span> <span class="attr">ref</span>=<span class="string">"dbConfig"</span>/&gt;</span> <span class="comment">&lt;!--  非必须  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dbConfig"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idType"</span> <span class="attr">value</span>=<span class="string">"AUTO"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置一个可以进行批量执行的sqlSession  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"executorType"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring:scan</span> <span class="attr">base-package</span>=<span class="string">"com.hdu.mapper"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Student</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Test"><a href="#Test" class="headerlink" title="@Test"></a>@Test</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">context3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-config.xml"</span>);</span><br><span class="line">    StudentMapper studentMapper = context.getBean(<span class="string">"studentMapper"</span>, StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Student student = studentMapper.selectById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://github.com/Raptor1998/java_demo" target="_blank" rel="noopener">https://github.com/Raptor1998/java_demo</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="http://raptor1998.top/2021/04/06/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://raptor1998.top/2021/04/06/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-05T16:00:00.000Z</published>
    <updated>2021-04-17T10:33:06.926Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>添加mysql组和用户</strong></p><ul><li>npm</li></ul><p><a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a><br><a href="https://blog.csdn.net/liumm0000/article/details/18841197" target="_blank" rel="noopener">https://blog.csdn.net/liumm0000/article/details/18841197</a></p><ul><li>tar</li></ul><p><a href="https://repo.huaweicloud.com/mysql/Downloads/MySQL-5.7/" target="_blank" rel="noopener">https://repo.huaweicloud.com/mysql/Downloads/MySQL-5.7/</a><br><a href="https://blog.csdn.net/z13615480737/article/details/80019881" target="_blank" rel="noopener">https://blog.csdn.net/z13615480737/article/details/80019881</a></p><h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><p><a href="https://blog.csdn.net/wangfeijiu/article/details/112454405" target="_blank" rel="noopener">https://blog.csdn.net/wangfeijiu/article/details/112454405</a></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>show engines;</strong></p><p><strong>show variables like “%storange_engine%”;</strong></p><h2 id="MyISAM和InnoDB对比"><a href="#MyISAM和InnoDB对比" class="headerlink" title="MyISAM和InnoDB对比"></a>MyISAM和InnoDB对比</h2><table><thead><tr><th>对比</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁定某一行，不对其他行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存的要求较高，而且内存大小对性能有决定性影响</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr></tbody></table><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p><a href="https://blog.csdn.net/wangfeijiu/article/details/113409719" target="_blank" rel="noopener">一文搞懂MySQL索引（清晰明了）</a></p><h2 id="sql-joins"><a href="#sql-joins" class="headerlink" title="sql joins"></a>sql joins</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="SQL JOINS" class="fancybox"><img alt="SQL JOINS" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210406091949.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="SQL JOINS"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">WHERE</span> B.Key <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">WHERE</span> A.Key <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">WHERE</span> A.Key <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> B.Key <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">WHERE</span> B.Key <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line">UNION</span><br><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; <span class="keyword">FROM</span> TableA A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> TableB B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">WHERE</span> A.Key <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure></div><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>索引是帮助MySQL高效获取数据的数据结构</p><p><strong>索引是排好序的快速查找数据结构</strong></p><p><strong>索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！</strong></p><p><strong>除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</strong></p><p>我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</p><h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本降低了cpu的消耗</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占空间的</li><li>虽然索引极大地提高了查询速度，却同时会降低更新表的速度，如对表进行insert，update和delete。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引的字段，都会调整因为更新所带来的的键值变化后的索引信息</li><li>索引知识提高效率的一个因素，如果你的MySQL有大量数据量的表，就需要花时间去研究建立最优秀的索引，或优化查询</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><p>即一个索引只包含单个列，一个表可以有多个单列索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列的值必须唯一，但允许为空</p><h3 id="符合索引"><a href="#符合索引" class="headerlink" title="符合索引"></a>符合索引</h3><p>即一个索引包含多个列</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本语法 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、创建索引 [UNIQUE]可以省略*/</span></span><br><span class="line"><span class="comment">/* 如果只写一个字段就是单值索引，写多个字段就是复合索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> tabName(columnName(<span class="keyword">length</span>));</span><br><span class="line"><span class="comment">/* alter创建 */</span></span><br><span class="line"><span class="keyword">ALTER</span> tabName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> (columnName(<span class="keyword">length</span>))  </span><br><span class="line"><span class="comment">/* 2、删除索引 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> tabName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、查看索引 */</span></span><br><span class="line"><span class="comment">/* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 */</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> tabName \G;</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次) */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> indexName(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、该语句创建普通索引，索引值可以出现多次 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> <span class="keyword">INDEX</span> indexName(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、该语句指定了索引为FULLTEXT，用于全文检索 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabName <span class="keyword">ADD</span> FULLTEXT indexName(column_list);</span><br></pre></td></tr></tbody></table></figure></div><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="深入理解MySQL索引底层原理"><a href="#深入理解MySQL索引底层原理" class="headerlink" title="深入理解MySQL索引底层原理"></a>深入理解MySQL索引底层原理</h3><p><a href="https://zhuanlan.zhihu.com/p/113917726" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113917726</a></p><h2 id="索引创建准则"><a href="#索引创建准则" class="headerlink" title="索引创建准则"></a>索引创建准则</h2><ul><li>主键自动创建唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引： 因为每次更新不单单是更新了记录还会更新索引</li><li>where条件用不到的字段不创建索引</li><li>查询中排序的字段，排序的字段若是通过索引去访问将大大提高排序速度</li><li>查询中统计或分组字段</li></ul><p><strong>不适合创建：</strong></p><ul><li><p>表记录太少</p></li><li><p>集成增删改的表</p></li><li><p>数据重复且分布平均的字段</p><p>索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</p></li></ul><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><h2 id="常见瓶颈"><a href="#常见瓶颈" class="headerlink" title="常见瓶颈"></a>常见瓶颈</h2><ul><li>CPU：Cpu在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态</li></ul><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p><ul><li><code>id</code>：表的读取顺序。小标驱动大表</li><li><code>select_type</code>：数据读取操作的操作类型。</li><li><code>possible_keys</code>：哪些索引可以使用。</li><li><code>key</code>：哪些索引被实际使用。</li><li><code>ref</code>：表之间的引用。</li><li><code>rows</code>：每张表有多少行被优化器查询。</li></ul><ol><li><p>id </p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul></li><li><p>select_type</p><ul><li><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION</code>。</li><li><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</li><li><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</li><li><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</li><li><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</li><li><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</li></ul></li><li><p>table   </p><p>数据是关于那张表的</p></li><li><p>type</p><p><strong>访问类型排列</strong><br><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code></p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code></p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</li><li><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</li><li><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code>const</code> 类型之外, 这是最好的联接类型。</li><li><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</li><li><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></li><li><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</li></ul></li><li><p>possible_keys  </p><p>  显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则改索引将被列出，但不一定被查询实际使用</p></li><li><p>key  </p><p>  实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则改索引进出现在key列表中</p></li><li><p>key_len </p><p>  表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好</p><p>  key_len显示的值为索引字段的最大可能长度，并非实际长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p></li><li><p>ref   </p><p>  显示索引的那一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p></li><li><p>rows </p><p>  根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p></li><li><p>Extra</p><p> 包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><strong><code>Using filesort</code></strong>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></li><li><strong><code>Using temporary</code></strong>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></li><li><strong><code>Using index</code></strong>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</li><li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。<ul><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul></li></ul></li></ol><h2 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`article`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`author_id`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`category_id`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> , </span><br><span class="line"><span class="string">`views`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> , </span><br><span class="line"><span class="string">`comments`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`title`</span> VARBINARY(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></div><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>查询<code>category_id</code>为1且<code>comments</code>大于1的情况下，<code>views</code>最多的<code>article_id</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="demo" class="fancybox"><img alt="demo" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210407101805.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="demo"></a></p><p>当<code>comments &gt; 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就用不上，但是当<code>comments = 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就可以用。<strong>所以，范围之后的索引会失效。</strong></p><h2 id="双表"><a href="#双表" class="headerlink" title="双表"></a>双表</h2><h3 id="表-1"><a href="#表-1" class="headerlink" title="表"></a>表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`class`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`card`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`book`</span>(</span><br><span class="line"><span class="string">`bookid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`card`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">class</span>(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br></pre></td></tr></tbody></table></figure></div><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210407151937.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>可以看到在右表创建索引后，type变为了red，rows也优化了</p><p><strong>这是由左连接的特性决定的，left join 条件用于确定如何从右表搜索行，左边一定都有左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。</strong></p><h2 id="三表"><a href="#三表" class="headerlink" title="三表"></a>三表</h2><h3 id="表-2"><a href="#表-2" class="headerlink" title="表"></a>表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`phone`</span>(</span><br><span class="line"><span class="string">`phoneid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`card`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> phone(card)<span class="keyword">VALUES</span>(<span class="keyword">FLOOR</span>(<span class="number">1</span>+(<span class="keyword">RAND</span>()*<span class="number">20</span>)));</span><br></pre></td></tr></tbody></table></figure></div><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210407153744.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><strong>尽可能减少join语句中的NestedLoop（嵌套循环）的循环次数</strong></p><p><strong>永远用小结果集驱动大的结果集</strong></p><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul><li><p>全值匹配</p></li><li><p>最佳左前缀法则。</p></li><li><p>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</p></li><li><p>索引中范围条件右边的字段会全部失效。</p></li><li><p>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</p></li><li><p>MySQL在使用<code>!=</code>或者<code>&lt;&gt;</code>的时候无法使用索引会导致全表扫描。</p></li><li><p><code>is null</code>、<code>is not null</code>也无法使用索引。</p></li><li><p><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</p><p>如何解决两边%索引失效     <strong>覆盖索引</strong> ？？？</p></li><li><p>字符串不加单引号索引失效。</p></li><li><p>少用<code>or</code>，用它来连接时会索引失效。</p></li></ul><h3 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h3><p><strong>最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。</strong></p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>假设index(a,b,c)</p><table><thead><tr><th>where</th><th>索引是否被引用</th></tr></thead><tbody><tr><td>where a = 3</td><td>Y,使用到a</td></tr><tr><td>where a= 2 and b= 5</td><td>Y,使用到a,b</td></tr><tr><td>where a= 2 and b= 5 and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where a= 2 或者 b= 5 and c=4 或者 where c=4</td><td>N</td></tr><tr><td>where a= 3 and c= 5</td><td>使用a，但无法使用c，b断了</td></tr><tr><td>where a= 2 and b &gt; 5 and c= 5</td><td>使用到a和b，c不能在用在范围之后，b断了</td></tr><tr><td>where a= 2 and b like  “kk%” and c = 4</td><td>Y,使用到a，b，c</td></tr><tr><td>where a= 2 and b like  “%kk” and c = 4</td><td>Y,使用到a</td></tr><tr><td>where a= 2 and b like  “%kk%” and c = 4</td><td>Y,使用到a</td></tr><tr><td>where a= 2 and b like  “k%kk%” and c = 4</td><td>Y,使用到a，b，c</td></tr></tbody></table><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_test_c1234 <span class="keyword">ON</span> <span class="string">`test`</span>(<span class="string">`c1`</span>,<span class="string">`c2`</span>,<span class="string">`c3`</span>,<span class="string">`c4`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.全值匹配*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c3`</span> = <span class="string">'a3'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span> <span class="keyword">AND</span> <span class="string">`c3`</span> = <span class="string">'a3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c4`</span> = <span class="string">'a4'</span> <span class="keyword">AND</span> <span class="string">`c3`</span> = <span class="string">'a3'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c1`</span> = <span class="string">'a1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c3`</span> &gt; <span class="string">'a3'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> &gt; <span class="string">'a4'</span> <span class="keyword">AND</span> <span class="string">`c3`</span> = <span class="string">'a3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找,  c3字段用于排序了但是没有统计到key_len中，c4字段失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`c3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`c3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`c4`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c5`</span> = <span class="string">'a5'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`c2`</span>, <span class="string">`c3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c5`</span> = <span class="string">'a5'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`c3`</span>, <span class="string">`c2`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span>  <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span>  <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c5`</span> = <span class="string">'a5'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort </span></span><br><span class="line"><span class="comment">   因为之前c2这个字段已经确定了是'a2'了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！</span></span><br><span class="line"><span class="comment">   所以没有产生Using filesort 和(10)对比</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c2`</span> = <span class="string">'a2'</span> <span class="keyword">AND</span> <span class="string">`c5`</span> = <span class="string">'a5'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c3, c2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GROUP BY 表面上是叫做分组，但是分组之前必排序。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`c2`</span>,<span class="string">`c3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort Using temporary */</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`c1`</span> = <span class="string">'a1'</span> <span class="keyword">AND</span> <span class="string">`c4`</span> = <span class="string">'a4'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`c3`</span>,<span class="string">`c2`</span>;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>定值、范围还是排序，一般order by 是给个范围，group by 基本上都需要进行排序，会有临时表产生</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于单值索引，尽量选择昂前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段排序中，位置越靠前越好</li><li>在选择组合索引的时候，尽量选择可以能够包含单签query中的where字句中更多的字段的索引</li><li>尽可能的通过分析统计信息和调整query的写法来达到选择合适索引的目的</li></ul><h1 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h1><p><strong>如何分析慢SQL</strong></p><p>观察，至少跑一段时间，查看生产的慢SQL情况<code>--&gt;</code>开启慢查询日志，设置阈值，比如超过5秒的就是慢SQL，将其抓取<code>--&gt;</code>explain+慢SQL分析<code>--&gt;</code>show profile<code>--&gt;</code>运维或者DBA进行sql数据库服务器的参数调优</p><p><strong>总结</strong></p><p>慢查询的开启并捕获<code>--&gt;</code>explain+慢SQL分析<code>--&gt;</code>show profile 查询在MySQL服务器里面执行细节和生命周期情况<code>--&gt;</code>SQL数据库服务器的参数调优</p><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="小数据集驱动大数据集"><a href="#小数据集驱动大数据集" class="headerlink" title="小数据集驱动大数据集"></a>小数据集驱动大数据集</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以理解为建立5次连接，每次查询1000次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以理解为建立1000次连接，每次查询5次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`A`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`B`</span>)</span><br><span class="line">等价于： </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id = B.id</span><br><span class="line">当B表的数据集小于A的数据集时，用<span class="keyword">in</span>优于<span class="keyword">exists</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`A`</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> <span class="string">`B`</span> <span class="keyword">WHERE</span> <span class="string">`B`</span>.id = <span class="string">`A`</span>.id);</span><br><span class="line">等价于：</span><br><span class="line">for <span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> A.id = B.id</span><br><span class="line">当A表的数据集小于B的数据集时，用<span class="keyword">exists</span>优于<span class="keyword">in</span></span><br></pre></td></tr></tbody></table></figure></div><ul><li><code>EXISTS(subquery)</code>子查询只返回<code>true</code>或者<code>false</code>，因此子查询中的<code>SELECT *</code>可以是<code>SELECT 1 OR SELECT X</code>，它们并没有区别。</li><li><code>EXISTS(subquery)</code>子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</li><li><code>EXISTS(subquery)</code>子查询往往也可以用条件表达式，其他子查询或者<code>JOIN</code>替代，何种最优需要具体问题具体分析。</li></ul><h3 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h3><p><strong>提高ORDER BY排序的速度：</strong></p><ul><li><code>ORDER BY</code>时使用<code>SELECT *</code>是大忌，查什么字段就写什么字段，这点非常重要。在这里的影响是：<ul><li>当查询的字段大小总和小于<code>max_length_for_sort_data</code>而且排序字段不是<code>TEXT|BLOB</code>类型时，会使用单路排序算法，否则使用多路排序算法。</li><li>两种排序算法的数据都有可能超出<code>sort_buffer</code>缓冲区的容量，超出之后，会创建<code>tmp</code>临时文件进行合并排序，导致多次IO，但是单路排序算法的风险会更大一些，所以要增大<code>sort_buffer_size</code>参数的设置。</li></ul></li><li>尝试提高<code>sort_buffer_size</code>：不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</li><li>尝试提高<code>max_length_for_sort_data</code>：提高这个参数，会增加用单路排序算法的概率。但是如果设置的太高，数据总容量<code>sort_buffer_size</code>的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。</li></ul><p><strong>KEY a_b_c(a,b,c)</strong></p><p><strong>order by 能使用所用最左前缀</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- order by a </span><br><span class="line">- order by a,b</span><br><span class="line">- order by a,b,c </span><br><span class="line">- order by a desc,b desc,c desc</span><br></pre></td></tr></tbody></table></figure></div><p><strong>如果where使用索引的最左前缀定义为常量，则order by能使用索引</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- where a = const order by b,c</span><br><span class="line">- where a = const and b = const order by c</span><br><span class="line">- where a = const and b &gt; const order by b,c</span><br></pre></td></tr></tbody></table></figure></div><p><strong>不能使用索引进行排序</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- order by a ASC,b DESC, c DESC <span class="comment">/*排序不一致*/</span></span><br><span class="line">- where g = const order by b,c <span class="comment">/*丢失索引a*/</span></span><br><span class="line">- where a = const order by c <span class="comment">/*丢失索引b*/</span></span><br><span class="line">- where a = const order by a,d <span class="comment">/*d不是索部分*/</span></span><br><span class="line">- where a in (...) order by b,c <span class="comment">/*对于排序来说，多个相等条件也是范围查询*/</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="group-by关键字优化"><a href="#group-by关键字优化" class="headerlink" title="group by关键字优化"></a>group by关键字优化</h3><ul><li><code>GROUP BY</code>实质是先排序后进行分组，遵照索引建的最佳左前缀。</li><li>当无法使用索引列时，会使用<code>Using filesort</code>进行排序，增大<code>max_length_for_sort_data</code>参数的设置和增大<code>sort_buffer_size</code>参数的设置，会提高性能。</li><li><code>WHERE</code>执行顺序高于<code>HAVING</code>，能写在<code>WHERE</code>限定条件里的就不要写在<code>HAVING</code>中了。</li></ul><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>​        MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过<code>long_query_time</code>的SQL，则会被记录到慢查询日志中。<code>long_query_time</code>的默认值为10，意思是运行10秒以上的语句。</p><p><strong>默认情况下慢查询日志是关闭的，如果不是调优需要的话，一般不建议启动该参数</strong>，开启会带来一定的性能影响</p><p><strong>show variables like “%slow_query_log%”;</strong></p><p>当前数据库有效，重启后失效</p><p><strong>set global slow_query_log = 1;</strong></p><p>慢查询时间，等于不会被记录</p><p><strong>show variables like “long_query_time%”;</strong></p><p>设置阈值为三秒</p><p><strong>set global long_query_time = 3;</strong></p><p>慢sql记录条数</p><p><strong>show global status like “%Slow_queries%”;</strong></p><h3 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more</span><br></pre></td></tr></tbody></table></figure></div><h2 id="批量数据插入"><a href="#批量数据插入" class="headerlink" title="批量数据插入"></a>批量数据插入</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 产生随机字符串</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> chars_str <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'abcdefghijklmnopqrstuvwsyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str = <span class="keyword">CONCAT</span>(return_str,<span class="keyword">SUBSTRING</span>(chars_str,<span class="keyword">FLOOR</span>(<span class="number">1</span>+<span class="keyword">RAND</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    RETURN return_str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机部门编号</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num() <span class="keyword">RETURNS</span> <span class="built_in">INT</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i = <span class="keyword">FLOOR</span>(<span class="number">100</span> + <span class="keyword">RAND</span>() * <span class="number">10</span>);</span><br><span class="line">    RETURN i;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></tbody></table></figure></div><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_dept(<span class="keyword">IN</span> <span class="keyword">START</span> <span class="built_in">INT</span>(<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="built_in">INT</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept(deptno,dname,loc) <span class="keyword">VALUES</span>((<span class="keyword">START</span> + i),rand_string(<span class="number">10</span>),rand_string(<span class="number">8</span>));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_emp(<span class="keyword">IN</span> <span class="keyword">START</span> <span class="built_in">INT</span>(<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="built_in">INT</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(empno,ename,job,mgr,hiredata,sal,comm,deptno) <span class="keyword">VALUES</span>((<span class="keyword">START</span> + i),rand_string(<span class="number">6</span>),<span class="string">'SALESMAN'</span>,<span class="number">0001</span>,<span class="keyword">CURDATE</span>(),<span class="number">2000</span>,<span class="number">400</span>,rand_num());</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></tbody></table></figure></div><h3 id="录入"><a href="#录入" class="headerlink" title="录入"></a>录入</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100001</span>,<span class="number">500000</span>);</span><br></pre></td></tr></tbody></table></figure></div><h2 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h2><p>是MySQL提供可以用来分析当前会话语句的执行的资源消耗情况。可以用于SQL的调优的测量</p><p>默认情况下是关闭的，并保存15次的运行结果</p><p><strong>SHOW VARIABLES LIKE ‘profiling’;</strong></p><p>开启</p><p><strong>SET profiling=ON;</strong></p><p>查看最近执行的slq</p><p><strong>SHOW PROFILES;</strong></p><p>诊断sql</p><p><strong>SHOW PROFILE cpu,block io FOR QUERY Query_ID;</strong></p><p><code>Show Profile</code>查询参数备注：</p><ul><li><code>ALL</code>：显示所有的开销信息。</li><li><code>BLOCK IO</code>：显示块IO相关开销（通用）。</li><li><code>CONTEXT SWITCHES</code>：上下文切换相关开销。</li><li><code>CPU</code>：显示CPU相关开销信息（通用）。</li><li><code>IPC</code>：显示发送和接收相关开销信息。</li><li><code>MEMORY</code>：显示内存相关开销信息。</li><li><code>PAGE FAULTS</code>：显示页面错误相关开销信息。</li><li><code>SOURCE</code>：显示和Source_function。</li><li><code>SWAPS</code>：显示交换次数相关开销的信息。</li></ul><p><code>Show Profile</code>查询列表，日常开发需要注意的结论：</p><ul><li><code>converting HEAP to MyISAM</code>：查询结果太大，内存都不够用了，往磁盘上搬了。</li><li><code>Creating tmp table</code>：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。</li><li><code>Copying to tmp table on disk</code>：把内存中的临时表复制到磁盘，危险！！！</li><li><code>locked</code>：死锁。</li></ul><h2 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h2><p><strong>不可在生产环境使用</strong></p><p><strong>set global general_log = 1;</strong></p><p><strong>set global log_output = “table”;</strong></p><p><strong>select * from mysql.log_output;</strong></p><h1 id="锁理论概述"><a href="#锁理论概述" class="headerlink" title="锁理论概述"></a>锁理论概述</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>从对数据操作的类型（读、写）</p><ul><li>读锁（共享锁）： 针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前写操作没有完成之前，它会阻断其他写锁和读锁</li></ul></li><li><p>从对数据操作的粒度</p><ul><li>表锁</li><li>行锁</li></ul></li></ul><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>偏向myISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生所冲突的概率最高，并发度最低</p><h3 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409091515.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="写锁案例"><a href="#写锁案例" class="headerlink" title="写锁案例"></a>写锁案例</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409092350.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>MyISAM在执行<code>select</code>前，会自动给涉及到的所有的表加<code>读锁</code>，在执行增删改操作之前，会自动给涉及到的表加<code>写锁</code></p><p>MySQL的表级锁两种模式：</p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ul><table><thead><tr><th>锁类型</th><th>可否兼容</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>是</td><td>否</td></tr><tr><td>写锁</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><ul><li>对于MyISAM表的读操作（加读锁），不会阻塞其他进程对同一张表的读请求，但会阻塞对同一张表的学请求。只有当读锁释放后，才会执行凄然进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当前写锁释放后，才会执行其他进程的读写操作。</li></ul><h3 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h3><p><strong>SHOW STATUS LIKE ‘table%’;</strong></p><p>可以通过<code>Table_locks_immediate</code>和<code>Table_locks_waited</code>状态变量来分析系统上的表锁定。具体说明如下：</p><p><code>Table_locks_immediate</code>：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1。</p><p><code>Table_locks_waited</code>：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在较严重的表级锁争用情况。</p><p><strong><code>MyISAM</code>的读写锁调度是写优先，这也是<code>MyISAM</code>不适合做写为主表的引擎。因为写锁后，其他线程不能进行任何操作，大量的写操作会使查询很难得到锁，从而造成永远阻塞。</strong></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><p>偏向于InnoDB引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高。</p></li><li><p>InnoDB与MyISAM的最大不同有两点：一是支出事务</p><p>（TRANSACTION）；二是采用了行级锁</p></li></ul><h3 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h3><h4 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h4><blockquote><p>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行</p></blockquote><blockquote><p>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态，这意味着所有的数据规则都必须应用于事务的修改，以保持数据的完整新；事物结束时，所有的内部数据结构（如B树索引或双向链表）也都是必须正确的。 </p></blockquote><blockquote><p>隔离性（Lsolation）：数据库系统提供的一套隔离机制，保证事务在不受外部并发操作的影响的“独立”环境执行，这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p></blockquote><blockquote><p>持久性（Durable）：事务完成之后，他对于数据的修改时永久性的，计时出现系统故障也能够保持。</p></blockquote><h4 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h4><ul><li><p>更新丢失（Lost update）</p><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题―—最后的更新覆盖了由其他事务所做的更新。</p><p>例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。</p><p>如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</p></li><li><p>脏读（Dirty Reads）</p><p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态;这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</p><p>一句话:事务A读取到了事务B玊修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p></li><li><p>不可重复读（Non-Repeatable Reads）</p><p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”。</p><p>一句话:事务A读取到了事务B已经提交的修改数据，不符合隔离性</p></li><li><p>幻毒（Phantom Reads）</p><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读“</p><p>一句话:事务A读取到了事务B体提交的新增数据，不符合隔离性。</p><p><strong>幻读和脏读有点类似，脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。</strong></p></li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>“脏读”、“不可重复读”、“幻读”，其实都是数据读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读（Read committed）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（Repeatable read）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化（Serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离本质实际上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务合理程度的要求也是不一样的，比如许多应用对“不可重复读”、”幻读“并不敏感，可能更关心数据并发访问的能力。</p><p><strong>查看数据库事务隔离级别：</strong></p><p><strong>show variables like “tx_isolation”;</strong></p><h3 id="行锁案例"><a href="#行锁案例" class="headerlink" title="行锁案例"></a>行锁案例</h3><p>改为手动提交</p><p><strong>SET autocommit=0;</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409154417.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>操作同一数据和不同数据</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409155102.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="索引失效行锁升级为表锁"><a href="#索引失效行锁升级为表锁" class="headerlink" title="索引失效行锁升级为表锁"></a>索引失效行锁升级为表锁</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409160218.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h3><p><strong>SHOW STATUS LIKE ‘innodb_row_lock%’;</strong></p><ul><li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量。</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度（重要）。</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花的平均时间（重要）。</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间。</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（重要）。</li></ul><h3 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409160836.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>当我们使用范围条件而不是相等条件检索数据，并请求共享或者排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”</p><p>InnoDB也会对这个间隙加锁，这种随机值就是所谓的间隙锁（Next-key锁）</p><p><strong>因为query执行过程中通过范围查找的话，它会锁定整个范围内所有的索引键值，即使这个键值不存在。</strong></p><p><strong>间隙锁有一个比较致命的缺点，即使某些不存在的键值也会被无辜锁定，二造成锁定的时候无法插入锁定范围内的任何数据。在某些场景下这可能对性能造成很大的危害</strong></p><h3 id="锁定一行"><a href="#锁定一行" class="headerlink" title="锁定一行"></a>锁定一行</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409172611.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>select …..  for update 锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交commit</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现昂面所带来的的性能损耗可能比表级锁会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统的并发量较高时，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。但是，InnoDB的行级锁同样也有脆弱的一面，当我们使用不当时，可能会让InnoDB的整体性能表现不仅不如MyISAM，甚至可能更差。</p></blockquote><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li>尽可能的让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽可能的缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务代销，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ol><h2 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h2><p>开锁和加锁时间结余表锁和行锁之间，会出现死锁，锁定粒度结余表锁和行锁之间，并发度一般</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-slave1 -v /root/slave1/log:/var/log/mysql -v /root/slave1/data:/var/lib/mysql -v /root/slave1/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.49</span><br></pre></td></tr></tbody></table></figure></div><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Master配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=1 # 必须</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin # 必须</span><br><span class="line">read-only=0</span><br><span class="line">binlog-ignore-db=mysql</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Slave配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=2 # 必须</span><br></pre></td></tr></tbody></table></figure></div><p><strong>关于docker下mysql无法启动修改配置文件</strong></p><p>把docker容器中的配置文件复制到主机中，然后在主机中修改，修改完成后再复制到docker容器中，这里需要使用的docker的命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp [容器id]：docker容器中配置文件路径  主机路径</span><br></pre></td></tr></tbody></table></figure></div><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp mysql:/etc/mysql/my.cnf /home/my.cnf</span><br></pre></td></tr></tbody></table></figure></div><p>这样就能把容器中的文件拿到本地来，然后进行修改之后呢，再通过该命名上传到容器中去。</p><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 主机文件路径 容器id：docker容器中配置文件路径</span><br><span class="line">docker cp /home/my.cnf mysql:/etc/mysql/my.cnf</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>主机</p></blockquote><p>创建复制账户</p><p><strong>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘zhangsan’@’182.254.146.46’ IDENTIFIED BY ‘123456’;</strong></p><p>刷新配置</p><p><strong>FLUSH PRIVILEGES;</strong></p><p>查看主机状态</p><p><strong>SHOW MASTER STATUS;</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409215117.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><blockquote><p>从机</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'182.254.146.46'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'zhangsan'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'123456'</span>,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'file编号'</span>,</span><br><span class="line">MASTER_LOG_POS=<span class="keyword">Position</span>值;</span><br></pre></td></tr></tbody></table></figure></div><p>开启</p><p><strong>START SLAVE;</strong></p><p>从机状态</p><p><strong>SHOW SLAVE STATUS\G</strong></p><p><code>lave_IO_Running 和 Slave_SQL_Running 必须同时为Yes 说明主从复制配置成功！</code></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210409215510.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://raptor1998.top/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://raptor1998.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>J2EE环境搭建-Linux（Centos7）</title>
    <link href="http://raptor1998.top/2021/03/29/J2EE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-linux/"/>
    <id>http://raptor1998.top/2021/03/29/J2EE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-linux/</id>
    <published>2021-03-28T16:00:00.000Z</published>
    <updated>2021-08-16T13:10:24.729Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压tar包到/usr/local/java</span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure></div><h1 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压tar包到/usr/<span class="built_in">local</span>/apache-maven-3.6.1</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.6.1</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">mvn -version</span><br></pre></td></tr></tbody></table></figure></div><h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><p><strong>一、 gcc</strong></p><p>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：</p><p><strong>yum install gcc-c++</strong></p></li><li><p><strong>二、 PCRE</strong></p><p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</p><p><strong>yum install -y pcre pcre-devel</strong></p></li><li><p><strong>三、 zlib</strong></p><p>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p><p><strong>yum install -y zlib zlib-devel</strong></p></li><li><p><strong>四、 openssl</strong></p><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用</p><p>程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库</p><p><strong>yum install -y openssl openssl-devel</strong></p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://nginx.org/download/" target="_blank" rel="noopener">tar包下载</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. tar -zxvf nginx-1.16.1.tar.gz</span><br><span class="line"></span><br><span class="line">2. mkdir nginx</span><br><span class="line"></span><br><span class="line">3. cd nginx-1.16.1</span><br><span class="line"></span><br><span class="line">4.  ./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line">5.  make</span><br><span class="line"></span><br><span class="line">6.  make install</span><br></pre></td></tr></tbody></table></figure></div><h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports   查看当前放行的端口</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent      开放某个端口</span><br><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent    关闭某个端口</span><br><span class="line">firewall-cmd --reload / systemctl restart filewalld.service    重启防火墙</span><br><span class="line">systemctl enable firewalld    开机启动防火墙</span><br><span class="line">systemctl disable firewalld   禁止防火墙开机启动</span><br><span class="line">systemctl start firewalld     开启防火墙</span><br><span class="line">systemctl stop firewalld      停止防火墙</span><br></pre></td></tr></tbody></table></figure></div><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>5.6的 <strong>password</strong> 字段 5.7 改为<strong>authentication_string</strong>字段</p><h2 id="RPM-MYSQL-5-6"><a href="#RPM-MYSQL-5-6" class="headerlink" title="RPM  MYSQL 5.6"></a>RPM  MYSQL 5.6</h2><p><a href="http://repo.mysql.com/" target="_blank" rel="noopener">*.rpm</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查MySQL及相关RPM包 rpm –e 名称</span></span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line">yum -y remove mysql-libs*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建组和用户</span></span><br><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要的依赖</span></span><br><span class="line">yum install -y cmake make gcc gcc-C++ libaio ncurses ncurses-devel</span><br><span class="line">yum install -y perl-Module-Install.noarch</span><br><span class="line">yum install net-tools.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">rpm -ivh MySQL-server-5.6.49-1.el6.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh MySQL-devel-5.6.49-1.el6.x86_64.rpm </span><br><span class="line">rpm -ivh MySQL-client-5.6.49-1.el6.x86_64.rpm </span><br><span class="line"></span><br><span class="line">cp /usr/share/mysql/my-default.cnf /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化MySQL及设置密码</span></span><br><span class="line">/usr/bin/mysql_install_db</span><br><span class="line">service mysql start</span><br><span class="line">cat /root/.mysql_secret  #查看root账号密码</span><br><span class="line">mysql -u root –p </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SET PASSWORD = PASSWORD(<span class="string">'123456'</span>);</span></span><br><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="meta">#</span><span class="bash">允许远程登陆</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select host,user,password from user;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">'123456'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> host=<span class="string">'%'</span> <span class="built_in">where</span> user=<span class="string">'root'</span> and host=<span class="string">'localhost'</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机自启动</span></span><br><span class="line">chkconfig mysql on</span><br><span class="line">chkconfig --list | grep mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">修改字符集和数据存储路径</span></span><br><span class="line">    [client]</span><br><span class="line">    password        = 1234567</span><br><span class="line">    port            = 3306</span><br><span class="line">    default-character-set=utf8</span><br><span class="line">    [mysqld]</span><br><span class="line">    user=root</span><br><span class="line">    port            = 3306</span><br><span class="line">    character_set_server=utf8</span><br><span class="line">    character_set_client=utf8</span><br><span class="line">    collation-server=utf8_general_ci</span><br><span class="line">    #(注意linux下mysql安装完后是默认：表名区分大小写，列名不区分大小写； 0：区分大小写，1：不区分大小写)</span><br><span class="line">    lower_case_table_names=1</span><br><span class="line">    ##(设置最大连接数，默认为 151，MySQL服务器允许的最大连接数16384; )</span><br><span class="line">    max_connections=1000</span><br><span class="line">    [mysql]</span><br><span class="line">    default-character-set = utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">查看字符集</span></span><br><span class="line">show variables like '%collation%';</span><br><span class="line">show variables like '%char%';</span><br></pre></td></tr></tbody></table></figure></div><h2 id="TAR-MYSQL-5-7"><a href="#TAR-MYSQL-5-7" class="headerlink" title="TAR MYSQL 5.7"></a>TAR MYSQL 5.7</h2><h3 id="STEPS"><a href="#STEPS" class="headerlink" title="STEPS"></a>STEPS</h3><p><a href="https://repo.huaweicloud.com/mysql/Downloads/MySQL-5.7/" target="_blank" rel="noopener">华为云</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同上  添加用户组  安装依赖</span></span><br><span class="line">6  cat /etc/group | grep mysql</span><br><span class="line">7  groupadd mysql</span><br><span class="line">8  useradd -r -g mysql mysql</span><br><span class="line">9  id mysql   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">11  tar -zxvf mysql-5.7.33-linux-glibc2.12-x86_64.tar.gz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 放在 /usr/<span class="built_in">local</span>/mysql</span></span><br><span class="line">13  mv mysql-5.7.33-linux-glibc2.12-x86_64 mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改权限</span></span><br><span class="line">15  chown -R mysql:mysql mysql/</span><br><span class="line">16  chmod -R 755 mysql/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">20  yum install -y perl-Module-Install.noarch</span><br><span class="line">21  yum install net-tools.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 某些版本解压出来的mysql没有data目录   创建 /usr/<span class="built_in">local</span>/mysql/data</span></span><br><span class="line">24  mkdir data</span><br><span class="line">26  chown -R mysql:mysql mysql/</span><br><span class="line">27  chmod -R 755 mysql/</span><br><span class="line">28  yum install -y cmake make gcc gcc-C++ libaio ncurses ncurses-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行初始化 之前 查看/etc下是否存在my.cnf文件，改名备份或者删除，否则一堆莫名其妙错误</span></span><br><span class="line">29  mv /etc/my.cnf /etc/my-back.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以前是mysql_install_db 初始化 datadir就是安装路径，basedir就是根目录  /usr/<span class="built_in">local</span>/mysql/bin目录 ,7Qx0rZqh&amp;%s</span></span><br><span class="line">36  ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上一步会生成临时面 见下图</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加开机启动  /usr/<span class="built_in">local</span>/mysql目录</span></span><br><span class="line">38  cp ./support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建RSA private key  /usr/<span class="built_in">local</span>/mysql/bin目录</span></span><br><span class="line">41  ./mysql_ssl_rsa_setup --datadir=/usr/local/mysql/data/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了保险再授权一次</span></span><br><span class="line">48  chown -R mysql:mysql ./</span><br><span class="line">49  chown -R mysql:mysql ./data/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑mysql配置文件  见末尾</span></span><br><span class="line">52  vim /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动 修改basedir 和datadir 为之前的安装地址 datadir=/usr/<span class="built_in">local</span>/mysql/data basedir=/usr/<span class="built_in">local</span>/mysql</span></span><br><span class="line">53  vim /etc/init.d/mysqld </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">54  service mysqld start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入开机启动</span></span><br><span class="line">55  chkconfig --add mysqld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现找不到命令 添加软连接</span></span><br><span class="line">59  ln -s /usr/local/mysql/bin/mysql /usr/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化时生成了临时密码</span></span><br><span class="line">60  mysql -u root -p</span><br><span class="line"></span><br><span class="line">alter user 'root'@'localhost' identified by '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程连接</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS db_test DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210816103415.png" data-fancybox="group" data-caption="初始化结果" class="fancybox"><img alt="初始化结果" title="初始化结果" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210816103415.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="my-cfg"><a href="#my-cfg" class="headerlink" title="my.cfg"></a>my.cfg</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect='SET NAMES utf8'</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"><span class="meta">#</span><span class="bash">不区分大小写 </span></span><br><span class="line">lower_case_table_names = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">不开启sql严格模式</span></span><br><span class="line">sql_mode = "STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/usr/local/mysql/data/mysqld.pid</span><br></pre></td></tr></tbody></table></figure></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/wqkeep/p/10708096.html" target="_blank" rel="noopener">Linux安装nginx的环境要求</a></p><p><a href="https://candy.blog.csdn.net/article/details/80019881" target="_blank" rel="noopener">linux centos7下源码 tar安装mysql5.7.30或mysql5.7.22 图文详解</a></p><p><a href="https://blog.csdn.net/qq_30000313/article/details/85333971" target="_blank" rel="noopener">linux安装mysql5.7.24</a></p></body></html>]]></content>
    
    <summary type="html">
    
      J2EE环境搭建-Linux
    
    </summary>
    
    
      <category term="Linux" scheme="http://raptor1998.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://raptor1998.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://raptor1998.top/2021/03/27/redis/"/>
    <id>http://raptor1998.top/2021/03/27/redis/</id>
    <published>2021-03-26T16:00:00.000Z</published>
    <updated>2021-07-14T02:55:03.871Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="NoSql？非关系型数据库"><a href="#NoSql？非关系型数据库" class="headerlink" title="NoSql？非关系型数据库"></a>NoSql？非关系型数据库</h2><h3 id="单机MySQL"><a href="#单机MySQL" class="headerlink" title="单机MySQL"></a>单机MySQL</h3><ul><li><p>数据量的总大小一个机器放不下时</p></li><li><p>数据的索引(B+ Tree)一个机器的内存放不下时</p></li><li><p>访问量(读写混合)一个实例不能承受</p></li></ul><h3 id="Memcached-缓存-MySQL-垂直拆分"><a href="#Memcached-缓存-MySQL-垂直拆分" class="headerlink" title="Memcached(缓存)+MySQL+垂直拆分"></a>Memcached(缓存)+MySQL+垂直拆分</h3><p>​        <code>由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模 式成为这个时候的网站标配了。</code></p><h3 id="分表分库-水平拆分-mysql集群"><a href="#分表分库-水平拆分-mysql集群" class="headerlink" title="分表分库+水平拆分+mysql集群"></a>分表分库+水平拆分+mysql集群</h3><p>​        <code>在Memcached的高速缓存，MySQL的主从复制， 读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</code></p><p><code>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</code></p><ol><li>易扩展<br> NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</li><li>大数据量高性能<br> NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache,在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</li><li>多样灵活的数据模型<br> NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</li></ol><h2 id="NoSql特点"><a href="#NoSql特点" class="headerlink" title="NoSql特点"></a>NoSql特点</h2><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键-值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据:</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h2 id="NoSql数据库分类"><a href="#NoSql数据库分类" class="headerlink" title="NoSql数据库分类"></a>NoSql数据库分类</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210328163430.png" data-fancybox="group" data-caption="NoSql数据库的四大分类" class="fancybox"><img alt="NoSql数据库的四大分类" title="NoSql数据库的四大分类" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210328163430.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="分布式数据库CAP"><a href="#分布式数据库CAP" class="headerlink" title="分布式数据库CAP"></a>分布式数据库CAP</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol><li><p><code>A (Atomicity) 原子性 就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</code></p></li><li><p><code>C (Consistency) 一致性 就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</code></p></li><li><p><code>I (Isolation) 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</code></p></li><li><p><code>D (Durability) 持久性 持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</code></p></li></ol><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>C:Consistency（强一致性）</li><li>A:Availability（可用性）</li><li>P:Partition tolerance（分区容错性）</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span><br><span class="line">可用性（A）：保证每个请求不管成功或者失败都有响应。</span><br><span class="line">分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</span><br></pre></td></tr></tbody></table></figure></div><h3 id="CAP的三进二"><a href="#CAP的三进二" class="headerlink" title="CAP的三进二"></a>CAP的三进二</h3><p>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210328164352.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210328164352.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li><p>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</p></li><li><p>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</p></li><li><p>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p></li></ul><hr><ul><li>一致性与可用性的决择</li></ul><ul><li>数据库事务一致性需求</li></ul><p><code>很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</code></p><ul><li>数据库的写实时性和读实时性需求</li></ul><p><code>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说在微博发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</code></p><ul><li>对复杂的SQL查询，特别是多表关联查询的需求<br><code>任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</code></li></ul><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p><strong>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</strong></p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft state）</li><li>最终一致（Eventually consistent）</li></ul><p>它的思想是通过<strong>让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</strong>。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="Redis文档"><a href="#Redis文档" class="headerlink" title="Redis文档"></a>Redis文档</h2><h2 id="Redis-与其他-key-value-缓存产品有以下三个特点："><a href="#Redis-与其他-key-value-缓存产品有以下三个特点：" class="headerlink" title="Redis 与其他 key - value 缓存产品有以下三个特点："></a>Redis 与其他 key - value 缓存产品有以下三个特点：</h2><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="xxxx"><a href="#xxxx" class="headerlink" title="xxxx"></a>xxxx</h4><h3 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h3><p>默认6379  16库</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul><li><code>SELECT</code>   切换库</li><li><code>DBSIZE</code>   当前库的key数量</li><li><code>FLUSHDB</code>  清空当前库</li><li><code>FLUSHALL</code>   清空全部库</li></ul><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><h2 id="键key"><a href="#键key" class="headerlink" title="键key"></a>键key</h2><table><thead><tr><th>key *</th><th>所有key</th></tr></thead><tbody><tr><td>exists key</td><td>判断某个key是否存在</td></tr><tr><td>move key db</td><td>移动到某库</td></tr><tr><td>expire key seconds</td><td>设置过期时间</td></tr><tr><td>ttl key</td><td>查看key剩余过期时间，-1永不过期，2已经过期</td></tr><tr><td>type key</td><td>查看key类型</td></tr></tbody></table><p><a href="https://redis.io/commands#generic" target="_blank" rel="noopener">https://redis.io/commands#generic</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</span><br><span class="line"><span class="number">2</span>. string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</span><br><span class="line"><span class="number">3</span>. string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是<span class="number">512</span>M</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Redis hash 是一个键值对集合。</span><br><span class="line"><span class="number">2</span>. Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</span><br><span class="line"><span class="number">3</span>. 类似Java里面的Map&lt;String,Object&gt;</span><br></pre></td></tr></tbody></table></figure></div><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</span><br><span class="line"><span class="number">2</span>. 它的底层实际是个链表</span><br></pre></td></tr></tbody></table></figure></div><p>链表的操作无论是头和尾效率都极高，但对中间元素进行操作，效率就惨淡了</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的Set是string类型的无序集合。它是通过HashTable实现实现的    差集、交集、并集</span><br></pre></td></tr></tbody></table></figure></div><h2 id="有序表Zset"><a href="#有序表Zset" class="headerlink" title="有序表Zset"></a>有序表Zset</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Redis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。</span><br><span class="line"><span class="number">2</span>. 不同的是每个元素都会关联一个<span class="keyword">double</span>类型的分数。</span><br><span class="line"><span class="number">3</span>. redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。</span><br></pre></td></tr></tbody></table></figure></div><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p><a href="https://redis.io/commands#" target="_blank" rel="noopener">https://redis.io/commands#</a></p><h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><p><a href="https://blog.csdn.net/suprezheng/article/details/90679790" target="_blank" rel="noopener">https://blog.csdn.net/suprezheng/article/details/90679790</a></p><h1 id="内存处理策略"><a href="#内存处理策略" class="headerlink" title="内存处理策略"></a>内存处理策略</h1><p><code>#volatile-lru：利用LRU算法移除设置过过期时间的key。#volatile-random：随机移除设置过过期时间的key。#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）#allkeys-lru：利用LRU算法移除任何key。#allkeys-random：随机移除任何key。#noeviction：不移除任何key，只是返回一个写错误。</code></p><h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p><a href="https://redis.io/topics/persistence#redis-persistence" target="_blank" rel="noopener">https://redis.io/topics/persistence#redis-persistence</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis provides a different range of persistence options:</p><ul><li><strong>RDB</strong> (Redis Database): The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li><li><strong>AOF</strong> (Append Only File): The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big.</li><li><strong>No persistence</strong>: If you wish, you can disable persistence completely, if you want your data to just exist as long as the server is running.</li><li><strong>RDB + AOF</strong>: It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</li></ul><p>The most important thing to understand is the different trade-offs between the RDB and AOF persistence. Let’s start with RDB:</p><p>​        <code>在指定时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时将快照文件直接读到内存</code></p><p>​        <code>Redis会单独创建一个（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，真个过程中，主进程是不尽兴任何IO操作的，这样就确保了极高的性能，如果徐涛进行大规模的数据恢复，且对数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</code></p><h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p><h2 id="RDB保存的是dump-rdb文件"><a href="#RDB保存的是dump-rdb文件" class="headerlink" title="RDB保存的是dump.rdb文件"></a>RDB保存的是dump.rdb文件</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behavior will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save ""</span><br><span class="line"></span><br><span class="line">默认<span class="number">900</span>秒内有<span class="number">1</span>个更改，<span class="number">300</span>秒内有<span class="number">10</span>个更改以及<span class="number">60</span>秒内有<span class="number">10000</span>个更改，则将内存中的数据快照写入磁盘。</span><br></pre></td></tr></tbody></table></figure></div><h2 id="RDB-（redis-database）"><a href="#RDB-（redis-database）" class="headerlink" title="RDB （redis database）"></a>RDB （redis database）</h2><ul><li><p>配置文件中默认的快照配置dbfilename dump.rdb<br>冷拷贝后重新使用<br>cp dump.rdb dump_new.rdb</p></li><li><p>save或bgsave</p><ul><li>Save：save时只管保存，其它不管，全部阻塞</li><li>BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li></ul></li><li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p></li></ul><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p><strong>将备份文件  dump.rdb  移动至安装目录启动即可</strong></p><p>*<em>CONFIG GET dir  获取目录 *</em></p><p>停止    <code>redis-cli config set save ""</code></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>适合大规模的数据恢复</li><li>对数据的完整性和一致性要求不搞</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>在一定间隔时间做一次备份，redis意外宕机的话，就会丢失最后一次快照后的所有修改</li><li>Fork的时候，内存的数据被克隆了一份，大致两倍的膨胀性能需要考虑</li></ul><h2 id="AOF-（Append-Only-File）"><a href="#AOF-（Append-Only-File）" class="headerlink" title="AOF （Append Only File）"></a>AOF （Append Only File）</h2><p>The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big.</p><p><strong>以日志的形式来记录每个写操作,</strong>将redis执行过的所有命令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，或者说，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code># AOF and RDB persistence can be enabled at the same time without problems.</code></p><p><code># If the AOF is enabled on startup Redis will load the AOF, that is the file</code></p><p><code># with the better durability guarantees.</code></p><h5 id="appendonly-yes-开启"><a href="#appendonly-yes-开启" class="headerlink" title="appendonly yes  开启"></a><strong>appendonly yes</strong>  开启</h5><h5 id="appendfsync-everysec"><a href="#appendfsync-everysec" class="headerlink" title="appendfsync everysec"></a><strong>appendfsync everysec</strong></h5><p><code>Redis supports three different modes:</code></p><ul><li><p><code># no: don't fsync, just let the OS flush the data when it wants. Faster.</code></p></li><li><p><code># always: fsync after every write to the append only log. Slow, Safest.</code></p><p>同步持久化，每次发生数据变更会立即被记录到磁盘，性能较差，但数据完整性较好</p></li><li><p><code># everysec: fsync only one time every second. Compromise.</code></p><p>出场默认推荐，一步操作，每秒记录，如果一秒内宕机，有数据丢失</p></li></ul><h5 id="no-appendfsync-on-rewrite-no"><a href="#no-appendfsync-on-rewrite-no" class="headerlink" title="no-appendfsync-on-rewrite no"></a>no-appendfsync-on-rewrite no</h5><p>重写时是否可以运用appendfsync，用no即可，保证数据安全性和</p><h5 id="auto-aof-rewrite-percentage-100"><a href="#auto-aof-rewrite-percentage-100" class="headerlink" title="auto-aof-rewrite-percentage 100"></a>auto-aof-rewrite-percentage 100</h5><p>设置重写的基准值</p><h5 id="auto-aof-rewrite-min-size-64mb"><a href="#auto-aof-rewrite-min-size-64mb" class="headerlink" title="auto-aof-rewrite-min-size 64mb"></a>auto-aof-rewrite-min-size 64mb</h5><p>设置重写的基准值</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><h4 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h4><p>aof保存到对应目录（CONFIG GET dir）启动即可</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>redis-check-aof –fix file</strong></p><h3 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h3><p>AOF采用文件追加方式，文件会越来越大，为了避免这种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可恢复数据的最小指令集，可以使用命令 <a href="https://redis.io/commands/bgrewriteaof" target="_blank" rel="noopener">BGREWRITEAOF</a></p><h4 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h4><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（同样是先写临时文件最后在rename），遍历新进程的内存中数据，每条记录都有一条的set语句。重写aof文件操作，并没有读取就得aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，和快照类似</p><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</p><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><p>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</p><p>aof运行效率要慢于rdb，每秒同步策略较好，不同步效率和rdb相同</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>RDB持久化方式能够在指定时间间隔内对数据进行快照存储</p><p>AOF持久化方式记录每次对服务器的写操作，当服务器重启的时候就会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾，redis还能对AOF文件进行后台重写，使得AOF文件的体积不止于过大</p><p>只做缓存，如果只希望数据在服务器运行时存在，可以不用任何持久化方式</p><p>同时开启两种持久化策略：</p><p><code>这种情况下，当redis重启的时候回优先载入AOF文件来恢复初始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集完整</code></p><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件那是否可以只是用AOF？</p><p><code>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段</code></p><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>所有命令都会被序列化，按顺序的串行化执行而不会被其他命令插入，不需加塞。</p><ul><li><a href="https://redis.io/commands/discard" target="_blank" rel="noopener">DISCARD</a></li><li><a href="https://redis.io/commands/exec" target="_blank" rel="noopener">EXEC</a></li><li><a href="https://redis.io/commands/multi" target="_blank" rel="noopener">MULTI</a></li><li><a href="https://redis.io/commands/unwatch" target="_blank" rel="noopener">UNWATCH</a></li><li><a href="https://redis.io/commands/watch" target="_blank" rel="noopener">WATCH</a></li></ul><p>redis对事务部分支持</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>demo1全体连坐  一个错误全部不执行</p><p>demo2 正确的执行 错误的抛出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> demo1</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "k1"</span><br><span class="line">2) "k2"</span><br><span class="line">3) "k3"</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3</span><br><span class="line">(error) ERR wrong number of arguments for 'getset' command</span><br><span class="line">127.0.0.1:6379&gt; set k4 44</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> demo2</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "k1"</span><br><span class="line">2) "k2"</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">"aa"</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">"bb"</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 33</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) OK</span><br></pre></td></tr></tbody></table></figure></div><h3 id="watch监控"><a href="#watch监控" class="headerlink" title="watch监控"></a>watch监控</h3><h4 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁  Pessimistic Lock"></a>悲观锁  Pessimistic Lock</h4><p>每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这个数据机会block知道他拿到锁，传统的关系型数据库像行锁、表锁、读锁、写锁等都是在操作之前先上锁</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>每次取数据的时候都认为比人不会修好，所以不会上锁，但是更新的时候回判断在此期间有没有人更新这个数据，可以使用版本号等机制</p><h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set balance 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set debt 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "debt"</span><br><span class="line">2) "balance"</span><br><span class="line">127.0.0.1:6379&gt; get balance</span><br><span class="line">"100"</span><br><span class="line">127.0.0.1:6379&gt; WATCH balance</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY balance 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY debt 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; WATCH balance</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 加塞  执行set balance 800</span></span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY balance 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY debt 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get balance</span><br><span class="line">"800"</span><br></pre></td></tr></tbody></table></figure></div><h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><ul><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li><li>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h1 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h1><p>rabbitmq</p><h1 id="主从复制-master-salve"><a href="#主从复制-master-salve" class="headerlink" title="主从复制  master/salve"></a>主从复制  master/salve</h1><ul><li>读写分离</li><li>容灾恢复</li></ul><h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><ol><li><p>配从库不配主库</p></li><li><p>从库配置：<strong>slaveof 主库ip 主库端口</strong></p><ul><li>每次master断开之后，都需要重新连接，除非你配置进redis.conf  <strong>REPLICATION</strong></li><li>INFO replication 当前角色</li><li>对于主机设置密码  配置文件中 masterauth password</li></ul></li><li><p>常用模式</p><ul><li><p>一主二仆</p><p><code>主机shutdown之后，从机原地待命；主机又开启之后，主机新增记录，从机可以顺利复制</code></p><p><code>从机shutdown之后，无法获得主机数据，每次与master断开连接后，都需要重新连接，除非配置进redis.conf文件</code></p></li><li><p>薪火相传</p><p>链式传递</p></li><li><p>反客为主</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></tbody></table></figure></div><p>是当前的数据库停止与其他数据库的同步，转为主数据库</p></li></ul></li></ol><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul><li>slave启动成功连接到master后会发送一个sync命令<br>master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master，一次完全同步（全量复制)将被自动执行</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>能够从后台监控机器是否故障，如果故障了根据投票数自动将从库转换为主库</strong></p><p>新建sentinel.conf</p><p><strong>sentinel monitor host6379 127.0.0.1 6379 1</strong> </p><p><strong>sentinel auth-pass host6379 123456</strong>    //主机密码</p><p>最后一个数字1 表示，主机挂掉以后，slave投票看让谁接替成为主机</p><p>哨兵开启</p><p><strong>redis-sentinel /user/local/redis/bin/sentinel.conf</strong></p><p>当主机挂掉后，从库成为master，当旧主机重启后，会改变身份，成为slave</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>由于所有的写操作都在master上操作，然后同步更新到slave上，所以从master同步到slave机器有一定延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会是这个问题更加严重。</p></body></html>]]></content>
    
    <summary type="html">
    
      Redis的集群：Redis分片的缺点、集群架构、集群操作基本命令。Lua脚本语言的介绍。Redis和Lua结合，Redis的Lua脚本编程，构建强大的Redis服务。Redis整合Spring等。Redis集群实现Tomcat集群的Session共享等
    
    </summary>
    
    
      <category term="Redis" scheme="http://raptor1998.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://raptor1998.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://raptor1998.top/2021/03/10/mybatis/"/>
    <id>http://raptor1998.top/2021/03/10/mybatis/</id>
    <published>2021-03-09T16:00:00.000Z</published>
    <updated>2021-07-14T02:55:32.993Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">mybatis官方文档</a></p><h1 id="mybatis参数处理"><a href="#mybatis参数处理" class="headerlink" title="mybatis参数处理"></a>mybatis参数处理</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BookMapper mapper = sqlSession.getMapper(BookMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Book qwe = mapper.queryByIdAndName(<span class="number">3</span>, <span class="string">"qwe"</span>);</span><br><span class="line">System.out.println(qwe);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></tbody></table></figure></div><p><code>规定了一个mapper接口，调用了queryByIdAndName这个方法，mybatis会为BookMapper创建一个代理对象，最终都是代理对象去实现这个方法</code></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419161247.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419161247.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162156.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162156.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162241.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162241.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>paramNameResolver解析参数封装map的</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Book <span class="title">queryByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id , @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String name)</span>;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>names:{0 = id , 1 = name}   names  值 的来源：</strong>  </p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419164220.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419164220.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>此时，若是还有第三个参数且未标注param则，names{0=id，1=name，2=2}</strong></p><p><strong>args此时不为空，值为{3，qwe}</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> paramCount = <span class="keyword">this</span>.names.size();</span><br><span class="line">    <span class="comment">//1. 如果参数为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; paramCount != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">//2. 如果只有一个参数，并且没有param注解，返回args[0]，单个参数直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> args[(Integer)<span class="keyword">this</span>.names.firstKey()];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//3. 多个元素或者有param注解</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//4. 遍历names（构造器中值已经确定），{0=id，1=name}</span></span><br><span class="line">            <span class="keyword">for</span>(Iterator var5 = <span class="keyword">this</span>.names.entrySet().iterator(); var5.hasNext(); ++i) {</span><br><span class="line">            <span class="comment">//names集合的value作为key，names集合的key作为取值的参考args[0]: args{1,"qwe"}</span></span><br><span class="line">                <span class="comment">//取值之后则： {id = args[0]:3,name=args[1]:"qwe"}</span></span><br><span class="line">                <span class="comment">//假设有第三个参数且无注解，则 {id = args[0]:3,name=args[1]:"qwe",2 = args[2]}</span></span><br><span class="line">                Entry&lt;Integer, String&gt; entry = (Entry)var5.next();</span><br><span class="line">                param.put(entry.getValue(), args[(Integer)entry.getKey()]);</span><br><span class="line">                <span class="comment">//额外的将每一个参数也保存到map中，使用新的key：param1...paramN</span></span><br><span class="line">                <span class="comment">//效果： 有param注解可以#{指定的key}，或#{param1}</span></span><br><span class="line">                String genericParamName = <span class="string">"param"</span> + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.names.containsValue(genericParamName)) {</span><br><span class="line">                    param.put(genericParamName, args[(Integer)entry.getKey()]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> param;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162545.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210419162545.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="参数值的获取"><a href="#参数值的获取" class="headerlink" title="参数值的获取"></a>参数值的获取</h2><p><strong>#{  }，${  }区别：# 是以预编译的形式，将参数设置到sql语句中，prepareStatement，防止sql注入；$取出的值直接拼装在sql语句中，会有安全问题</strong></p><p><code>大多数情况下，使用#{}取值</code></p><blockquote><p> ${}使用场景</p></blockquote><p><strong>原生jdbc不支持占位符的地方就可以使用${}进行取值</strong></p><p>*<em>分表，按照年份份表拆分：select * from ${year}_salary where xxx; *</em></p><p><strong>排序，select * from emp order by ${name} ${order}</strong></p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>MyBatis系统中默认定义了两级缓存。 </p><p><strong>一级缓存和二级缓存</strong></p><p>1、默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。</p><p>2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。<br>3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。</p><h2 id="一级缓存（本地缓存）"><a href="#一级缓存（本地缓存）" class="headerlink" title="一级缓存（本地缓存）"></a>一级缓存（本地缓存）</h2><p>sqlSession级别的缓存，一级缓存是一只开启的，SQLSession级别的一个map</p><ul><li><p>一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。当 Session flush 或 close 后, 该Session 中的所有 Cache 将被清空。</p></li><li><p>本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域. </p></li></ul><blockquote><p> 一级缓存失效的情况：</p></blockquote><ol><li>SQLSession不同</li><li>sqlsession相同，条件不同</li><li>sqlsession相同，两次查询之间执行了增删改</li><li>sqlsession相同，手动清除了一级缓存</li></ol><h2 id="二级缓存（全局缓存）"><a href="#二级缓存（全局缓存）" class="headerlink" title="二级缓存（全局缓存）"></a>二级缓存（全局缓存）</h2><p>基于namespace级别的缓存，一个namespace对应一个二级缓存</p><p><code>查出的数据都会被默认放在一级缓存中，只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存</code></p><p><strong>一个会话慢查询一条数据，这个数据就会被放到当前会话的一级缓存中；如果会话关闭，一级缓存中的数据会被保存到二级缓存中，新的会话查询信息，就可以参照二级缓存；不同的namespace查出的数据会被放在在即对应的缓存中</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p><strong>eviction=“FIFO”：</strong>缓存回收策略：</p></blockquote><p>LRU – 最近最少使用的：移除最长时间不被使用的对象。</p><p>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>默认的是 LRU。 </p><blockquote><p><strong>flushInterval：</strong>刷新间隔，单位毫秒</p></blockquote><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p><blockquote><p><strong>size：</strong>引用数目，正整数</p></blockquote><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p><blockquote><p><strong>readOnly：</strong>只读，true/false</p></blockquote><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象</p><p>不能被修改。这提供了很重要的性能优势。</p><p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，</p><p>但是安全，因此默认是 false。</p><h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><ol><li><p>“cacheEnabled”=”false”</p><p>关闭二级缓存，一级缓存可用</p></li><li><p>每个select标签有usCache=“true”</p><p>false：一级缓存依然使用，二级缓存不可用</p></li><li><p>每个增删改的flushCache默认true</p><p>增删改完成后会清除一级和二级缓存</p></li><li><p>sqlSession.clearCache()： </p><p>只是用来清除一级缓存。 </p></li><li><p>当在某一个作用域 (一级缓存Session/二级缓存Namespaces) 进行了 C/U/D 操作后，默认该作用域下<strong>所有 select 中的缓存将被clear</strong>。</p></li><li><p>localCacheScope     （SESSION | STATEMENT）</p><p>MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</p></li></ol><h2 id="缓存流程"><a href="#缓存流程" class="headerlink" title="缓存流程"></a>缓存流程</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210420193907.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210420193907.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="整合第三方缓存ehcache"><a href="#整合第三方缓存ehcache" class="headerlink" title="整合第三方缓存ehcache"></a>整合第三方缓存ehcache</h2><p>xxxx</p><h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><p><a href="http://mybatis.org/generator/index.html" target="_blank" rel="noopener">MyBatis Generator官方文档</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>编写MBG的配置文件（重要几处配置）</p><p>1）jdbcConnection配置数据库连接信息</p><p>2）javaModelGenerator配置javaBean的生成策略</p><p>3）sqlMapGenerator 配置sql映射文件生成策略</p><p>4）javaClientGenerator配置Mapper接口的生成策略</p><p>5）table 配置要逆向解析的数据表</p><p>​                tableName：表名</p><p>​                domainObjectName：对应的javaBean名 </p></li><li><p>运行代码生成器生成代码</p><p>Context标签</p><p><strong>targetRuntime=“MyBatis3“</strong>可以生成带条件的增删改查</p><p><strong>targetRuntime=“MyBatis3Simple“</strong>可以生成基本的增删改查</p></li></ol><h2 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"DB2Tables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/testdata?serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.hdu.entity"</span> <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapping"</span> <span class="attr">targetProject</span>=<span class="string">".\src\main\resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.hdu.dao"</span> <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"bank"</span> <span class="attr">domainObjectName</span>=<span class="string">"Bank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="runGen-java"><a href="#runGen-java" class="headerlink" title="runGen.java"></a>runGen.java</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">context</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">    File configFile = <span class="keyword">new</span> File(<span class="string">"src/main/resources/generatorConfig.xml"</span>);</span><br><span class="line">    ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">    Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">    DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">    MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//xxxExample就是封装查询条件的</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">context2</span><span class="params">()</span></span>{</span><br><span class="line">        BankExample bankExample = <span class="keyword">new</span> BankExample();</span><br><span class="line">        BankExample.Criteria criteria = bankExample.createCriteria();</span><br><span class="line">        criteria.andMoneyBetween(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">        BankExample.Criteria criteria1 = bankExample.createCriteria();</span><br><span class="line">        criteria1.andMoneyEqualTo(<span class="number">600</span>);</span><br><span class="line">        bankExample.or(criteria1);</span><br><span class="line">        List&lt;Bank&gt; banks = bankMapper.selectByExample(bankExample);</span><br><span class="line">        System.out.println(banks);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421100048.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421100048.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><blockquote><ol><li>获取获取sqlSessionFactory对象</li><li>获取SQLSession对象</li><li>获取接口的实现类斗代理对象（MapperProxy）</li><li>执行增删改查</li></ol></blockquote><h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><h3 id="sqlSessionFactory-init"><a href="#sqlSessionFactory-init" class="headerlink" title="sqlSessionFactory-init"></a>sqlSessionFactory-init</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></tbody></table></figure></div><p><strong>把配置文件的信息解析并保存在Configuration对象中，返回包含了Configuration的DefaultConfiguration对象</strong></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171340.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171340.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="步骤详情"><a href="#步骤详情" class="headerlink" title="步骤详情"></a>步骤详情</h4><blockquote><p>创建SQLSessionFactoryBuilder对象</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142420.png" data-fancybox="group" data-caption="创建SQLSessionFactory" class="fancybox"><img alt="创建SQLSessionFactory" title="创建SQLSessionFactory" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142420.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>bulid(inputstream)</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142421.png" data-fancybox="group" data-caption="跟踪进入build方法" class="fancybox"><img alt="跟踪进入build方法" title="跟踪进入build方法" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142421.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>XMLConfigBuilder 创建解析器parser</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142422.png" data-fancybox="group" data-caption="parser.parse()" class="fancybox"><img alt="parser.parse()" title="parser.parse()" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142422.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>把每一个标签的配置信息解析到Configuration中</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142424.png" data-fancybox="group" data-caption="configuration解析" class="fancybox"><img alt="configuration解析" title="configuration解析" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142424.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142423.png" data-fancybox="group" data-caption="setting解析" class="fancybox"><img alt="setting解析" title="setting解析" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142423.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142430.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142430.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>mapper解析实例</p><p>Mapper.xml纵的每一个元素信息解析出来并保存在全局配置中，将增删改查标签的每一个属性都解析出来封装成一个MappedStatement</p><p>一个mappedStateMent就代表一个增删改查标签的详细信息</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142426.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142426.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142427.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142427.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142428.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142428.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142429.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142429.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>mappedStatement实例</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142433.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142433.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>configuration-final  封装了所有配置文件的信息</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142431.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421142431.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="sqlSession"><a href="#sqlSession" class="headerlink" title="sqlSession"></a>sqlSession</h3><p><strong>返回SQLSession的实现类DefaultSQLSession里面包含了Executer和Configuration</strong></p><p><strong>这一步executer会被创建</strong></p><p><strong>关于拦截器如何包装executer，见mybatis-插件开发</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></tbody></table></figure></div><h4 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171341.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171341.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="步骤详情-1"><a href="#步骤详情-1" class="headerlink" title="步骤详情"></a>步骤详情</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421144640.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421144640.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>openSessionFromDataSource()</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>获取一些信息，创建事务，new Executor（）,然后返回一个DefaultSQLSession</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421144925.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421144925.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>executer创建</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421145752.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421145752.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>cacheExecuter</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421145756.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421145756.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="getMapper"><a href="#getMapper" class="headerlink" title="getMapper"></a>getMapper</h3><p><strong>使用SQLSessionFactory创建一个MapperProxy的代理对象，代理对象里面包含了DefaultSQLSession（executer）</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421151034.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421151034.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="流程图-2"><a href="#流程图-2" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171342.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171342.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="步骤详情-2"><a href="#步骤详情-2" class="headerlink" title="步骤详情"></a>步骤详情</h4><blockquote><p>根据接口类型获取MapperProxyFactory</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153504.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153504.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>创建MapperProxy，他是一个InvocationHandler，返回mapperproxy的代理对象</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153505.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153505.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153939.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421153939.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="查询实现-invoke"><a href="#查询实现-invoke" class="headerlink" title="查询实现 invoke"></a>查询实现 invoke</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book qwe = mapper.queryByIdAndName(<span class="number">3</span>, <span class="string">"疏忽转"</span>);</span><br></pre></td></tr></tbody></table></figure></div><h4 id="流程图-3"><a href="#流程图-3" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171343.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421171343.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160507.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160507.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>参数解析结果</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160616.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160616.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>执行SQLSession的selectOne，实际上是执行selectList</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160908.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421160908.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>代用executer的增删改查</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421161308.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421161308.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>参数的一个封装，传入的如果是一个集合，向map中增加一个collection，如果还是一个list再加list</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421161725.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421161725.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>BoundSql对象封装了SQL语句的详细信息</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162013.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162013.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>缓存中的key模样  各种信息  hash、sql、参数等等</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162239.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162239.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>查询方法</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162526.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162526.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>一级缓存未命中，调用真正的查询方法 queryFromDatabase</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162909.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421162909.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>queryFromDatabase方法，查出数据后保存在本地缓存</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421163210.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421163210.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>doquery    创建statementHandler对象</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421164245.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421164245.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>默认创建一个PrepareStartementHandler对象，<strong>statementType</strong>可以配置</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421165443.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421165443.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>拦截器包装statementHandler</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421165722.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421165722.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>预编译sql产生PrepareStatement、ResultSetHandler对象、调用ParameterHandler设置参数</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421172441.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421172441.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>执行最终查询，使用resultHandler封装结果</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421172810.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421172810.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="查询流程总结"><a href="#查询流程总结" class="headerlink" title="查询流程总结"></a>查询流程总结</h4><ul><li>StatementHandler：处理sql语句预编译，设置参数等相关工作；</li><li>ParameterHandler：设置预编译参数用的</li><li>ResultHandler：处理结果集</li><li>TypeHandler：在整个过程中，进行数据库类型和javaBean类型的映射</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421173350.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210421173350.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="运行原理总结"><a href="#运行原理总结" class="headerlink" title="运行原理总结"></a>运行原理总结</h2><ol><li><p>根据配置文件（全局、sql映射）初始化Configuration对象</p></li><li><p>创建一个DefaultSQLSession对象，里面包含Configuration以及Executer（根据全局配置文件中的defaultExecutertype 创建对应的Executer类型）</p></li><li><p>DefaultSQLSession.getMapper（)拿到mapper接口对应的MapperProxy</p></li><li><p>MapperProxy里面有DefaultSQLSession</p></li><li><p>执行增删改查方法</p><ol><li><p>调用defaultSQLSession的增删改查（Executer）</p></li><li><p>会创建一个statement对象，同时，也会创建Parameterhandler和resulthandler</p></li><li><p>调用statementHandler预编译参数以及设置参数值，使用ParameterHandler对象来给sql设置参数</p></li><li><p>调用statementHandler的增删改查方法</p></li><li><p>使用ResultHandler封装结果</p><p><strong>每个对象创建时都会有一步拦截器包装</strong></p></li></ol></li></ol><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>[<a href="https://github.com/Raptor1998/java_demo]" target="_blank" rel="noopener">https://github.com/Raptor1998/java_demo]</a>(</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/tags/mybatis/"/>
    
  </entry>
  
</feed>
