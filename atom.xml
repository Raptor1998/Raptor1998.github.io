<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raptor&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raptor1998.top/"/>
  <updated>2022-08-14T15:40:24.639Z</updated>
  <id>http://raptor1998.top/</id>
  
  <author>
    <name>陳 ？</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ByteDance New Group</title>
    <link href="http://raptor1998.top/2022/07/10/ByteDance4/"/>
    <id>http://raptor1998.top/2022/07/10/ByteDance4/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-08-14T15:40:24.639Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h2><hr><p>呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p><hr><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142218372.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142218372.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a><br>我的状态完全和樱木刚开始接触篮球一样，啥也不会，自己还挺有想法</p><blockquote><p>如何评价“樱木花道”这个人物？</p></blockquote><blockquote><p>樱木花道从一个自负、无知、单纯而且有点爱惹祸的小年轻，后来因为他心目中的女生晴子小姐而彻底改变了自己，成为一个刻苦上进，最终当上篮球手而且努力使自己做到了“灌篮高手”的境界。</p></blockquote><p>实习到目前已经一个月出头，前面两周都在看文档，熟悉业务，参与回归测试，其实对于自身技术上的成长可以说是几乎没有，只能靠自己探索内部基础工具的实现原理学习技术，毕竟业务这东西，对于目前的工作意义非凡，但对于个人成长来说，更多的还是业务背后的技术沉淀</p><p>第一次独立处理需求，PM是新加坡人，万幸的是她讲中文，还不算难理解，对于测试用例的编写还算有点新的理解，第一次写，更多的还是站在开发的角度去考虑事情，去扣一些极端操作，反而忽略了用户操作，对于功能测试来讲，更多的还是偏重于用户角度，这时其实就在思考测试岗位存在的意义了，毕竟之前在校内开发，写完代码，自测没问题就直接上了，并没有专门的同学把关</p><p>目前收获最大的的是学习需求上线流程，敏捷迭代的各时间点工作</p><h2 id="换线"><a href="#换线" class="headerlink" title="换线"></a>换线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142211306.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142211306.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>本来高高兴兴，ld拉了一个群，群里只有ld、我、mentor和未来的新mentor，就说了一句话，长期支持一下非中机器人的方向，当我看到这个消息和上图表情一模一样，难顶。。。</p><p>SMB的业务还没完全理解，刚处理了两个需求，还都没有完全上线，一个外部依赖，另一个历史逻辑太多，理解的有点慢，现在又要去接触一个新的业务，我这短短几个月的实习里，若是按照目前的强度来看，我这实习期间可能并不会接触多过多的东西</p><h2 id="新业务线"><a href="#新业务线" class="headerlink" title="新业务线"></a>新业务线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142216915.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142216915.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>SMB一共处理了两个需求，还有一个因为外部依赖没能上线，现在新业务线是基础服务，业务好理解，就是智能问答，多轮对话，提供工具，为客增赋能，让销售们更好的、更快的解决问题，类似于辅助型对话机器人</p><h3 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h3><p>问答：通过机器人发起提问，权限以及其他的一些校验通过后，将信息打包给KE，KE进行意图分析（KE可以理解为卧龙为KE提供了训练模型的数据，读书期间研究方向有部分nlp相关，目前在做的主要是自动构建领域KG），KE将分析的数据返回飞书卡片，测试根据会话人的部分、角色等判定是否返回某些FAQ的答案，然后根据用户的交互行为卧龙返回对应数据</p><p>人工：会话服务将从KE获取的用户意图以及用户部门等信息，发送给卧龙后台，卧龙后台查找符合条件的值班客服信息并返回给会话服务</p><p> 多轮对话：目前还没涉及，应该很有意思，根据之前的理解，对于NLP相关的，随着trans(E\H……)系列问世，再加上各类变形，bert等，有简单了解过基于知识图谱的KBQA</p><h3 id="新小组"><a href="#新小组" class="headerlink" title="新小组"></a>新小组</h3><p>随着业务线的更换，mentor也换了，看来是不用回去了，同时过来的还有之前租的rd同学，但是他支持一个月还要回去的。。。</p><p>换座位，周五开完最后一个smb的迭代总结会议，晚上就换座位了，都不认识，基本有问题就问新mentor和之前组的xiayan，最难受的是啥，就是我刚换完座位，立刻就有人坐在了我原来的位置，其实本来应该他过来这边，但是好像因为需求紧急，我来了有一点时间，已经熟悉的差不多了，换组的成本不大，就让我来了，那我只能一遍呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Month1</title>
    <link href="http://raptor1998.top/2022/06/28/ByteDance2/"/>
    <id>http://raptor1998.top/2022/06/28/ByteDance2/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2022-08-14T15:42:11.878Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="入职第四周"><a href="#入职第四周" class="headerlink" title="入职第四周"></a>入职第四周</h1><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p> <a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142146986.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142128353.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>怎么说呢，除了有点卷，没什么个人时间，工作内容不符合我的预期，餐厅吃够了，天天当混子之外，其他的都还可以</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142148721.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142149703.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="业务线"><a href="#业务线" class="headerlink" title="业务线"></a>业务线</h2><p>万万没想到，目前最大的阻碍竟然是英语，面试的时候可没提过这个事，所在的团队是 Non-China 线，小组是 SMB，小微企业的跟进，PM 多是外国人，每日站会他们参与就要用英文，包括新的需求 PRD 以及迭代会议的总结，看我 mentor 之前说的英文不是事，再看看她在站会和迭代上讲的熟练程度，说她英语专业毕业我都信……</p><p>每天九点半左右去吃早餐，准备一下开始新一天的工作，十点半开每日站会，前面几天，每天都用同样的句式，</p><ul><li>Today I will continue to learn basic components and understand general business operations</li><li>Today I will continue to learn basic components and learn agile software development</li><li>learn develop and test process specification</li><li>Today I will write test case for pitch planner and understand interface logic</li><li>learn how to test</li><li>Contact other needs and sort out relevant businesses</li><li>“Living to death” related documents, and alarm learning</li></ul><p>“熟悉文档，学习说啥啥啥”，下迭代我要参与到站会的主持中去，难顶，这个迭代要记录 todo，后续还要参与到火车轮班，虽然现在还知道是啥，盲猜就是服务发布相关的东西</p><p>刚上没几天班，我旁边带我熟悉的军哥晋升奶爸，直接休假都七月多，（写到这赶紧停下来，去买个小礼物，过几天回来恭喜一下）此时就又换了一位组内成员夏嫣带我熟悉业务，前面一周多是以熟悉文档为主，包括几种平台的使用，非常枯燥，实际上的使用还得是在实践中了解，纸上谈兵的看意义不大，甚至没有真正理解；第二三周开始接触业务，跟着夏嫣、凤琳做一些回归测试，熟悉业务为主，目前针对业务的理解，实际上简单概括可以分为几个大角色，广告主、销售，因为是变现中台，按业务模块，简单概括用户管理，线索发现，商机管理，业务跟进，数据分析。目前在接触最多的业务属于定时任务的一块，将一些某些条件的广告主筛选出来，推进某些流程中，由业务进行跟进，可能没有 C 端产品好理解，但都是基于 C 端产品的，Tik Tok 等<br>截止到目前，处理了两个需求，都是和新加坡的 winter 对接的，pitch planner 相关的（这块原本是要我接受的，但是军哥陪产假，没人带着熟悉，所以后续嗯可能接手夏嫣 program 那块），后端改动不大的那种，多是一些前端的改造，通过 Charles 做一些断点即可</p><p>团队内的自动化测试工具，ate，基于 pytest 写的， 在 win 下安装出现了很多独占问题，为了避免后续我本地 win 可以运行，其他人或容器无法运行，又要重新 debug，非常低效，这周申请更换了 mac pro，其实入职申请的就是 mac，只不过不给我</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135241.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然了，虽然工作内容不符合预期，吃的还是不错的，疯狂炫零食饮料，包括其他也可以看很多其他东西的，内部的一些文章，架构都是可以学习的，QA 工作一部分也是要看 RD 代码，所以还是可惜学习一下如何设计的，比如在 shopify program 这块业务线，针对 cronjob 实际上，按照我预想的设计，就只是简单的在容器中设置一个定时任务，但是在实际此处的实现，还是与我想的有差别的，通过自定义注解，将所有将要执行的任务注册进容器中，然后在启动类中实现 CommandLineRunner，每次对定时任务的调度通过任务名实现，可以避免我们单个服务一直占用资源，而且可以随时对任务进行调度，说到这，我再次期间还犯了个错，在第一次进行定时任务测试的时候，将定时任务跑到了线上环境，造成当天的定时任务跑了两次，第二天策略同学火速赶来，应为数据对不上，还好没造成太大影响，不然直接因 P0 事故被开除。此次之后，我就小心了，每次操作前都反复跟组内的人确认，讲真，当时完全是认为工作枯燥，干完收工的一个心态</p><p>在实习期间，还要处理之前学校的项目，进入二期，讲给师弟，完全手把手交，人都麻了，又赶上服务器前移，溜了几个查询语句号让他们上手，将近一个月，毫无进展，当然，维护过程中，还是有收获，比如在 nginx 配置 https，但是此时服务不开放 443 如何解决等问题，说实话，对于此类项目，不该找连几行点吗都没写过的来维护，毕竟真实在用的业务，不断的新需求与更改，可能给后面接手的人造成更大的麻烦</p><h2 id="发钱了"><a href="#发钱了" class="headerlink" title="发钱了"></a>发钱了</h2><p>不说了，按天结算，算不错账<br>字节不打卡，考勤完全自己报，leader 审批通过了就行，问题很大，狗头……可能是怕打卡的话员工搞事，十点上班起点正常下班，but 实际大家上到九点十点，无脑卷，资本家的糖衣炮弹让人疯狂，我直接 反卷先锋 贴在飞书</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135561.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="春游"><a href="#春游" class="headerlink" title="春游"></a>春游</h2><p>竟然是死去的春游，实验室竟然还没忘记春游，现在夏天都快过完了<br>啥峡谷漂流来着，机智如我，有四个小机灵鬼没去，听说有人失温了，那天感觉是最近俩月最冷的一天，十几度吧，加上下雨，收集 n 张票，开了 n 次越野，攀岩 n 次，射击 n 次，</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142145894.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142136693.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance myGroup</title>
    <link href="http://raptor1998.top/2022/06/25/ByteDance5/"/>
    <id>http://raptor1998.top/2022/06/25/ByteDance5/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-08-14T14:56:38.401Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h1><p>从高空看program这块业务，实际上通过cronjob的手段将符合预定条件的广告主添加进某个流程中（Handraiser、payment ready……），并赋予一些相关的状态标签，切换拥有者，为owner添加其目前的分配数量，判断条件来源于tcc</p><p>目前理解的tcc是类似spring cloud config </p><hr><p>从代码层面看，通过定时任务，检索配置，推进流程：实现ApplicationListener&lt; ContextRefreshedEvent&gt;一般被用于在项目初始化动作完成后执行的自己业务拓展动作，作为应用初始化完毕后执行的动作（先InitializingBean）获取加Schedule注解的类，将任务注册进taskRegMap中，实现CommandLineRunner接口，容器启动之后，加载实现类的逻辑资源，已达到完成资源初始化的任务，然后准备执行任务，调用TaskInvoker 的 invoke 方法，从taskRegisterListener中获取任务实例执行：获取TCC配置，不等步长获取需要检测的adv，对获取到的实体进行条件检测，符合条件进行下一步推进</p><h1 id="小组氛围"><a href="#小组氛围" class="headerlink" title="小组氛围"></a>小组氛围</h1><p>组内一共五个人，三位女生，另一位男生休陪产假目前接触还不是很多，前面一周都是跟着junge去吃的，现在恰饭都是我一个人，妈耶，孤单。。。mentor她们喜欢吃盒饭，我觉得有点难顶，所以都是自己去食堂，偶尔她们吃餐厅才会一起。</p><p>感觉mentor怀孕有点不喜欢说话，每次碰到我也不知道说啥玩意好，可能是因为是小组长，不能跟你嬉皮笑脸的吧（狗头保命）</p><p>业务都是我旁边的xiayan在带，人美心善就是她了，感觉还没我年龄大。<br>业务上关键是我啥也不会，问的我都不好意思再问了。。。这里要吐槽一下，字节这内部平台也太多了，而且感觉全是在市面上的工具的改版，功能上可能差不多，但是用法上可能会有很大差距</p><p>这边一般九点下班（2022.8.3半夜前来更新，还没下班。。。麻了），太难了，抛出房租、生活费，希望我的实习期间能剩下个学费的钱。。。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142254091.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142254091.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>希望能在实习过程中，接触更多技术相关的东西，像樱木一样，从初学者到”灌篮高手“在短短几个月完成蜕变</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142253172.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142253172.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Culture</title>
    <link href="http://raptor1998.top/2022/06/20/ByteDance3/"/>
    <id>http://raptor1998.top/2022/06/20/ByteDance3/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-08-14T15:42:08.490Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="始终创业"><a href="#始终创业" class="headerlink" title="始终创业"></a>始终创业</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142151560.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li><p>保持创业心态，始终开创而不守成，创新而非依赖资源</p></li><li><p>敏捷有效，最简化流程，避免简单事情复杂化</p></li><li><p>对外敏锐谦逊，避免自满或优越感</p><h1 id="多元兼容"><a href="#多元兼容" class="headerlink" title="多元兼容"></a>多元兼容</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200521.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></li><li><p>欣赏个体多样性，聚焦人的核心特质</p></li><li><p>全球视角，理解不同文化、观点和实践</p></li><li><p>善意假设，默认开放信任，有效合作</p></li></ul><h1 id="坦诚清晰"><a href="#坦诚清晰" class="headerlink" title="坦诚清晰"></a>坦诚清晰</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200247.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>表达真实想法，不怕暴露问题，反对”向上管理”</li><li>准确、简洁、直接，少用抽象、模糊、空泛的词</li><li>就事论事，理性沟通，避免主观臆测和情绪化表达</li></ul><h1 id="求真务实"><a href="#求真务实" class="headerlink" title="求真务实"></a>求真务实</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201517.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>独立思考，刨根问底，找到本质</li><li>直接体验，深入事实，拿一手数据或信息</li><li>不自嗨，注重实际效果</li></ul><h1 id="敢为极致"><a href="#敢为极致" class="headerlink" title="敢为极致"></a>敢为极致</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201235.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>敢于为了更好的结果明智地冒险，注重整体ROI</li><li>尝试多种可能性，在更大范围里找最优解</li><li>追求卓越，高标准，不仅做了，更要做好</li></ul><h1 id="共同成长"><a href="#共同成长" class="headerlink" title="共同成长"></a>共同成长</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201471.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>相信并认可使命和愿景，基于使命愿景自驱</li><li>面对短期波动有耐心、有韧性，共同解决问题</li><li>持续学习，不设边界，与组织一起成长</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy 为什么需要一把分布式锁？</title>
    <link href="http://raptor1998.top/2022/06/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E6%8A%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/"/>
    <id>http://raptor1998.top/2022/06/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E6%8A%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-08-14T15:40:53.938Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="为什么我们需要一把分布式锁？"><a href="#为什么我们需要一把分布式锁？" class="headerlink" title="为什么我们需要一把分布式锁？"></a>为什么我们需要一把分布式锁？</h1><p>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email（当然这取决于业务应用的容忍度）。</p><p>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，订单重复，超卖或者其它严重的问题。</p><h1 id="分布式锁的三个属性"><a href="#分布式锁的三个属性" class="headerlink" title="分布式锁的三个属性"></a>分布式锁的三个属性</h1><h2 id="互斥（Mutual-Exclusion）"><a href="#互斥（Mutual-Exclusion）" class="headerlink" title="互斥（Mutual Exclusion）"></a>互斥（Mutual Exclusion）</h2><p>这是锁最基本的功能，同一时刻只能有一个客户端持有锁；</p><h2 id="避免死锁（Dead-lock-free）"><a href="#避免死锁（Dead-lock-free）" class="headerlink" title="避免死锁（Dead lock free）"></a>避免死锁（Dead lock free）</h2><p>如果某个客户端获得锁之后花了太长时间处理，或者客户端发生了故障，锁无法释放会导致整个处理流程无法进行下去，所以要避免死锁。最常见的是通过设置一个 TTL(Time To Live，存活时间) 来避免死锁。</p><h2 id="容错（Fault-tolerance）"><a href="#容错（Fault-tolerance）" class="headerlink" title="容错（Fault tolerance）"></a>容错（Fault tolerance）</h2><p>为避免单点故障，锁服务需要具有一定容错性。大体有两种容错方式，一种是锁服务本身是一个集群，能够自动故障切换(ZooKeeper、etcd)；另一种是客户端向多个独立的锁服务发起请求，其中某个锁服务故障时仍然可以从其他锁服务读取到锁信息(Redlock)，代价是一个客户端要获取多把锁，并且要求每台机器的时钟都是一样的，否则 TTL 会不一致，可能有的机器会提前释放锁，有的机器会太晚释放锁，导致出现问题。</p><h1 id="常见的分布式锁实现方案"><a href="#常见的分布式锁实现方案" class="headerlink" title="常见的分布式锁实现方案"></a>常见的分布式锁实现方案</h1><ul><li>redis</li><li>mysql</li><li>zookeeper</li><li>。。。<h1 id="基于redis的分布式锁"><a href="#基于redis的分布式锁" class="headerlink" title="基于redis的分布式锁"></a>基于redis的分布式锁</h1><h2 id="错误的加锁：非原子操作"><a href="#错误的加锁：非原子操作" class="headerlink" title="错误的加锁：非原子操作"></a>错误的加锁：非原子操作</h2>使用redis的分布式锁，我们首先想到的是setnx命令，</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET if Not Exists：</span><br><span class="line">   SETNX lockKey value</span><br><span class="line">   EXPIRE lockKey 30</span><br></pre></td></tr></tbody></table></figure></div><p>使用jedis的客户端代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.setnx(lockKey, val) == 1) {</span><br><span class="line">    jedis.expire(lockKey, timeout);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。<br>加锁和设置超时两个操作是分开的，并非原子操作。假设加锁成功，但是设置锁超时失败，那么该lockKey永不失效。</p><blockquote><p>问题1：为什么这个锁必须要设置一个过期时间？</p></blockquote><p>当一个客户端获取锁成功之后，假如它崩溃了，或者它忘记释放锁，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了</p><blockquote><p>问题2：这个锁的有效时间设置多长比较合适？</p></blockquote><p>前面这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。看来真是个两难的问题。</p><h2 id="正确的加锁姿势"><a href="#正确的加锁姿势" class="headerlink" title="正确的加锁姿势"></a>正确的加锁姿势</h2><p>Redis客户端为了获取锁，向Redis节点发送如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lockKey requestId NX PX 30000</span><br></pre></td></tr></tbody></table></figure></div><p>lockKey 是加锁的锁名；<br>requestId 是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的；（下面会分析它的作用）<br>NX 表示只有当lockKey对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁；<br>PX 30000 设置过期时间，表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</p><p>在java中使用jedis包的调用方法是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime)</span><br></pre></td></tr></tbody></table></figure></div><p><strong>问题：为什么要设置一个随机字符串requestId？如果没有会出现什么问题？</strong></p><p>下面释放锁的时候给出答案。</p><h2 id="依赖redis超时自动释放锁的问题"><a href="#依赖redis超时自动释放锁的问题" class="headerlink" title="依赖redis超时自动释放锁的问题"></a>依赖redis超时自动释放锁的问题</h2><p>如果按照如下方式加锁：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);</span><br><span class="line">if ("OK".equals(result)) {</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>加锁之后，每次都会到expireTime之后才会释放锁，哪怕业务使用完这把锁了。所以更合理的做法是：</p><p>1、加锁；</p><p>2、业务操作；</p><p>3、主动释放锁；</p><p>4、如果主动释放锁失败了，则达到超时时间，redis自动释放锁。</p><p>暂时无法在飞书文档外展示此内容</p><p>如何释放锁呢？java代码里在finally中释放锁，即无论代码执行成功或者失败，都要释放锁。</p><p>try{<br>    String result = jedis.set(lockKey, requestId, “NX”, “PX”, expireTime);<br>    if (“OK”.equals(result)) {<br>        return true;<br>    }<br>    return false;<br>} finally {<br>    unlock(lockKey);<br>}</p><h2 id="释放了别人的锁"><a href="#释放了别人的锁" class="headerlink" title="释放了别人的锁"></a>释放了别人的锁</h2><p>上面那个unlock(lockKey)代码释放锁有什么问题？可能会出现释放别人的锁的问题。</p><p>有的同学可能会反驳：线程A获取了锁之后，它要是没有释放锁，这个时候别的线程假如线程B、C……根本不可能获取到锁，何来释放别人锁之说？</p><p>暂时无法在飞书文档外展示此内容</p><p>【1】客户端1获取锁成功。</p><p>【2】客户端1在某个操作上阻塞了很长时间。</p><p>【3】过期时间到了，锁自动释放了。</p><p>【4】客户端2获取到了对应同一个资源的锁。</p><p>【5】客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</p><p>【6】另外线程客户端3此时可以成功请求到锁</p><p>如何解决这个问题：自己只能释放自己加的锁，不允许释放别人加的锁！</p><p>前面使用set命令加锁的时候，除了使用lockKey锁标识之外，还使用了一个requestId，这个requestId的作用是什么呢？</p><p>requestId是在释放锁的时候用的！！！</p><p>伪代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.get(lockKey).equals(requestId)) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>所以在释放锁的时候，先要获取到该锁的值（就是每个加锁线程自己设置的requestId），然后判断跟之前自己设置的值是否相同，如果相同才允许删除锁，返回成功，如果不同，直接返回失败。</p><p><strong>问题：为什么要设置一个随机字符串requestId？如果没有会出现什么问题？</strong></p><p>设置一个随机字符串requestId是必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能导致释放别人的锁。所以要保证requestId全局唯一。</p><h2 id="释放锁的问题：非原子操作"><a href="#释放锁的问题：非原子操作" class="headerlink" title="释放锁的问题：非原子操作"></a>释放锁的问题：非原子操作</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.get(lockKey).equals(requestId)) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>显然，jedis.get(lockKey).equals(requestId) 这行代码包含了【获取该锁的值】，【判断是否是自己加的锁】，【删除锁】这三个操作，万一这三个操作中间的某个时刻出现阻塞</p><p>暂时无法在飞书文档外展示此内容<br>【1】客户端1获取锁成功；<br>【2】客户端1进行业务操作；<br>【3】客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。<br>【4】客户端1判断随机字符串的值，与预期的值相等。<br>【5】客户端1由于某个原因阻塞住了很长时间。<br>【6】过期时间到了，锁自动释放了。<br>【7】客户端2获取到了对应同一个资源的锁。<br>【8】客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</p><p>实际上，如果不是客户端1阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>问题的根源：锁的判断在客户端，但是锁的删除却在服务端！</p><h2 id="正确的释放锁姿势"><a href="#正确的释放锁姿势" class="headerlink" title="正确的释放锁姿势"></a>正确的释放锁姿势</h2><p>正确的释放锁姿势——锁的判断和删除都在服务端（redis），使用lua脚本保证原子性：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure></div><p>这段Lua脚本在执行的时候要把前面的requestId作为ARGV[1]的值传进去，把lockKey作为KEYS[1]的值传进去。</p><p>释放锁的操作为什么要使用lua脚本？<br>释放锁其实包含三步操作：’GET’、判断和’DEL’，用Lua脚本来实现能保证这三步的原子性。</p><h2 id="锁超时问题"><a href="#锁超时问题" class="headerlink" title="锁超时问题"></a>锁超时问题</h2><p>如果客户端1请求锁成功了，但是由于业务处理、GC、操作系统等原因导致它处理时间过长，超过了锁的时间，这时候redis会自动释放锁，这种情况可能导致问题：</p><p>如何解决这种问题？</p><p>—- 续期，java里我们可以使用TimerTask类来实现自动续期的功能，伪代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer();</span><br><span class="line">timer.schedule(new TimerTask() {</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Timeout timeout) throws Exception {</span><br><span class="line">        //自动续期逻辑􁛔􀛖􁖅􀹗􁭦􁬋</span><br><span class="line">    }</span><br><span class="line">}, 10000, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure></div><p>这个机制在redisson框架中已经实现，而且还有一个比较霸气的名字watchdog（看门狗）：加锁时没有指定加锁时间时会启用watchdog机制，默认加锁30秒，每10秒钟检查一次，如果存在就重新设置 过期时间为30秒（即30秒之后它就不再续期了）</p><p>lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</p><p>默认值：30000</p><p>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用leaseTimeout参数的情况。如果该看门狗未使用lockWatchdogTimeout去重新调整一个分布式锁的</p><p>lockWatchdogTimeout超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</p><h1 id="Redis主从架构数据同步复制问题"><a href="#Redis主从架构数据同步复制问题" class="headerlink" title="Redis主从架构数据同步复制问题"></a>Redis主从架构数据同步复制问题</h1><p>我们通常使用「Redis Cluster」或者「哨兵模式」这两种方式实现redis的高可用，而这两种方式都是基于「主从架构数据同步复制」实现的，而redis默认的主从复制是异步的。</p><p>前面铺垫的redis锁在单点实例中是没有问题的，因为并没有涉及redis的高可用部署架构细节。但是如果多实例的情况下会出现什么问题呢？比如：主从、或者使用了哨兵模式、或者redis cluster。redis的主从架构如下所示：</p><p>Redis所有的写操作都是先在Master上操作，然后同步更新到Slave上，Slave只能读不能写。<br>丢失数据场景：当网络发生脑裂（split-brain）或者partitioned cluster集群分裂为多数派与少数派，如果数据继续写入少数派的Master，则当Cluster感知，并停止少数派Master，或者重新选主时，则面临丢失刚才已写入少数派的数据</p><p>主从发生重新选导致分布式锁出现问题的场景：<br>暂时无法在飞书文档外展示此内容</p><h1 id="WAIT命令能够为Redis实现强一致吗？"><a href="#WAIT命令能够为Redis实现强一致吗？" class="headerlink" title="WAIT命令能够为Redis实现强一致吗？"></a>WAIT命令能够为Redis实现强一致吗？</h1><p>WAIT numreplicas timeout </p><p>numreplicas：指定副本（slave）的数量。</p><p>timeout：超时时间，时间单位为毫秒；当设置为0 时，表示无限等待，即用不超时。</p><p>WAIT命令作用：WAIT 命令阻塞当前客户端，直到所有先前的写入命令成功传输，并且由至少指定数量的副本（slave）确认。在主从、sentinel和Redis群集故障转移中， WAIT能够增强（仅仅是增强，但不是保证）数据的安全性。</p><p>官方文档：<a href="https://redis.io/commands/wait" target="_blank" rel="noopener">https://redis.io/commands/wait</a></p><p>结论： WAIT 不能保证 Redis 的强一致性</p><h1 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h1><p>针对上面的问题，redis之父antirez设计了Redlock算法，Redlock的算法描述就放在Redis的官网上：<br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></p><p>在Redlock之前，很多人对于分布式锁的实现都是基于单个Redis节点的。而Redlock是基于多个Redis节点（都是Master）的一种实现。前面基于单Redis节点的算法是Redlock的基础。<br>加锁<br>Redlock算法基于N个完全独立的Redis节点，客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>【1】获取当前时间T1（毫秒数）。</p><p>【2】使用相同的key、value按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。</p><p>【3】获取当前时间T2减去步骤1中的T1，计算获取锁消耗了多长时间（T3= T2-T1），计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（大于等于 N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>【4】如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>【5】如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>注意！！！：redLock会直接连接多个redis主节点，不是通过集群机制连接的。<br>RedLock的写与主从集群无关，直接操作的是所有主节点，所以才能避开主从故障切换时锁丢失的问题。</p><h2 id="失败重试（脑裂问题）"><a href="#失败重试（脑裂问题）" class="headerlink" title="失败重试（脑裂问题）"></a>失败重试（脑裂问题）</h2><p>高并发场景下，当多个加锁线程并发抢锁时，可能导致脑裂，最终造成任何一个线程都无法抢到锁的情况。<br>暂时无法在飞书文档外展示此内容所以当一个加锁线程无法获得锁的时候，应该在一个随机延时后再一次尝试获得锁。加锁线程从多数redis实例中获得锁越快，出现脑裂的窗口越小（重试的次数也越少）。所以理想情况下，加锁线程应该多路复用地同时向N个实例发送加锁命令。</p><p>值得强调的是，如果获取大部分锁失败，加锁线程应该尽可能快的释放（部分）已经获得了的锁。所以为了让锁能够再次被获得就没有必要等待key过期（然而如果发生了网络分区导致客户端无法再与redis实例交互，那么就必须等待key过期才能重新抢到锁）。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>Redlock算法释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><blockquote><p>问题1：为什么要在多个实例上加锁？<br>本质上为了容错，部分实例异常宕机，剩余实例只要超过N/2+1依旧可用。多个实例节点，实际上构建了一个分布式锁系统。分布式系统中，总会有异常节点，所以需要考虑异常节点达到多少个，也不会影响整个系统的正确性。（可以参考一下拜占庭将军问题的分析）</p></blockquote><blockquote><p>问题2：为什么步骤3加锁成功之后，还要计算加锁的累计耗时？<br>因为加锁操作的针对的是分布式中的多个节点，所以耗时肯定是比单个实例耗时更久，至少需要N/2+1个网络来回，还要考虑网络延迟、丢包、超时等情况发生，网络请求次数越多，异常的概率越大。<br>所以即使N/2+1个节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那么此时的锁已经没有意义了。</p></blockquote><blockquote><p>问题3：为什么释放锁，要操作所有节点，对所有节点都释放锁？<br>因为当对某一个redis节点加锁时，可能因为网络原因导致加锁“失败”。注意这个“失败”，指的是redis节点实际已经加锁成功了，但是返回的结果因为网络延迟并没有传到加锁的线程，被加锁线程丢弃了，加锁线程误以为没有成功，于是加锁线程去尝试下一个节点了。</p></blockquote><p>所以释放锁的时候，不管以前有没有加锁成功，都要释放所有节点的锁，以保证清除节点上述图中发生的情况导致残留的锁。</p><p>崩## 溃恢复（AOF持久化）对Redlock算法影响</p><p>假设Rodlock算法中的redis发生了崩溃-恢复，那么锁的安全性将无法保证。假设加锁线程在5个实例中对其中3个加锁成功，获得了这把分布式锁，这个时候3个实例中有一个实例被重启了。重启后的实例将丢失其中的锁信息，这个时候另一个加锁线程可以对这个实例加锁成功，此时两个线程同时持有分布式锁。锁的安全性被破坏。</p><p>暂时无法在飞书文档外展示此内容如果我们配置了AOF持久化，只能减少它发生的概率而无法保证锁的绝对安全。断电的场景下，如果redis被配置了默认每秒同步数据到硬盘，重启之后lockKey可能会丢失，理论上，如果我们想要保证任何实例重启的情况下锁都是安全的，需要在持久化配置中设置<br>fsync=always，但此时redis的性能将大大打折扣。</p><p>为了保证这一点，我们只需要让一个崩溃时间、不可用时间（实例崩溃后存在的锁的所有key所需的时间）比最大TTL还要长的实例变成非法和自动释放的。<br>如果不配置redis持久化，那么只能使用延迟重启保证锁的安全性。</p><p>结论：为了保证Redlock算法的安全性，有如下两种手段</p><h2 id="持久化配置中设置"><a href="#持久化配置中设置" class="headerlink" title="持久化配置中设置"></a>持久化配置中设置</h2><p>fsync=always，性能大大降低<br>恰当的运维，把崩溃节点进行延迟重启，超过崩溃前所有锁的</p><p>TTL时间之后才加入Redlock节点组<br>redis分布式锁官方文档翻译</p><h2 id="Redlock算法存在的问题"><a href="#Redlock算法存在的问题" class="headerlink" title="Redlock算法存在的问题"></a>Redlock算法存在的问题</h2><p>Redlock论战：Martin Kleppmann vs. Antirez<br>Martin Kleppmann是剑桥大学的分布式系统专家，《数据密集型应用系统设计》一书的作者。<br>Antirez 是redis的作者，redlock算法的作者。<br>Redis之父Antirez实现Redlock算法之后。有一天，Martin Kleppmann写了一篇blog，分析了Redlock在安全性上存在的一些问题。然后Redis的作者立即写了一篇blog来反驳Martin的分析。但Martin表示仍然坚持原来的观点。随后，这个问题在Twitter和Hacker News上引发了激烈的讨论，很多分布式系统的专家都参与其中。</p><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a><br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a><br><a href="http://antirez.com/news/101" target="_blank" rel="noopener">http://antirez.com/news/101</a></p><p>Martin Kleppmann在2016-02-08这一天发表了一篇blog，名字叫“How to do distributed locking”，地址如下：<br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p><p>Martin在这篇文章中谈及了分布式系统的很多基础性的问题（特别是分布式计算的异步模型），对分布式系统的从业者来说非常值得一读。这篇文章大体可以分为两大部分：<br>前半部分，与Redlock无关。Martin指出，即使我们拥有一个完美实现的分布式锁（带自动过期功能），在没有共享资源参与进来提供某种fencing机制的前提下，我们仍然不可能获得足够的安全性。<br>后半部分，是对Redlock本身的批评。Martin指出，由于Redlock本质上是建立在一个同步模型之上，对系统的记时假设(timing assumption)有很强的要求，因此本身的安全性是不够的。<br>客户端长期阻塞导致锁过期<br>首先我们讨论一下前半部分的关键点。Martin给出了下面这样一份时序图：</p><p>在上面的时序图中，假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。上图中出现的lease这个词可以暂且认为就等同于一个带有自动过期功能的锁。客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p><p>初看上去，有人可能会说，既然客户端1从GC pause中恢复过来以后不知道自己持有的锁已经过期了，那么它可以在访问共享资源之前先判断一下锁是否过期。但仔细想想，这丝毫也没有帮助。因为GC pause可能发生在任意时刻，也许恰好在判断完之后。<br>也有人会说，如果客户端使用没有GC的语言来实现，是不是就没有这个问题呢？Martin指出，系统环境太复杂，仍然有很多原因导致进程的pause，比如虚存造成的缺页故障(page fault)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果。<br>总结起来就是说，即使锁服务本身是没有问题的，而仅仅是客户端有长时间的pause或网络延迟，仍然会造成两个客户端同时访问共享资源的冲突情况发生。而这种情况其实就是我们在前面已经提出来的“客户端长期阻塞导致锁过期”的那个疑问。<br>解决方案——fencing token<br>那怎么解决这个问题呢？Martin给出了一种方法，称为fencing token。fencing token是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图：</p><p>在上图中，客户端1先获取到的锁，因此有一个较小的fencing token，等于33，而客户端2后获取到的锁，有一个较大的fencing token，等于34。客户端1从GC pause中恢复过来之后，依然是向存储服务发送访问请求，但是带了fencing token = 33。存储服务发现它之前已经处理过34的请求，所以会拒绝掉这次33的请求。这样就避免了冲突。<br>（问题：考虑网络延迟导致33号token比34号先到的情景）<br>时间跳跃<br>Martin在文中构造了一些事件序列，能够让Redlock失效（两个客户端同时持有锁）。为了说明Redlock对系统记时(timing)的过分依赖，他首先给出了下面的一个例子（还是假设有5个Redis节点A, B, C, D, E）：<br>客户端1从Redis节点A, B, C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。<br>节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。<br>客户端2从Redis节点C, D, E成功获取了同一个资源的锁（多数节点）。<br>客户端1和客户端2现在都认为自己持有了锁。<br>上面这种情况之所以有可能发生，本质上是因为Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了了。Martin在这里其实是要指出分布式算法研究中的一些基础性问题，或者说一些常识问题，即好的分布式算法应该基于异步模型(asynchronous model)，算法的安全性不应该依赖于任何记时假设(timing assumption)。在异步模型中：进程可能pause任意长的时间，消息可能在网络中延迟任意长的时间，甚至丢失，系统时钟也可能以任意方式出错。一个好的分布式算法，这些因素不应该影响它的安全性(safety property)，只可能影响到它的活性(liveness property)，也就是说，即使在非常极端的情况下（比如系统时钟严重错误），算法顶多是不能在有限的时间内给出结果而已，而不应该给出错误的结果。这样的算法在现实中是存在的，像比较著名的Paxos，或Raft。但显然按这个标准的话，Redlock的安全性级别是达不到的。</p><p>在Martin的这篇文章中，还有一个很有见地的观点，就是对锁的用途的区分。他把锁的用途分为两种：<br>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email。<br>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其它严重的问题。<br>最后，Martin得出了如下的结论：<br>如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock则是个过重的实现(heavyweight)。<br>如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。而且，它没有一个机制能够提供fencing token。那应该使用什么技术呢？Martin认为，应该考虑类似Zookeeper的方案，或者支持事务的数据库。<br>Martin对Redlock算法的形容是：<br>neither fish nor fowl （不伦不类）</p><p>【其它疑问】<br>Martin提出的fencing token的方案，需要对提供共享资源的服务进行修改，这在现实中可行吗？<br>根据Martin的说法，看起来，如果资源服务器实现了fencing token，它在分布式锁失效的情况下也仍然能保持资源的互斥访问。这是不是意味着分布式锁根本没有存在的意义了？<br>资源服务器需要检查fencing token的大小，如果提供资源访问的服务也是包含多个节点的（分布式的），那么这里怎么检查才能保证fencing token在多个节点上是递增的呢？<br>Martin对于fencing token的举例中，两个fencing token到达资源服务器的顺序颠倒了（小的fencing token后到了），这时资源服务器检查出了这一问题。如果客户端1和客户端2都发生了GC pause，两个fencing token都延迟了，它们几乎同时到达了资源服务器，但保持了顺序，那么资源服务器是不是就检查不出问题了？这时对于资源的访问是不是就发生冲突了？</p><p>1、问题一：节点重启<br>N个Redis节点中如果有节点发生崩溃重启，会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。参考上面的“崩溃恢复（AOF持久化）对Redlock算法影响”分析。<br>【备注】在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。</p><p>如何解决这个问题？<br>redis之父antirez提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><p>2、问题二：时钟变迁<br>Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了了。<br>结论：redis的过期时间是依赖系统时钟的，如果时钟漂移过大时会影响到过期时间的计算。<br>为什么系统时钟会存在漂移呢？先简单说下系统时间，linux提供了两个系统时间：clock realtime和clock monotonic<br>clock realtime</p><p>也就是xtime/wall time，这个时间是可以被用户改变的，被NTP改变。redis的判断超时使用的gettimeofday函数取的就是这个时间，redis的过期计算用的也是这个时间。参考<a href="https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time.html" target="_blank" rel="noopener">https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time.html</a><br>clock monotonic</p><p>，直译过来是单调时间，不会被用户改变，但是会被NTP改变。<br>最理想的情况是：所有系统的时钟都时时刻刻和NTP服务器保持同步，但这显然是不可能的。<br>clock realtime可以被人为修改，在实现分布式锁时，不应该使用clock realtime。不过很可惜，redis使用的就是这个时间，Redis 5.0使用的还是clock realtime。Antirez说过后面会改成clock monotonic的。也就是说，人为修改redis服务器的时间，就能让redis出问题了。<br>暂时无法在飞书文档外展示此内容<br>【1】加锁线程1从节点Redis1, Redis2, Redis3成功获取了锁（多数节点）。由于网络问题，与Redis4、Redis5通信失败。<br>【2】节点Redis3上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。<br>【3】加锁线程2从Redis3, Redis4, Redis5成功获取了同一个资源的锁（多数节点）。<br>【4】加锁线程1和加锁线程2现在都认为自己持有了锁。</p><p>什么情况下会发生时钟变迁？<br>人为修改了时钟<br>从NTP服务收到了一个大的时钟更新事件导致时钟漂移<br>闰秒（是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中或者季末对协调世界时增加或减少1秒的调整，此时一分钟为59秒或者61秒，闰秒曾使许多大型系统崩溃）<br>……</p><p>如何解决这个问题？<br>（1）redis之父antirez在redlock论战中的解释：实际系统中是可以避免大的时钟跳跃的。当然，这取决于基础设施和运维方式。（实际上这种理想情况是很难达到的，不同的redis节点，毫秒级别的时间误差几乎是必然存在的。）<br>（2）Fencing token机制：类似raft算法、zab协议中的全局递增数字，对这个token的校验需要后端资源进行校验，如此一来，相当于后端资源具备了互斥机制，这种情况下为什么还要一把分布式锁呢？而且涉及到后端资源的改造。</p><p>总结<br>RedLock算法数建立在了 Time 是可信的模型上的一种分布式锁，所以时间被破坏的情况下它无法实现锁的绝对安全；<br>RedLock算法实现比较复杂，并且性能比较差；<br>RedLock需要恰当的运维保障它的正确性，故障-崩溃之后需要一套延迟重启的机制</p><p>RedLock的核心价值，在于多数派思想。相比于基于单点Redis的锁服务，RedLock解决了锁数据写入时多份的问题，从而可以克服单点故障下的数据一致性问题。在继承自基于单点的Redis锁服务缺陷（解锁不具备原子性；锁服务、调用方、资源方缺乏确认机制）的基础上，其核心的问题为：缺乏锁数据丢失的识别和感知机制。<br>RedLock中的每台Redis，充当的仍旧只是存储锁数据的功能，每台Redis之间各自独立，单台Redis缺乏全局的信息，自然也不知道自己的锁数据是否是完整的。在单台Redis数据的不完整的前提下，没有分布式共识机制，使得在各种分布式环境的典型场景下（结点故障、网络丢包、网络乱序），没有完整数据但参与决策，从而破坏数据一致性。</p><p>基于Mysql的分布式锁（ShedLock）<br>使用ShedLock需要在Mysql数据库创建一张加锁用的表：<br>CREATE TABLE shedlock<br>(<br>    name VARCHAR(64),<br>    lock_until TIMESTAMP(3) NULL,<br>    locked_at TIMESTAMP(3) NULL,<br>    locked_by VARCHAR(255),<br>    PRIMARY KEY (name)<br>)</p><p>加锁<br>通过插入同一个name(primary key)，或者更新同一个name来抢，对应的intsert、update的SQL为：</p><p>INSERT INTO shedlock<br>(name, lock_until, locked_at, locked_by)<br>VALUES<br>(锁名字,  当前时间+最多锁多久,  当前时间, 主机名)<br>UPDATE shedlock<br>SET lock_until = 当前时间+最多锁多久,<br>locked_at = 当前时间,<br>locked_by = 主机名 WHERE name = 锁名字 AND lock_until &lt;= 当前时间 </p><p>释放锁：<br>通过设置lock_until来实现释放，再次抢锁的时候需要通过lock_util来判断锁失效了没。对应的SQL为：<br>UPDATE shedlock<br>SET lock_until = lockTime WHERE name = 锁名字<br>问题分析<br>1、单点问题；<br>2、主从同步问题。假如使用全同步模式，分布式锁将会有性能上的问题。</p><p>基于zookeeper的分布式锁<br>zookeeper的节点类型<br>Zookeeper的数据存储结构就像一棵树，这棵树由节点组成，这种节点叫做Znode。Znode分为四种类型：<br>持久节点 （PERSISTENT）</p><p>默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。<br>持久节点顺序节点（PERSISTENT_SEQUENTIAL）</p><p>所谓顺序节点，就是在创建节点时，Zookeeper根据创建的顺序给该节点名称进行编号：<br>临时节点（EPHEMERAL）</p><p>和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除：<br>临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><p>【使用该类型节点实现分布式锁】<br>顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。<br>zookeeper的watch机制<br>zookeeper集群和客户端通过长连接维护一个session，当客户端试图创建/lock节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此返回获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。这样的特性redis的Redlock就无法实现。<br>暂时无法在飞书文档外展示此内容</p><p>加锁&amp;释放锁<br>客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。<br>持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。（<br>客户端删除锁）<br>znode应该被创建成<br>EPHEMERAL_SEQUENTIAL的。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除，。这保证了锁一定会被释放（zookeeper服务器自己删除锁）。另外保证了公平性，后面创建的节点会加在节点链最后的位置，等待锁的客户端会按照先来先得的顺序获取到锁。</p><p>暂时无法在飞书文档外展示此内容<br>惊群效应：错误的实现——如果实现zookeeper分布式锁的时候，所有后加入的节点都监听最小的节点。那么删除节点的时候，所有客户端都会被唤醒，这个时候由于通知的客户端很多，通知操作会造成zookeeper性能突然下降，这样会影响zookeeper的使用。<br>时钟变迁问题Zookeeper不依赖全局时间，它使用zab协议实现分布式共识算法，不存在该问题。<br>超时导致锁失效问题Zookeeper不依赖有效时间，它依靠心跳维持锁的占用状态，不存在该问题。</p><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但仔细考察的话，并不尽然。客户端可以删除锁，zookeeper服务器也可以删除锁，会引发什么问题。<br>zookeeper是怎么检测出某个客户端已经崩溃了呢？<br>实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>基于zookeeper的分布式锁存在的问题：<br>【1】客户端1创建了znode节点/lock，获得了锁。<br>【2】客户端1进入了长时间的GC pause。（或者网络出现问题、或者zk服务检测心跳线程出现问题等等）<br>【3】客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。<br>【4】客户端2创建了znode节点/lock，从而获得了锁。<br>【5】客户端1从GC pause中恢复过来，它仍然认为自己持有锁。<br>这个场景下，客户端1和客户端2在一段窗口时间内同时获取到锁。</p><p>结论：使用zookeeper的临时节点实现的分布式锁，它的锁安全期是在客户端取得锁之后到zk服务器会话超时的阈值（跨机房部署很容易出现）的时间之间。它无法设置占用分布式锁的时间，何时zk服务器会删除锁是不可预知的，所以这种方式它比较适合一些客户端获取到锁之后能够快速处理完毕的场景。</p><p>另一种方案<br>另外一种使用zk作分布式锁的实现方式：不使用临时节点，而是使用持久节点加锁，把zk集群当做一个mysql、或者一个单机版的redis，加锁的时候存储锁的到期时间，这种方案把锁的删除、判断过期这两个职责交给客户端处理。（当做一个可以容错的mysql，性能问题！）</p><p>ZooKeeper分布式锁的优点和缺点<br>总结一下ZooKeeper分布式锁：<br>优点：<br>（1）ZooKeeper分布式锁基于分布式一致性算法实现，能有效的解决分布式问题，不受时钟变迁影响，不可重入问题，使用起来也较为简单；<br>（2）当锁持有方发生异常的时候，它和Zookeeper之间的session无法维护。Zookeeper会在Session租约到期后，自动删除该Client持有的锁，以避免锁长时间无法释放而导致死锁。<br>缺点：<br>ZooKeeper实现的分布式锁，性能并不太高。为啥呢？因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同步不到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。<br>总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用特性，所以在并发量不是太高的场景，推荐使用ZooKeeper的分布式锁。</p><p>小结一下，基于ZooKeeper的锁和基于Redis的锁相比在实现特性上有两个不同：<br>在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。<br>基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。</p><p>Chubby<br>提到分布式锁，就不能不提Google的Chubby。<br>Chubby是Google内部使用的分布式锁服务，有点类似于ZooKeeper，但也存在很多差异。Chubby对外公开的资料，主要是一篇论文，叫做“The Chubby lock service for loosely-coupled distributed systems”，下载地址如下：<br><a href="https://research.google.com/archive/chubby.html" target="_blank" rel="noopener">https://research.google.com/archive/chubby.html</a></p><p>另外，YouTube上有一个的讲Chubby的talk，也很不错，播放地址：<br><a href="https://www.youtube.com/watch?v=PqItueBaiRg&amp;feature=youtu.be&amp;t=487" target="_blank" rel="noopener">https://www.youtube.com/watch?v=PqItueBaiRg&amp;feature=youtu.be&amp;t=487</a></p><p>Chubby自然也考虑到了延迟造成的锁失效的问题。论文里有一段描述如下：<br>a process holding a lock L may issue a request R, but then fail. Another process may ac- quire L and perform some action before R arrives at its destination. If R later arrives, it may be acted on without the protection of L, and potentially on inconsistent data.<br>（译文： 一个进程持有锁L，发起了请求R，但是请求失败了。另一个进程获得了锁L并在请求R到达目的方之前执行了一些动作。如果后来请求R到达了，它就有可能在没有锁L保护的情况下进行操作，带来数据不一致的潜在风险。）<br>这跟前面Martin的分析大同小异。</p><p>Chubby给出的用于解决（缓解）这一问题的机制称为sequencer，类似于fencing token机制。锁的持有者可以随时请求一个sequencer，这是一个字节串，它由三部分组成：<br>锁的名字。</p><p>锁的获取模式（排他锁还是共享锁）。</p><p>lock generation number（一个64bit的单调递增数字）。作用相当于fencing token或epoch number。</p><p>sequencer：客户端拿到sequencer之后，在操作资源的时候把它传给资源服务器。然后，资源服务器负责对sequencer的有效性进行检查。检查可以有两种方式：<br>调用Chubby提供的API，<br>CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效。<br>将客户端传来的sequencer与资源服务器当前观察到的<br>最新的sequencer进行对比检查。可以理解为与Martin描述的对于fencing token的检查类似。<br>锁延期机制：当然，如果由于兼容的原因，资源服务本身不容易修改，那么Chubby还提供了一种机制：<br>lock-delay</p><p>。Chubby允许客户端为持有的锁指定一个lock-delay的时间值（默认是1分钟）。当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空(draining the queue)，尽量防止出现延迟到达的未处理请求。</p><p>可见，为了应对锁失效问题，Chubby提供的两种处理方式：CheckSequencer()检查与上次最新的sequencer对比、lock-delay，它们对于安全性的保证是从强到弱的。而且，这些处理方式本身都没有保证提供绝对的正确性(correctness)。但是，Chubby确实提供了单调递增的lock generation number，这就允许资源服务器在需要的时候，利用它提供更强的安全性保障。</p><p>总结起来，Chubby引入了资源方和锁服务的验证，来避免了锁服务本身孤立地做预防死锁机制而导致的破坏锁安全性的风险。同时依靠Session来维持锁的持有状态，在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。</p><p>总结<br>（1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；<br>（2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。<br>（3）基于mysql的分布式锁一般均有单点问题，高并发场景下对数据库的压力比较大；</p><p>需要考虑的问题：我们的业务对极端情况的容忍度，为了一把绝对安全的分布式锁导致过度设计，引入的复杂性和得到的收益是否值得。</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Day1</title>
    <link href="http://raptor1998.top/2022/06/07/ByteDance1/"/>
    <id>http://raptor1998.top/2022/06/07/ByteDance1/</id>
    <published>2022-06-06T16:00:00.000Z</published>
    <updated>2022-08-14T11:47:03.839Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="一面5-16"><a href="#一面5-16" class="headerlink" title="一面5.16"></a>一面5.16</h2><p>具体细节内容忘了，只有几个深刻的，spring中的循环依赖问题，随便背了一下，然后简单分析一二三级的实现方式，算法是最长公共子串，对于这俩问题，我只能说测开何苦为难测开啊，还好我简单看过spring这块</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843526.jpg" data-fancybox="group" data-caption="kabuxiaqu" class="fancybox"><img alt="kabuxiaqu" title="kabuxiaqu" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843526.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>redis的big key有什么影响，项目中的最后上线的架构，mq消息堆积问题，最后问了个测试用例设计，反问了工作内容，不是点点点吧，回答我说：要是只是测试，你觉得我会问你这么多内容吗</p><h2 id="二三四面5-19"><a href="#二三四面5-19" class="headerlink" title="二三四面5.19"></a>二三四面5.19</h2><p>效率直接起飞，二面结束直接问我有时间吗，进行三面，三面结束hr直接电话问有时间吗，聊聊……，从两点到五点半，中间还穿插了一个其他厂的hr面，累够呛</p><p>二面leader面，没啥有印象的题目，只记得写了好多sql，无非就是group by，left join……算法忘了……最后同样反问工作内容，又随便聊了点别的，leader还亮了亮纹身</p><p>三面交叉，首先震惊，竟然是个女的，问我怎么封装一个http工具，说了半天没说明白，差点怼起来……说平时看我用mybatis，问都用来干什么，直接开始XX，内心狂喜，</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/202208141921214.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/202208141921214.gif" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>刚写过一个简单的mybatis，没讲干啥，讲了下怎么实现mybatis<br>最后算法感觉走过场吧，给你一个数组，统计次数出现最多的那个数……讲了个hashmap的实现以及空间换时间的实现，我想手写第二种思路，她让我写hashmap的吧<br>不得不说，得书的在线coding做的还是不错的，比牛客、力扣好用一万倍<br>hr面反正就问一下经历以及实习时间，啥时候入职，希望能快点入职，最后就说去和业务确认一下，然后就审批offer了</p><h1 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141943550.jpg" data-fancybox="group" data-caption="华夏之心" class="fancybox"><img alt="华夏之心" title="华夏之心" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141943550.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>der der的就去了八方城，入职填的mac，领到手的确实thinkpad，然后前往华夏之心</p><p> <a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843477.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843477.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>头两天没租房子，准备随时跑路，毕竟测开，手里还有几份开发的offer，这个时候华为要是给了我offer，我就去华子了，可惜他晚了几天，这里必须得点名一下体面厂，4月我都躺平了，准备就体面厂混个实习了，然后五一过完，跟我说实习发不了offer，毁约，我就又去投了一份暑期超新星，两轮面完，我又通过了（滑稽），我直接接了offer，准备鸽他</p><p> <a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843535.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141843535.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>入职第一天，啥也没干，mentor oneone画饼，mentor画完leader oneone画，说后续参与到什么什么的开发中，至少到写这个的时候我还没参与进去……不知道后续<br>就觉得 饭还可以，下午茶也不错</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141944577.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141944577.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>入职赶上6.1儿童节，领了个儿童节大礼包，瑜伽、跳绳二选一，下午茶小手表，棒棒糖等一系列小朋友礼物……<br>入职第二天，赶上端午节假期，端午大礼包……赶上字节十周年，day1大礼包+T恤纪念<br>截止到此时，资本家的糖衣炮弹邦邦砸在身上，直接跑路还来的及，薅资本家羊毛</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945647.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945647.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>端午期间租了个房子，环境还凑合，能直接看到工作的地方，房补有要求，不行30分钟以内，地铁20分钟，除去房补每月还要支出1000多块</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945004.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945004.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945662.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208141945662.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="实习" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mybatis-simple</title>
    <link href="http://raptor1998.top/2022/05/10/mybatis-mini/"/>
    <id>http://raptor1998.top/2022/05/10/mybatis-mini/</id>
    <published>2022-05-09T16:00:00.000Z</published>
    <updated>2022-05-25T03:01:28.534Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h2 id="mybatis执行的流程"><a href="#mybatis执行的流程" class="headerlink" title="mybatis执行的流程"></a>mybatis执行的流程</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220525110009.png" class="fancybox"><img alt="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220525110009.png" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220525110009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220525110009.png"></a></p><h2 id="实现一个简单的mybatis思路"><a href="#实现一个简单的mybatis思路" class="headerlink" title="实现一个简单的mybatis思路"></a>实现一个简单的mybatis思路</h2><ol><li>读取xml配置文件的信息</li><li>创建一个SqlSessionFactory，并解析mybatis-config.xml和xxMapper.xml的信息（简化了步骤，直接在解析过程中赋值了）</li><li>将解析的结果封装到一个Configuration中，包括Environment，表示数据库的一些连接信息；<br>和一个Map&lt;String, MapperStatement&gt;，其中key的表示是namespace+id，MapperStatement存储相关的sql信息</li><li>调用openSession方法，其中SqlSession中包括前面解析的配置类和一个执行器Executor。</li><li>Executor可以通过DataSource进行数据库交互</li><li>获取mapper的代理类</li><li>调用查询方法，最终会调用Executor的方法，Executor的到参数，并获取响应的MapperStatement，执行完成之后，根据返回类型，使用反射将结果封装成响应的类型</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://github.com/Raptor1998" target="_blank" rel="noopener">Raptor1998</a>/<strong><a href="https://github.com/Raptor1998/mybatis-mini" target="_blank" rel="noopener">mybatis-mini</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://raptor1998.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Transaction</title>
    <link href="http://raptor1998.top/2022/05/03/spring%20transaction/"/>
    <id>http://raptor1998.top/2022/05/03/spring%20transaction/</id>
    <published>2022-05-02T16:00:00.000Z</published>
    <updated>2022-05-25T03:04:49.701Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220505094129.png" data-fancybox="group" data-caption="img.png" class="fancybox"><img alt="img.png" title="img.png" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220505094129.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的<code>ACID</code></h2><ol><li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="JDBC中手动事务的实现"><a href="#JDBC中手动事务的实现" class="headerlink" title="JDBC中手动事务的实现"></a><code>JDBC</code>中手动事务的实现</h2><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>手动获取数据源的连接，将提交方式设置为手动，出现异常手动回滚。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"></span><br><span class="line">    Connection connection = dataSource.getConnection();</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        String s = UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配合spring事务</span></span><br><span class="line">        <span class="comment">//jdbcTemplate.execute("insert into user(nickname) values('" + s + "')");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动控制</span></span><br><span class="line">        statement.execute(<span class="string">"insert into user(nickname) values('"</span> + s + <span class="string">"')"</span>);</span><br><span class="line">        <span class="comment">//int a = 12 / 0;</span></span><br><span class="line"></span><br><span class="line">        connection.commit();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        System.out.println(<span class="string">"异常"</span>+e.getMessage());</span><br><span class="line">        connection.rollback();</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//关闭是放回连接池还是关闭java和mysql的连接</span></span><br><span class="line">        <span class="comment">//不一定，连接池不同，可能不同，一般是放回连接池</span></span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>将<code>JDBCTemplate</code>抽离出来,将无用的操作封装到<code>MyJDBCTemplate</code>中，<code>serveice</code>中只关心业务逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"></span><br><span class="line">    Connection connection = dataSource.getConnection();</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        statement.execute(sql);</span><br><span class="line">        connection.commit();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        System.out.println(<span class="string">"异常"</span> + e.getMessage());</span><br><span class="line">        connection.rollback();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//关闭是放回连接池还是关闭java和mysql的连接</span></span><br><span class="line">        <span class="comment">//不一定，连接池不同，可能不同，一般是放回连接池</span></span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        myJdbcTemplate.execute(<span class="string">"insert into user(nickname) values('"</span> + UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>) + <span class="string">"')"</span>);</span><br><span class="line">        myJdbcTemplate.execute(<span class="string">"insert into user(nickname) values('"</span> + UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>) + <span class="string">"')"</span>);</span><br><span class="line">        <span class="comment">//int a = 10 / 0;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="QA——两条sql语句如何保证在一个连接内"><a href="#QA——两条sql语句如何保证在一个连接内" class="headerlink" title="QA——两条sql语句如何保证在一个连接内"></a>QA——两条<code>sql</code>语句如何保证在一个连接内</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h4><p><a href="面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）">面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）</a></p><h3 id="通过事务管理"><a href="#通过事务管理" class="headerlink" title="通过事务管理"></a>通过事务管理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证在一个线程中拿到的连接时同一个连接</span></span><br><span class="line">ThreadLocal&lt;Connection&gt; connectionThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (connectionThreadLocal.get() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> connectionThreadLocal.get();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        connectionThreadLocal.set(dataSource.getConnection());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> connectionThreadLocal.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MyTransactionManager myTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Connection connection = myTransactionManager.getConnection();</span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line">    statement.execute(sql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="通过aop实现一个简单的事务回滚"><a href="#通过aop实现一个简单的事务回滚" class="headerlink" title="通过aop实现一个简单的事务回滚"></a>通过aop实现一个简单的事务回滚</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MyTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"@annotation(MyTransaction)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doTransaction</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    Connection connection = transactionManager.getConnection();</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    System.out.println(<span class="string">"事务开始"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        connection.commit();</span><br><span class="line">        System.out.println(<span class="string">"事务提交"</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"事务回滚"</span>);</span><br><span class="line">        connection.rollback();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><h3 id="Propagation-REQUIRED（默认）"><a href="#Propagation-REQUIRED（默认）" class="headerlink" title="Propagation.REQUIRED（默认）"></a>Propagation.REQUIRED（默认）</h3><p><strong>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。</strong></p><p>  1. 父方法和子方法都开启事务，异常发生让子事务回滚，父事务一定回滚(子事务没将父事务挂起的情况下)，不管是否被try-catch包裹。<br>  2. 只要try-catch在内层，@Transactional在外层，异常被try-catch住，事务就不会回滚。<br>          3. 但是如果@Transactional在内层，try-catch在外层，那try-catch还没来得及处理异常就在@Transactional注解作用下回滚了</p><h3 id="Propagation-SUPPORTS"><a href="#Propagation-SUPPORTS" class="headerlink" title="Propagation.SUPPORTS"></a>Propagation.SUPPORTS</h3><p><strong>如果当前有事务，则使用事务，如果当前没有事务，就以非事务方式执行</strong></p><h3 id="Propagation-MANDATORY"><a href="#Propagation-MANDATORY" class="headerlink" title="Propagation.MANDATORY"></a>Propagation.MANDATORY</h3><p><strong>支持当前的事务，如果当前没有事务，就抛出异常。</strong></p><h3 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h3><p><strong>新建事务，如果当前存在事务，把当前事务挂起。</strong></p><h3 id="Propagation-NOT-SUPPORTED"><a href="#Propagation-NOT-SUPPORTED" class="headerlink" title="Propagation.NOT_SUPPORTED"></a>Propagation.NOT_SUPPORTED</h3><p><strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</strong></p><h3 id="Propagation-NEVER"><a href="#Propagation-NEVER" class="headerlink" title="Propagation.NEVER"></a>Propagation.NEVER</h3><p><strong>以非事务方式执行，如果当前存在事务，则抛出异常。与<code>Propagation.MANDATORY</code>正好相反。</strong></p><h3 id="Propagation-NESTED"><a href="#Propagation-NESTED" class="headerlink" title="Propagation.NESTED"></a>Propagation.NESTED</h3><p><strong>如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚，如果当前没有事务，就新建事务运行。</strong></p><p><strong>运行结果和原因与<code>Propagation.REQUIRED</code>一模一样。几乎没区别，这种情况用得少。</strong></p><h2 id="如何让下一个方法获取当前是否已经存在事务"><a href="#如何让下一个方法获取当前是否已经存在事务" class="headerlink" title="如何让下一个方法获取当前是否已经存在事务"></a>如何让下一个方法获取当前是否已经存在事务</h2><p>当事务开启之后，将值设置为true，此时便可以获取当前是否存在事务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Boolean&gt; hasTransaction = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></tbody></table></figure></div><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/qq_34115899/article/details/115602002" target="_blank" rel="noopener">事务的7种传播行为</a></p><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/Raptor1998" target="_blank" rel="noopener">Raptor1998</a>/<strong><a href="https://github.com/Raptor1998/spring-transaction" target="_blank" rel="noopener">spring-transaction</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://raptor1998.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://raptor1998.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://raptor1998.top/2022/04/26/spring%20bean/"/>
    <id>http://raptor1998.top/2022/04/26/spring%20bean/</id>
    <published>2022-04-25T16:00:00.000Z</published>
    <updated>2022-05-11T09:37:21.759Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="Spring-中-bean"><a href="#Spring-中-bean" class="headerlink" title="Spring 中 bean"></a>Spring 中 bean</h1><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p><strong>Spring 的 bean 作用域（scope）：</strong></p><ul><li>singleton:单例，默认作用域。</li><li>prototype:原型，每次创建一个新对象。</li><li>request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</li><li>session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</li><li>global-session:全局会话，所有会话共享一个实例。</li></ul><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a><strong>单例Bean</strong></h3><p>对于单例Bean,所有线程都共享一个单例实例Bean，因此是存在资源的竞争。如果单例Bean是一个<strong>无状态Bean</strong>（<strong>有状态就是有数据存储功能，无状态就是不会保存数据</strong>），也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p><strong>spring单例，为什么controller、service和dao确能保证线程安全？</strong></p><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。<br>实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。</p><ol><li>在@Controller/@Service等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。</li><li>尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。</li><li>默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。</li><li>一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的</li></ol><h3 id="原型Bean"><a href="#原型Bean" class="headerlink" title="原型Bean"></a><strong>原型Bean</strong></h3><p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p><h1 id="bean的循环依赖"><a href="#bean的循环依赖" class="headerlink" title="bean的循环依赖"></a>bean的循环依赖</h1><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><h3 id="singletonObjects"><a href="#singletonObjects" class="headerlink" title="singletonObjects"></a>singletonObjects</h3><p>完成初始化的单例对象的 cache，这里的 bean 经历过 实例化-&gt;属性填充-&gt;初始化 以及各种后置处理（一级缓存）。</p><h3 id="earlySingletonObjects"><a href="#earlySingletonObjects" class="headerlink" title="earlySingletonObjects"></a>earlySingletonObjects</h3><p>存放原始的 bean 对象（完成实例化但是尚未填充属性和初始化），仅仅能作为指针提前曝光，被其他 bean 所引用，用于解决循环依赖的 （二级缓存）。</p><h3 id="singletonFactories"><a href="#singletonFactories" class="headerlink" title="singletonFactories"></a>singletonFactories</h3><p>在 bean 实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring 会将实例化后的 bean 提前曝光，也就是把该 bean 转换成 beanFactory 并加入到 singletonFactories（三级缓存）。</p><h2 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h2><ol><li>实例化Bean：通过反射调用构造方法实例化对象。</li><li>依赖注入：装配Bean的属性</li><li>实现了Aware接口的Bean，执行接口方法：如顺序执行BeanNameAware、BeanFactoryAware、 ApplicationContextAware的接口方法。</li><li>Bean对象初始化前，循环调用实现了BeanPostProcessor接口的预初始化方法 （postProcessBeforeInitialization）</li><li>Bean对象初始化：顺序执行@PostConstruct注解方法、InitializingBean接口方法、init-method方法</li><li>Bean对象初始化后，循环调用实现了BeanPostProcessor接口的后初始化方法 （postProcessAfterInitialization）</li><li>容器关闭时，执行Bean对象的销毁方法，顺序是：@PreDestroy注解方法、DisposableBean接口方法、destroy-method</li></ol><h3 id="bean创建过程"><a href="#bean创建过程" class="headerlink" title="bean创建过程"></a>bean创建过程</h3><p>getBean-&gt;实例化-&gt;属性填充-&gt;初始化（自行bean的初始化方法，如afterPropertiesSet）</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171132.png" data-fancybox="group" data-caption="image-20220426163422045" class="fancybox"><img alt="image-20220426163422045" title="image-20220426163422045" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171132.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h4 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171154.png" data-fancybox="group" data-caption="image-20220426163511580" class="fancybox"><img alt="image-20220426163511580" title="image-20220426163511580" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171154.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="半成品提前暴露"><a href="#半成品提前暴露" class="headerlink" title="半成品提前暴露"></a>半成品提前暴露</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171200.png" data-fancybox="group" data-caption="image-20220426163608653" class="fancybox"><img alt="image-20220426163608653" title="image-20220426163608653" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171200.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>当b需要a 的时候，去单例池中寻找a，没找到；去半成品池中寻找a，找到以后赋值并将b放入单例池；然后将b赋值给a，并将半成品池中的a移除</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171208.png" data-fancybox="group" data-caption="image-20220426163827610" class="fancybox"><img alt="image-20220426163827610" title="image-20220426163827610" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171208.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p><strong>二级缓存就解决了循环依赖问题，为什么还需要三级缓存？</strong></p><p><strong>解决aop引用问题，当对象有aop增强的时候，a引用的是b的代理对象，而不是b的原始对象，b同理，需要a的代理对象。此时b再去半成品池去取对象，取得是a的原始对象，而不是代理对象。</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171219.png" data-fancybox="group" data-caption="image-20220426164008035" class="fancybox"><img alt="image-20220426164008035" title="image-20220426164008035" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171219.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="aop的代理实现"><a href="#aop的代理实现" class="headerlink" title="aop的代理实现"></a>aop的代理实现</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171222.png" data-fancybox="group" data-caption="image-20220426162945335" class="fancybox"><img alt="image-20220426162945335" title="image-20220426162945335" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171222.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>aop是初始化的后置处理中进行增强，如上图所示，bean的后置处理器中有一个aop处理器，有两个入口，一个事postProcessAfterInitialization（后置处理）和getEarlyBEanReference（提前处理）</strong></p><h3 id="添加工厂池"><a href="#添加工厂池" class="headerlink" title="添加工厂池"></a>添加工厂池</h3><p><strong>对象初始化完成之后，进行后置处理，当b对a有提前引用的时候，执行factory(a)，从而创建a的动态代理，并且将a的代理放到半成品池中，将a的半成品填充到b的属性中去，然后执行b的后置处理，将b放到单例池中去，（在执行createBeanInstance(“b”)的时候，也会去工厂池创建factory(b)，不过在创建b的过程中，没有人提前引用b，所以工厂池中的对象会被移除）</strong></p><p><strong>当a获取到b的代理对象之后，没必要在执行后置处理，而是直接从半成品池中的a移动到单例池中去，并且移除工厂池中的a</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171231.png" data-fancybox="group" data-caption="image-20220426164937768" class="fancybox"><img alt="image-20220426164937768" title="image-20220426164937768" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171231.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171241.png" data-fancybox="group" data-caption="image-20220426165309219" class="fancybox"><img alt="image-20220426165309219" title="image-20220426165309219" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171241.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171250.png" data-fancybox="group" data-caption="image-20220426165805873" class="fancybox"><img alt="image-20220426165805873" title="image-20220426165805873" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171250.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171259.png" data-fancybox="group" data-caption="image-20220426165736641" class="fancybox"><img alt="image-20220426165736641" title="image-20220426165736641" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220426171259.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="分别用一二三级缓存解决循环依赖的方案"><a href="#分别用一二三级缓存解决循环依赖的方案" class="headerlink" title="分别用一二三级缓存解决循环依赖的方案"></a>分别用一二三级缓存解决循环依赖的方案</h1><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="不考虑aop使用—级缓存解决循环依赖"><a href="#不考虑aop使用—级缓存解决循环依赖" class="headerlink" title="不考虑aop使用—级缓存解决循环依赖"></a>不考虑aop使用—级缓存解决循环依赖</h3><ol><li>创建A对象,放到缓存中，这时候为A对象注入属性</li><li>创建B放到缓存，从缓存中获得A对象，将B对象返回给A对象(这时候如果不考虑aop 一级缓存就可以解决循环依赖的问题了)</li></ol><h3 id="考虑aop时-一级缓存无法解决循环依赖的问题"><a href="#考虑aop时-一级缓存无法解决循环依赖的问题" class="headerlink" title="考虑aop时,一级缓存无法解决循环依赖的问题"></a>考虑aop时,一级缓存无法解决循环依赖的问题</h3><p> 因为初始化操作必须放在aop代理之前, 否则导致初始化的时候无法改变代理对象的属性值，假设A和B对象互相引用，且A和B对象都使用aop进行了增强，则按照上面的逻辑，A对象放到缓存后，需要注入B对象,而缓存中没有B对象，则需要去创建B对象，这时候B对象可以从缓存中获得A对象，而B对象拿到的是没有进行aop增强的A对象，这时候就算把初始化B对象和为B对象生成aop代理的业务逻辑放在这，也只能保证A对象获得的是aop代理过的B对象，而B对象中的A对象是没有经过aop增强的，且经过jdk/cglib动态代理后对象的属性值是没有办法改变的，这时候为A生成aop增强过的对象也无法替换B对象中的A对象，所以一级缓存无法解决。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存可以解决循环依赖，并且也可以解决循环依赖中的依赖对象被aop代理问题</p><p>就是普通对象初始化完成后，然后走到 getSingleton方法通过三级缓存创建对象,<br>假设A和B循环依赖,并且A和B都通过aop增强，假设先创建A，则当为A中注入B时，发现B没有，就会去创建B，如果使用二级缓存，这时候直接通过对象工厂创建A的aop对象<br>，放在一级缓存中，相当于A对象创建好了，这时候创建好B对象后，返回继续创建A对象，这时候按顺序，A的属性注入后该进行初始化A对象了，但这时候在创建B时已经把A对象放到一级缓存中了，这时候如果另一个线程来获取就会获得还没有完全初始化的<br>A对象（框架是单线程加载的，当框架加载好所有对象都创建好了，因该不会出现不安<br>全发布的情况），这时候也就会出现违背Spring创建对象的原则，即在对象没有完全初始化的时候就出现在了一级缓存中，Spring创建对象的原则是在对象被完全初始化后才能被放到缓存中，被外界获取。</p><h2 id="三级缓存-1"><a href="#三级缓存-1" class="headerlink" title="三级缓存"></a>三级缓存</h2><p><strong>A 假设和 B 相互引用，且都被 aop 增强</strong> </p><ol><li>A 对象先封装一个回调函数到三级循环中，这个接口里封装的是 aop 使用 bean 来创建 aop 代理类的方法</li><li>这时候如果为 A 对象中有 B 类的属性，需要把 B 注入到 A 中</li><li>这时候没有创建 B 类的对象，就去创建，也是封装一个回调函数到三级缓存中 </li><li>这时候需要往 B中注入 A ，发现 A 在三级循环中，这时候会调用回调函数的 getObject 方法获得 aop 增强过的 A 对象，放入二级缓存中，因为 A 对象没有初始化完成，这个对象是不完整的，其实也可直接放使用二级缓存来解决循环依赖 </li><li>但是用二级缓存的话会破坏 spring 创建对象的原则，一级缓存存放的是已经<br>初始化过的完整的对象，二级三级都是半成品， Spring 更喜欢把所有的普通 Bean 都初始化完成，再处理代理对象的初始化。</li></ol><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://blog.csdn.net/smilehappiness/article/details/119712824" target="_blank" rel="noopener">Spring框架中的单例bean是线程安全的吗?</a></p><p><a href="https://baijiahao.baidu.com/s?id=1677105782547823661&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">循环依赖问题</a></p><p><a href="https://blog.csdn.net/qq_39552268/article/details/122502988" target="_blank" rel="noopener">分别用一二三级缓存解决循环依赖的方案</a></p><p><a href="https://www.bilibili.com/video/BV1ET4y1N7Sp?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">第二次讲Spring循环依赖，时长16分钟，我保证每一秒都是精华</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://raptor1998.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://raptor1998.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC simple version</title>
    <link href="http://raptor1998.top/2022/04/23/spring%20ioc/"/>
    <id>http://raptor1998.top/2022/04/23/spring%20ioc/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-05-25T03:04:24.396Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring-IOC"></a>Spring-IOC</h1><p><strong>a simple version of spring IOC and AOP Demo</strong></p><p><strong>好莱坞法则：“别找我们，我们找你”</strong>；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h1 id="IOC-Foundation"><a href="#IOC-Foundation" class="headerlink" title="IOC Foundation"></a>IOC Foundation</h1><p>控制反转，把对象的创建和对象之间的调用过程，交给spring进行管理，使用IOC目的，为了降低耦合度</p><p>IoC <strong>不是一种技术，只是一种思想</strong>，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。<strong>IoC是设计思想，DI是实现方式</strong>。</p><h1 id="origin-spring"><a href="#origin-spring" class="headerlink" title="origin spring"></a>origin spring</h1><h2 id="beanFactory"><a href="#beanFactory" class="headerlink" title="beanFactory"></a>beanFactory</h2><p>通过beanfactory实现对象的创建，当实现类大声变化时，修改配置文件即可。在使用bean的时候从容器中获取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            properties.load(BeanFactory.class.getClassLoader().getResourceAsStream("factory.properties"));</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、强依赖/紧耦合，编译之后无法修改，没有扩展性。</span></span><br><span class="line"><span class="comment">     * 2、弱依赖/松耦合，编译之后仍然可以修改，让程序具有更好的扩展性。</span></span><br><span class="line"><span class="comment">     * 自己放弃了创建对象的权限，将创建对象的权限交给了BeanFactory，</span></span><br><span class="line"><span class="comment">     * 这种将控制权交给别人的思想，就是控制反转 IoC。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getDao</span><span class="params">(String beanName)</span> </span>{</span><br><span class="line">        <span class="comment">//判断缓存中是否存在bean</span></span><br><span class="line">        <span class="keyword">boolean</span> containsKey = cache.containsKey(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!containsKey) {</span><br><span class="line">            <span class="keyword">synchronized</span> (BeanFactory<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    String value = properties.getProperty(beanName); <span class="comment">//反射机制创建对象 try {Class clazz = Class.forName(value);</span></span><br><span class="line">                    Class clazz = Class.forName(value);</span><br><span class="line">                    Object object = clazz.getConstructor(<span class="keyword">null</span>).newInstance(<span class="keyword">null</span>);</span><br><span class="line">                    cache.put(beanName, object);</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cache.get(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="use-annotation"><a href="#use-annotation" class="headerlink" title="use annotation"></a>use annotation</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载IoC容器</span></span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"com.raptor.originspring.entity"</span>);</span><br><span class="line">String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">System.out.println(applicationContext.getBeanDefinitionCount());</span><br><span class="line"><span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) {</span><br><span class="line">    System.out.println(beanDefinitionName);</span><br><span class="line">    System.out.println(applicationContext.getBean(beanDefinitionName));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="own-spring——Annotation"><a href="#own-spring——Annotation" class="headerlink" title="own spring——Annotation"></a>own spring——Annotation</h1><h2 id="bean-life"><a href="#bean-life" class="headerlink" title="bean life"></a>bean life</h2><ol><li>实例化Bean：通过反射调用构造方法实例化对象。</li><li>依赖注入：装配Bean的属性</li><li>实现了Aware接口的Bean，执行接口方法：如顺序执行BeanNameAware、BeanFactoryAware、 ApplicationContextAware的接口方法。</li><li>Bean对象初始化前，循环调用实现了BeanPostProcessor接口的预初始化方法 （postProcessBeforeInitialization）</li><li>Bean对象初始化：顺序执行@PostConstruct注解方法、InitializingBean接口方法、init-method方法</li><li>Bean对象初始化后，循环调用实现了BeanPostProcessor接口的后初始化方法 （postProcessAfterInitialization）</li><li>容器关闭时，执行Bean对象的销毁方法，顺序是：@PreDestroy注解方法、DisposableBean接口方法、destroy-method</li></ol><h2 id="implementation-steps"><a href="#implementation-steps" class="headerlink" title="implementation steps"></a>implementation steps</h2><ol><li><p>自定义一个AnnotationConfigApplicationContext，构造器中传入要扫描的包。</p></li><li><p>获取这个包下的所有类。</p></li><li><p>遍历这些类，找出添加了 @Component 注解的类，获取它的 Class 和对应的 beanName，封装成一个BeanDefinition，存入集合 Set，这个机会就是 IoC 自动装载的原材料。</p></li><li><p>遍历 Set 集合，通过反射机制创建对象，同时检测属性有没有添加 @Value 注解，如果有还需要给属性赋值，再将这些动态创建的对象以 k-v 的形式存入缓存区。</p></li><li><p>提供 getBean 等方法，通过 beanName 取出对应的bean 即可。</p></li></ol><h2 id="declaration-annotation"><a href="#declaration-annotation" class="headerlink" title="declaration annotation"></a>declaration annotation</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> OwnAutowired</span><br><span class="line"><span class="meta">@interface</span> OwnComponent</span><br><span class="line"><span class="meta">@interface</span> OwnQualifier</span><br><span class="line"><span class="meta">@interface</span> OwnValue</span><br></pre></td></tr></tbody></table></figure></div><h2 id="declaration-AnnotationConfigApplicationContext"><a href="#declaration-AnnotationConfigApplicationContext" class="headerlink" title="declaration AnnotationConfigApplicationContext"></a>declaration AnnotationConfigApplicationContext</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnAnnotationConfigApplicationContext</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OwnAnnotationConfigApplicationContext</span><span class="params">(String packageName)</span> </span>{</span><br><span class="line">        <span class="comment">//找到对应的包，加载对应的class</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; beanDefinitions = findBeanDefinition(packageName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据类名和class   创建bean</span></span><br><span class="line">        createObject(beanDefinitions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动装在</span></span><br><span class="line">        autowireObject(beanDefinitions);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="scan-declaration-annotation"><a href="#scan-declaration-annotation" class="headerlink" title="scan declaration annotation"></a>scan declaration annotation</h2><p>包扫描详见此包下的com.raptor.ownspring.utils.MyTools</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findBeanDefinition</span><span class="params">(String packageName)</span> </span>{</span><br><span class="line">        <span class="comment">//获取当前包所有的类</span></span><br><span class="line">        <span class="comment">//遍历所有的类</span></span><br><span class="line">        <span class="comment">//奖这写类封装成 BeanDefinition，装在到集合中</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = MyTools.getClasses(packageName);</span><br><span class="line">        Iterator&lt;Class&lt;?&gt;&gt; iterator = classes.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            Class&lt;?&gt; aClass = iterator.next();</span><br><span class="line">            OwnComponent annotation = aClass.getAnnotation(OwnComponent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">//有注解   目标类找到</span></span><br><span class="line"><span class="comment">//                System.out.println(aClass+" 有注解");</span></span><br><span class="line">                <span class="comment">//封装一个BeanDefinition</span></span><br><span class="line">                String beanName = annotation.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span> .equals(beanName)) {</span><br><span class="line">                    <span class="comment">//没写别名</span></span><br><span class="line">                    <span class="comment">//获取到的类名是全类名   可以通过获取包名然后替换    同时将首字母更换为小写</span></span><br><span class="line">                    <span class="comment">//之更改第一个字母为小写即可</span></span><br><span class="line">                    <span class="comment">//beanName = aClass.getName().replace(classNamePre, "").toLowerCase();</span></span><br><span class="line">                    String className = aClass.getName().replaceAll(aClass.getPackage().getName() + <span class="string">"."</span>, <span class="string">""</span>);</span><br><span class="line">                    beanName = className.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase() + className.substring(<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">                BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition(beanName, aClass);</span><br><span class="line">                set.add(beanDefinition);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h2 id="reflex-and-attribute-injection"><a href="#reflex-and-attribute-injection" class="headerlink" title="reflex and attribute injection"></a>reflex and attribute injection</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">(Set&lt;BeanDefinition&gt; beanDefinitions)</span> </span>{</span><br><span class="line">        Iterator&lt;BeanDefinition&gt; iterator = beanDefinitions.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            BeanDefinition beanDefinition = iterator.next();</span><br><span class="line">            Class beanClass = beanDefinition.getBeanClass();</span><br><span class="line">            String beanName = beanDefinition.getBeanName();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//创建对象</span></span><br><span class="line">                Object object = beanClass.getConstructor().newInstance();</span><br><span class="line">                <span class="comment">//属性赋值</span></span><br><span class="line">                Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line">                <span class="keyword">for</span> (Field declaredField : declaredFields) {</span><br><span class="line"><span class="comment">//                    System.out.println(declaredField);</span></span><br><span class="line">                    OwnValue annotation = declaredField.getAnnotation(OwnValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="comment">//不等于null  有注解</span></span><br><span class="line">                    <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {</span><br><span class="line">                        String value = annotation.value();</span><br><span class="line">                        <span class="comment">//属性名</span></span><br><span class="line">                        String fieldName = declaredField.getName();</span><br><span class="line">                        String methodName = <span class="string">"set"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                        Method method = beanClass.getMethod(methodName, declaredField.getType());</span><br><span class="line">                        <span class="comment">//完成数据类型转换</span></span><br><span class="line">                        Object val = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">switch</span> (declaredField.getType().getName()) {</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"java.lang.Integer"</span>:</span><br><span class="line">                                val = Integer.parseInt(value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"java.lang.String"</span>:</span><br><span class="line">                                val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"java.lang.Float"</span>:</span><br><span class="line">                                val = Float.parseFloat(value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                        method.invoke(object, val);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//放入缓存</span></span><br><span class="line">                cache.put(beanName, object);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autowireObject</span><span class="params">(Set&lt;BeanDefinition&gt; beanDefinitions)</span> </span>{</span><br><span class="line">    Iterator&lt;BeanDefinition&gt; iterator = beanDefinitions.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">        BeanDefinition beanDefinition = iterator.next();</span><br><span class="line">        Class beanClass = beanDefinition.getBeanClass();</span><br><span class="line">        Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) {</span><br><span class="line">            OwnAutowired ownAutowiredAnnotation = declaredField.getAnnotation(OwnAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (ownAutowiredAnnotation != <span class="keyword">null</span>) {</span><br><span class="line">                OwnQualifier ownQualifierAnnotation = declaredField.getAnnotation(OwnQualifier<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (ownQualifierAnnotation != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">//有auto  也有  Qualifier</span></span><br><span class="line">                    <span class="comment">//根据bean名称</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        String beanName = ownQualifierAnnotation.value();</span><br><span class="line">                        <span class="comment">//属性bean</span></span><br><span class="line">                        Object o = cache.get(beanName);</span><br><span class="line">                        String fieldName = declaredField.getName();</span><br><span class="line">                        String methodName = <span class="string">"set"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                        Method method = beanClass.getMethod(methodName, declaredField.getType());</span><br><span class="line">                        <span class="comment">//需要设置  属性的 类</span></span><br><span class="line">                        Object o1 = cache.get(beanDefinition.getBeanName());</span><br><span class="line"></span><br><span class="line">                        method.invoke(o1, o);</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//只有autowire</span></span><br><span class="line">                    <span class="comment">//根据类型</span></span><br><span class="line">                    Class&lt;?&gt; aClass = declaredField.getType();</span><br><span class="line">                    OwnComponent annotation = aClass.getAnnotation(OwnComponent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {</span><br><span class="line">                        String beanName = annotation.value();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">""</span> .equals(beanName)) {</span><br><span class="line">                            String className = aClass.getName().replaceAll(aClass.getPackage().getName() + <span class="string">"."</span>, <span class="string">""</span>);</span><br><span class="line">                            beanName = className.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase() + className.substring(<span class="number">1</span>);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Object o = cache.get(beanName);</span><br><span class="line">                            String fieldName = declaredField.getName();</span><br><span class="line">                            String methodName = <span class="string">"set"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                            Method method = beanClass.getMethod(methodName, declaredField.getType());</span><br><span class="line">                            Object o1 = cache.get(beanDefinition.getBeanName());</span><br><span class="line">                            method.invoke(o1, o);</span><br><span class="line">                        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }<span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">//没写注解  无法注入</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't autowire"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Test-Own-Spring"><a href="#Test-Own-Spring" class="headerlink" title="Test Own Spring"></a>Test Own Spring</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//工具类测试</span></span><br><span class="line">    <span class="comment">//获取一个包下的类</span></span><br><span class="line">    OwnAnnotationConfigApplicationContext ownAnnotationConfigApplicationContext = <span class="keyword">new</span> OwnAnnotationConfigApplicationContext(<span class="string">"com.raptor.ownspring.entity"</span>);</span><br><span class="line">    Object account = ownAnnotationConfigApplicationContext.getBean(<span class="string">"account"</span>);</span><br><span class="line">    System.out.println(account);</span><br><span class="line"></span><br><span class="line">    Object orderTest = ownAnnotationConfigApplicationContext.getBean(<span class="string">"orderTest"</span>);</span><br><span class="line">    System.out.println(orderTest);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Bean-Scope"><a href="#Bean-Scope" class="headerlink" title="Bean Scope"></a>Bean Scope</h1><h2 id="declaration-annotation-1"><a href="#declaration-annotation-1" class="headerlink" title="declaration annotation"></a>declaration annotation</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OwnScope {</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="create-bean"><a href="#create-bean" class="headerlink" title="create bean"></a>create bean</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有bean的作用域</span></span><br><span class="line"><span class="keyword">if</span> (aClass.isAnnotationPresent(OwnScope<span class="class">.<span class="keyword">class</span>)) </span>{</span><br><span class="line">   OwnScope scopeAnnotation = aClass.getDeclaredAnnotation(OwnScope<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanDefinition.setScope(scopeAnnotation.value());</span><br><span class="line">   <span class="keyword">if</span> (scopeAnnotation.value().equals(<span class="string">"singleton"</span>)) {</span><br><span class="line">        set.add(beanDefinition);</span><br><span class="line">   }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//默认是单例bean</span></span><br><span class="line">    beanDefinition.setScope(<span class="string">"singleton"</span>);</span><br><span class="line">        <span class="comment">//单例bean等会直接创建对象</span></span><br><span class="line">        set.add(beanDefinition);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="get-bean"><a href="#get-bean" class="headerlink" title="get bean"></a>get bean</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (beanDefinitionMap.containsKey(beanName)) {</span><br><span class="line">        System.out.println(beanName);</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.getScope().equals(<span class="string">"singleton"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> cache.get(beanName);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(beanName + <span class="string">" not exist"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="own-spring——AppConfig"><a href="#own-spring——AppConfig" class="headerlink" title="own spring——AppConfig"></a>own spring——AppConfig</h1><h2 id="declaration-annotation-2"><a href="#declaration-annotation-2" class="headerlink" title="declaration annotation"></a>declaration annotation</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OwnComponentScan {</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="own-spring——simple-AOP"><a href="#own-spring——simple-AOP" class="headerlink" title="own spring——simple AOP"></a>own spring——simple AOP</h1><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OwnComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">"account"</span>)) {</span><br><span class="line">            System.out.println(<span class="string">"bean的初始化前"</span>);</span><br><span class="line">            ((Account) bean).test();</span><br><span class="line">            ((Account) bean).setName(<span class="string">"铠甲勇士"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"bean的初始化后"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">"aopTest"</span>)) {</span><br><span class="line">            Object proxyInstance = Proxy.newProxyInstance(BeanPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">bean</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(), <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>{</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">                    System.out.println(<span class="string">"初始化之后的代理逻辑"</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(bean,args);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="keyword">return</span> proxyInstance;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="create-postProcessor"><a href="#create-postProcessor" class="headerlink" title="create postProcessor"></a>create postProcessor</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OwnComponent annotation = aClass.getAnnotation(OwnComponent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (annotation != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是特殊的processor</span></span><br><span class="line">    <span class="keyword">if</span> (BeanPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">aClass</span>)) </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            BeanPostProcessor beanPostProcessor = (BeanPostProcessor) aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">            beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">        } <span class="keyword">catch</span> (InstantiationException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h2 id="when-create-bean"><a href="#when-create-bean" class="headerlink" title="when create bean"></a>when create bean</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bean post processor</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor beanPostProcessor : beanPostProcessors) {</span><br><span class="line">    object = beanPostProcessor.postProcessAfterInitialization(object, beanName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html" target="_blank" rel="noopener">Spring基础 - Spring核心之控制反转(IOC)</a></p><p><a href="https://www.bilibili.com/video/BV1AV411i7VH" target="_blank" rel="noopener">楠哥教你学Java之3小时搞懂Spring IoC核心源码</a></p><h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p><a href="https://github.com/Raptor1998" target="_blank" rel="noopener">Raptor1998</a>/<strong><a href="https://github.com/Raptor1998/Spring-IOC" target="_blank" rel="noopener">Spring-IOC</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://raptor1998.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://raptor1998.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java面试问题记录</title>
    <link href="http://raptor1998.top/2022/04/15/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://raptor1998.top/2022/04/15/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-14T16:00:00.000Z</published>
    <updated>2022-04-29T09:09:19.879Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><strong><em>1. 非核心线程的创建时机</em></strong></p><ul><li><p>核心线程的数量是 corePoolSize 的值，非核心线程的数量是 maxinumPoolSize - corePoolSize ；</p></li><li><p>非核心线程创建的触发时机是：当前线程池中核心线程已满，且没有空闲的线程，还有任务等待队列已满，满足上面的所有条件，才会去创建线程去执行新提交的任务；</p></li><li><p>如果线程池中的线程数量达到 maxinumPoolSize 的值，此时还有任务进来，就会执行拒绝策略，抛弃任务或者其他</p></li></ul><p><strong>如果拒绝策略是抛弃任务的话，有一种场景，就会造成大量任务的丢弃，就是瞬时冲高的情况下。</strong></p><p><strong><em>2. 排队任务调度策略</em></strong></p><ul><li><p>当线程池中核心线程数量已达标，且没有空闲线的情况下，在产生的任务，会加入到等待队列中去，这样一直持续下去，</p></li><li><p>等到等待队列已满，在来的任务，会创建非核心线程去执行新提交的任务，那么就产生一种结果，在等待队列中的任务是先提交的任务，反而没有在此时提交的任务先执行。</p></li></ul><p><strong>任务的执行顺序和任务的提交顺序不一致，如果业务需求的任务是有先后依赖关系的，就会降低线程的调度效率</strong></p><h2 id="拒绝策略使用场景"><a href="#拒绝策略使用场景" class="headerlink" title="拒绝策略使用场景"></a>拒绝策略使用场景</h2><p><strong>中止策略：无特殊场景。</strong><br><strong>丢弃策略：无关紧要的任务（博客阅读量）。</strong><br><strong>弃老策略：发布消息。</strong><br><strong>调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）。</strong></p><h3 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h3><p><strong>丢弃任务并抛出RejectedExecutionException异常。</strong></p><p>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.<br>使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h3 id="DiscardPolicy丢弃策略"><a href="#DiscardPolicy丢弃策略" class="headerlink" title="DiscardPolicy丢弃策略"></a>DiscardPolicy丢弃策略</h3><p><strong>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</strong></p><p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</p><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作。<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</p><h3 id="DiscardOldestPolicy弃老策略"><a href="#DiscardOldestPolicy弃老策略" class="headerlink" title="DiscardOldestPolicy弃老策略"></a>DiscardOldestPolicy弃老策略</h3><p><strong>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</strong></p><p>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</p><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</p><h3 id="CallerRunsPolicy调用者运行策略"><a href="#CallerRunsPolicy调用者运行策略" class="headerlink" title="CallerRunsPolicy调用者运行策略"></a>CallerRunsPolicy调用者运行策略</h3><p><strong>由调用线程处理该任务。</strong></p><p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p><h2 id="常见队列"><a href="#常见队列" class="headerlink" title="常见队列"></a>常见队列</h2><p><strong>1）ArrayBlockingQueue</strong></p><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><p><strong>（2）LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；</p><p>newFixedThreadPool线程池使用了这个队列。</p><p><strong>（3）DelayQueue</strong></p><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。</p><p>newScheduledThreadPool线程池使用了这个队列。</p><p><strong>（4）PriorityBlockingQueue</strong></p><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；</p><p><strong>（5）SynchronousQueue</strong></p><p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene</p><p>newCachedThreadPool线程池使用了这个队列。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul><li><p><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</p></li><li><p><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</p></li></ul><blockquote><p>问题一：static 属性不能被序列化</p></blockquote><p>原因：序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p><blockquote><p>问题二：Transient 属性不会被序列化</p></blockquote><p>我们在User里面加上一个transient 状态的心情属性mood;</p><blockquote><p>问题三：序列化版本号serialVersionUID</p></blockquote><p>所有实现序列化的对象都必须要有个版本号，这个版本号可以由我们自己定义，当我们没定义的时候JDK工具会按照我们对象的属性生成一个对应的版本号。</p><p>使用JDK生成的版本号和我们自定义的版本号的区别？</p><p><strong>JDK工具生成的serialVersionUID 是根据对象的属性信息生成的一个编号，这就意味着只要对象的属性有一点变动那么他的序列化版本号就会同步进行改变。</strong></p><blockquote><p>问题四：父类、子类序列化问题</p></blockquote><p>序列化是以正向递归的形式进行的，如果父类实现了序列化那么其子类都将被序列化；子类实现了序列化而父类没实现序列化，那么只有子类的属性会进行序列化，而父类的属性是不会进行序列化的。</p><p>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p><p>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p><h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>java虚拟机只会在不同的类的类名相同且加载该类的加载器均相同的情况下才会判定这是一个类。如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。</p><p>双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。</p><p>没有双亲委派模型，让所有类加载器自行加载的话，假如用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，系统就会出现多个不同的Object类， Java类型体系中基础行为就无法保证，应用程序就会变得一片混乱。</p><p><strong>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</strong></p><h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><ul><li>自定义类加载器，重写loadClass方法；</li><li>使用线程上下文类加载器；</li></ul><p>在jdbc中，父加载器委托子加载器。即利用线程上下文类加载器，让启动类加载器得以委托应用类加载器，去加载jar中的数据库驱动。</p><p>在tomcat中，子加载器优先于父加载器加载。即为了实现各个webapp的隔离性，webappClassLoader会先于父加载器加载。</p><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><strong>访问类型排列</strong><br><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code></p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code></p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</li><li><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</li><li><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code>const</code> 类型之外, 这是最好的联接类型。</li><li><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</li><li><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></li><li><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</li></ul><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><p><strong><code>Using filesort</code></strong>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></p></li><li><p><strong><code>Using temporary</code></strong>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></p></li><li><p><strong><code>Using index</code></strong>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</p></li><li><pre><code>Using where<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：表明使用了</span><br></pre></td></tr></tbody></table></figure></div>WHERE</code></pre><p>过滤。</p><ul><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul></li></ul><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul><li><p>全值匹配</p></li><li><p>最佳左前缀法则。</p></li><li><p>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</p></li><li><p>索引中范围条件右边的字段会全部失效。</p></li><li><p>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</p></li><li><p>MySQL在使用<code>!=</code>或者<code>&lt;&gt;</code>的时候无法使用索引会导致全表扫描。</p></li><li><p><code>is null</code>、<code>is not null</code>也无法使用索引。</p></li><li><p><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</p><p>如何解决两边%索引失效 <strong>覆盖索引</strong> ？？？</p></li><li><p>字符串不加单引号索引失效。</p></li><li><p>少用<code>or</code>，用它来连接时会索引失效。</p></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>MySQL的表级锁两种模式：</p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ul><table><thead><tr><th>锁类型</th><th>可否兼容</th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>是</td><td>否</td></tr><tr><td>写锁</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><ul><li>对于MyISAM表的读操作（加读锁），不会阻塞其他进程对同一张表的读请求，但会阻塞对同一张表的学请求。只有当读锁释放后，才会执行凄然进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当前写锁释放后，才会执行其他进程的读写操作。</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li><p>偏向于InnoDB引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高。</p></li><li><p>InnoDB与MyISAM的最大不同有两点：一是支出事务</p><p>（TRANSACTION）；二是采用了行级锁</p></li></ul><p>Record Lock：单个行记录上的锁，总是按索引键锁定记录。</p><p>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</p><p>Next-Key Lock：Record Lock+ Gap Lock，锁定一个范围，并且锁定记录本身。</p><p>当我们使用范围条件而不是相等条件检索数据，并请求共享或者排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”</p><p>InnoDB也会对这个间隙加锁，这种随机值就是所谓的间隙锁（Next-key锁）</p><p><strong>因为query执行过程中通过范围查找的话，它会锁定整个范围内所有的索引键值，即使这个键值不存在。</strong></p><p><strong>间隙锁有一个比较致命的缺点，即使某些不存在的键值也会被无辜锁定，二造成锁定的时候无法插入锁定范围内的任何数据。在某些场景下这可能对性能造成很大的危害</strong></p><ol><li>尽可能的让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽可能的缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务代销，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ol><p><strong>【select … lock in share model(共享锁)】：</strong></p><p>在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加IS锁，但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)。</p><p><strong>【select … for update(排他锁)】：</strong> </p><p>在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，for update之后并不会阻塞其他session的快照读取操作，除了select …lock in share mode和select … for update这种显示加锁的查询操作。</p><p><strong>lock in share mode适用于两张表存在业务关系时的一致性要求，for  update适用于操作同一张表时的一致性要求。</strong></p><h1 id="redis的String"><a href="#redis的String" class="headerlink" title="redis的String"></a>redis的String</h1><p>Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p><ul><li><p>int<br>保存long 型(长整型)的64位(8个字节)有符号整数</p></li><li><p>embstr：<br>代表 embstr 格式的 SDS(Simple Dynamic String 简单动态字符串),保存长度小于等于44字节的字符串<br>EMBSTR 顾名思义即：embedded string，表示嵌入式的String</p></li><li><p>raw<br>保存长度大于44字节的字符串</p></li></ul><p><a href="https://img-blog.csdnimg.cn/56817e4f1f924c7a90c29d519b8693a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zyf5ouo6byg6aWy5YW75ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/56817e4f1f924c7a90c29d519b8693a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zyf5ouo6byg6aWy5YW75ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://img-blog.csdnimg.cn/4efe3b38e340474aa52456955c5e1b1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zyf5ouo6byg6aWy5YW75ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/4efe3b38e340474aa52456955c5e1b1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zyf5ouo6byg6aWy5YW75ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><h3 id="key-ThreadLocal是强引用"><a href="#key-ThreadLocal是强引用" class="headerlink" title="key=ThreadLocal是强引用"></a>key=ThreadLocal是强引用</h3><ul><li><p>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</p></li><li><p>但是因为threadLocalMap的Entry强引用了threadLocal(key就是threadLocal), 造成ThreadLocal无法被回收</p></li><li><p>在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, 始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏</p></li></ul><p>  <strong>也就是说: ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的</strong></p><h3 id="key-ThreadLocal是弱引用"><a href="#key-ThreadLocal是弱引用" class="headerlink" title="key=ThreadLocal是弱引用"></a>key=ThreadLocal是弱引用</h3><ul><li>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</li><li>由于threadLocalMap只持有ThreadLocal的弱引用, 没有任何强引用指向threadlocal实例（这里Entry不再强引用ThreadLocal了）, 所以threadlocal就可以顺利被gc回收, 此时Entry中的key = null</li><li>在没有手动删除Entry以及CurrentThread依然运行的前提下, 也存在始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry,value就不会被回收, 而这块value永远不会被访问到了（因为key=null）, 导致value内存泄漏</li></ul><p><strong>也就是说: ThreadLocalMap中的key使用了弱引用, 也有可能内存泄漏</strong></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>文末的解释写更加清晰</strong></p><p>如果<code>ThreadLocalMap</code>的<code>key</code>为强引用回收<code>ThreadLocal</code>时，因为<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>就不会被回收，导致<code>Entry</code>内存泄漏。</p><p><code>ThreadLocalMap</code>的<code>key</code>为弱引用回收<code>ThreadLocal</code>时，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。当key为null，在下一次<code>ThreadLocalMap</code>调用set(),get(),remove()时会清除value的值。</p><p><strong>因此，<code>ThreadLocal</code>内存泄漏的根源是由于<code>ThreadLocalMap</code>的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不因为弱引用。</strong></p><p><strong><code>ThreadLocal</code>正确的使用方法：</strong></p><ol><li>每次使用完<code>ThreadLocal</code>都要调用它的remove()清除数据。</li><li>将<code>ThreadLoca</code>l变量定义成<code>private static</code>，这样就一直存在<code>ThreadLocal</code>的强引用，也能保证任何时候都能通过<code>ThreadLocal</code>的弱引用访问到Entry的value值，进而清除掉。</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/JH39456194/article/details/107304997" target="_blank" rel="noopener">threadlocal内存泄露问题</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>uploader</title>
    <link href="http://raptor1998.top/2022/03/29/uploader/"/>
    <id>http://raptor1998.top/2022/03/29/uploader/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-08-14T06:16:05.690Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p><strong><a href="https://github.com/Raptor1998/uploader" target="_blank" rel="noopener">https://github.com/Raptor1998/uploader</a></strong></p><h1 id="Uploader"><a href="#Uploader" class="headerlink" title="Uploader"></a>Uploader</h1><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li>Springboot 2.3.5 </li><li>Mybatis 1.3.2</li></ul><h2 id="content-path"><a href="#content-path" class="headerlink" title="content-path"></a>content-path</h2><p><code>/api/uploader</code></p><h2 id="upload-request-process"><a href="#upload-request-process" class="headerlink" title="upload request process"></a>upload request process</h2><h3 id="second-upload"><a href="#second-upload" class="headerlink" title="second upload"></a>second upload</h3><ol><li>计算文件的md5值，查询是否已经存在</li><li>是，根据文件名称和md5值实现秒传；否，直接上传</li></ol><h3 id="block-upload"><a href="#block-upload" class="headerlink" title="block upload"></a>block upload</h3><ol><li><p>计算文件md5值，根据需求切片，得到总片数</p></li><li><pre><code class="java"><span class="comment">/**</span><span class="comment"> * 分块上传</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> originalName 文件原名</span><span class="comment"> * <span class="doctag">@param</span> file         文件</span><span class="comment"> * <span class="doctag">@param</span> chunks       共分几块</span><span class="comment"> * <span class="doctag">@param</span> chunk        第几块</span><span class="comment"> * <span class="doctag">@param</span> size         文件总大小</span><span class="comment"> * <span class="doctag">@param</span> md5          文件的md5</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="meta">@PostMapping</span>(<span class="string">"/block/single"</span>)<span class="function"><span class="keyword">public</span> Result <span class="title">uploadBigSingleFile</span><span class="params">(@RequestParam(<span class="string">"originalName"</span>)</span> String originalName,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"chunks"</span>)</span> Integer chunks,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"chunk"</span>)</span> Integer chunk,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"size"</span>)</span> Long size,</span><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"md5"</span>)</span> String md5) </span>{    uploaderService.uploadWithBlock(originalName, file, chunks, size, chunk, md5);    <span class="keyword">return</span> ResultUtil.success(<span class="keyword">null</span>);}&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for block_file</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`block_file`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`block_file`</span>  (</span><br><span class="line">                               <span class="string">`block_file_id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">                               <span class="string">`block_file_chunk`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第几块'</span>,</span><br><span class="line">                               <span class="string">`block_file_md5`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'md5'</span>,</span><br><span class="line">                               <span class="string">`upload_time`</span> <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">COMMENT</span> <span class="string">'上传时间'</span>,</span><br><span class="line">                               <span class="string">`temp_path`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'临时文件的存储位置'</span>,</span><br><span class="line">                               PRIMARY <span class="keyword">KEY</span> (<span class="string">`block_file_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">                               <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`block_file_chunk`</span>(<span class="string">`block_file_chunk`</span>, <span class="string">`block_file_md5`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for file_info</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`file_info`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`file_info`</span>  (</span><br><span class="line">                              <span class="string">`file_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'文件详情'</span>,</span><br><span class="line">                              <span class="string">`file_original_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'原文件名'</span>,</span><br><span class="line">                              <span class="string">`file_union_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一标识'</span>,</span><br><span class="line">                              <span class="string">`file_real_path`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'真实路径'</span>,</span><br><span class="line">                              <span class="string">`file_suffix`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'拓展名'</span>,</span><br><span class="line">                              <span class="string">`file_url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'网络地址'</span>,</span><br><span class="line">                              <span class="string">`file_size`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文件大小'</span>,</span><br><span class="line">                              <span class="string">`file_upload_time`</span> <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">0</span>) <span class="keyword">COMMENT</span> <span class="string">'上传时间'</span>,</span><br><span class="line">                              <span class="string">`md5`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文件的md5值'</span>,</span><br><span class="line">                              PRIMARY <span class="keyword">KEY</span> (<span class="string">`file_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">                              <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`file_union_name`</span>(<span class="string">`file_union_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8 <span class="keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="keyword">Compact</span>;</span><br></pre></td></tr></tbody></table></figure></div><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.jianshu.com/p/d58d275ac1f4?ivk_sa=1024320u" target="_blank" rel="noopener">文件上传工具类（JAVA）</a></p><p><a href="https://github.com/gaoyuyue/MyUploader-Backend" target="_blank" rel="noopener">gaoyuyue/MyUploader-Backend</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://raptor1998.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo简单使用</title>
    <link href="http://raptor1998.top/2022/02/17/dubbo/"/>
    <id>http://raptor1998.top/2022/02/17/dubbo/</id>
    <published>2022-02-16T16:00:00.000Z</published>
    <updated>2022-04-25T01:36:51.382Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="Dubbo应用"><a href="#Dubbo应用" class="headerlink" title="Dubbo应用"></a>Dubbo应用</h1><h2 id="zookeeper宕机与dubbo直连"><a href="#zookeeper宕机与dubbo直连" class="headerlink" title="zookeeper宕机与dubbo直连"></a>zookeeper宕机与dubbo直连</h2><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。<br><strong>原因：</strong></p><ul><li><p>健壮性：</p><p>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong><br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p></li><li><p>高可用：通过设计，减少系统不能提供服务的时间；</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(url = <span class="string">"127.0.0.1:20882"</span>)  zookeeper注册中心宕机后可以通过dubbo直连方式进行服务者与消费者之间的通信</span><br></pre></td></tr></tbody></table></figure></div><h2 id="集群下dubbo负载均衡配置"><a href="#集群下dubbo负载均衡配置" class="headerlink" title="集群下dubbo负载均衡配置"></a>集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><h4 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h4><p><strong>基于权重的随机负载均衡机制</strong></p><p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220423170400390" class="fancybox"><img alt="image-20220423170400390" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220425093206.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220423170400390"></a></p><h4 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h4><p><strong>基于权重的轮询负载均衡机制</strong></p><p>轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220423170622615" class="fancybox"><img alt="image-20220423170622615" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220425093214.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220423170622615"></a></p><h4 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h4><p><strong>最少活跃数负载均衡机制</strong><br>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220423170804089" class="fancybox"><img alt="image-20220423170804089" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220425093219.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220423170804089"></a></p><h4 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h4><p><strong>一致性hash 负载均衡机制</strong></p><p>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220423170858341" class="fancybox"><img alt="image-20220423170858341" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220425093224.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220423170858341"></a></p><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p><ul><li>消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul><h3 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p>&lt;dubbo:service cluster=“failsafe” /&gt;或&lt;dubbo:reference cluster=“failsafe” /&gt;</p><h4 id="Failover-Cluster"><a href="#Failover-Cluster" class="headerlink" title="Failover Cluster"></a>Failover Cluster</h4><p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</p><h4 id="Failfast-Cluster"><a href="#Failfast-Cluster" class="headerlink" title="Failfast Cluster"></a>Failfast Cluster</h4><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><h4 id="Failsafe-Cluster"><a href="#Failsafe-Cluster" class="headerlink" title="Failsafe Cluster"></a>Failsafe Cluster</h4><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><h4 id="Failback-Cluster"><a href="#Failback-Cluster" class="headerlink" title="Failback Cluster"></a>Failback Cluster</h4><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><h4 id="Forking-Cluster"><a href="#Forking-Cluster" class="headerlink" title="Forking Cluster"></a>Forking Cluster</h4><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</p><h4 id="Broadcast-Cluster"><a href="#Broadcast-Cluster" class="headerlink" title="Broadcast Cluster"></a>Broadcast Cluster</h4><p>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220423174732984" class="fancybox"><img alt="image-20220423174732984" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220425093229.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220423174732984"></a></p><p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p><ol><li><strong>服务消费方（client）调用以本地调用方式调用服务；</strong></li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li><strong>服务消费方得到最终结果。</strong></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      Dubbo
    
    </summary>
    
    
      <category term="Dubbo" scheme="http://raptor1998.top/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://raptor1998.top/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>JVM——垃圾回收篇</title>
    <link href="http://raptor1998.top/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"/>
    <id>http://raptor1998.top/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/</id>
    <published>2022-01-19T16:00:00.000Z</published>
    <updated>2022-03-16T08:04:13.624Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h1><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。 </p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：</p><ul><li><p>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</p></li><li><p>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712102205795" class="fancybox"><img alt="image-20200712102205795" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173812.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712102205795"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>{</span><br><span class="line">    <span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line">    <span class="comment">//java 使用的不是引用计数算法</span></span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712103230349" class="fancybox"><img alt="image-20200712103230349" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173807.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712103230349"></a></p></li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>“GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712104149246" class="fancybox"><img alt="image-20200712104149246" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173803.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712104149246"></a></p><h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（string Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize（）方法<ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>{</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20220107153758261" class="fancybox"><img alt="image-20220107153758261" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173756.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20220107153758261"></a></p><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p><strong>标记</strong>：Collector从引用根节点开始遍历，</p><p>标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p><p><strong>标记的是引用的对象，不是垃圾！！</strong></p></li><li><p><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p></li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712150935078" class="fancybox"><img alt="image-20200712150935078" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173750.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712150935078"></a></p><h4 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候 提过</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712151916991" class="fancybox"><img alt="image-20200712151916991" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173745.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712151916991"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200712153236508" class="fancybox"><img alt="image-20200712153236508" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173740.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200712153236508"></a></p><h4 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h4><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul><li><p>Java虚拟机的堆内存设置不够。</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p></li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏</p><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p><blockquote><p>Java不同版本新特性</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li></ul></blockquote><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713083030867" class="fancybox"><img alt="image-20200713083030867" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173734.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713083030867"></a></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713083443486" class="fancybox"><img alt="image-20200713083443486" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173729.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713083443486"></a></p><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java堆区所占的内存大小。</li><li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h3 id="性能指标：吞吐量"><a href="#性能指标：吞吐量" class="headerlink" title="性能指标：吞吐量"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><blockquote><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713084726176" class="fancybox"><img alt="image-20200713084726176" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173724.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713084726176"></a></p><h3 id="性能指标：暂停时间"><a href="#性能指标：暂停时间" class="headerlink" title="性能指标：暂停时间"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p><p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713085306400" class="fancybox"><img alt="image-20200713085306400" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173721.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713085306400"></a></p><h3 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><p>那么，Java常见的垃圾收集器有哪些？</p><blockquote><p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p></blockquote><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li></ul><h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G11</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713093551365" class="fancybox"><img alt="image-20200713093551365" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173715.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713093551365"></a></p><h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713093757644" class="fancybox"><img alt="image-20200713093757644" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173712.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713093757644"></a></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1；</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713094745366" class="fancybox"><img alt="image-20200713094745366" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173703.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713094745366"></a></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li><li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li></ul><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial 0ld在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713100703799" class="fancybox"><img alt="image-20200713100703799" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173700.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713100703799"></a></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><p>等价于新生代用Serial GC，且老年代用Serial old GC</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713102030127" class="fancybox"><img alt="image-20200713102030127" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713102030127"></a></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p></li></ul><p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713110359441" class="fancybox"><img alt="image-20200713110359441" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173650.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713110359441"></a></p><p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p><p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p><p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p><p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713205154007" class="fancybox"><img alt="image-20200713205154007" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173644.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713205154007"></a></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713212230352" class="fancybox"><img alt="image-20200713212230352" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173638.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713212230352"></a></p><h3 id="CMS为什么不使用标记整理算法？"><a href="#CMS为什么不使用标记整理算法？" class="headerlink" title="CMS为什么不使用标记整理算法？"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li></ul><p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p><ul><li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li></ul><p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><ul><li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li><li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li></ul><p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li></ul><h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><h3 id="为什么名字叫-Garbage-First-G1-呢？"><a href="#为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫 Garbage First(G1)呢？"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p><h3 id="G1垃圾收集器的优点"><a href="#G1垃圾收集器的优点" class="headerlink" title="G1垃圾收集器的优点"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713215105293" class="fancybox"><img alt="image-20200713215105293" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173631.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713215105293"></a></p><p>而是这样的一个区域</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713215133839" class="fancybox"><img alt="image-20200713215133839" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173628.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713215133839"></a></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200326121914326" class="fancybox"><img alt="image-20200326121914326" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220316160315.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200326121914326"></a></p><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p><h3 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p><ul><li>超过5e%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于e.5至1秒）</li></ul><p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p><p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713223244886" class="fancybox"><img alt="image-20200713223244886" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173615.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713223244886"></a></p><p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过指针碰撞来分配空间</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713223509993" class="fancybox"><img alt="image-20200713223509993" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173609.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713223509993"></a></p><h3 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713224113996" class="fancybox"><img alt="image-20200713224113996" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173604.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713224113996"></a></p><p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713224716715" class="fancybox"><img alt="image-20200713224716715" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173558.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713224716715"></a></p><h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713225100632" class="fancybox"><img alt="image-20200713225100632" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173553.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713225100632"></a></p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根</li></ul><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><ul><li>第二阶段，更新RSet</li></ul><p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li>第三阶段，处理RSet</li></ul><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><ul><li>第四阶段，复制对象。</li></ul><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><ul><li>第五阶段，处理引用</li></ul><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200713225810871" class="fancybox"><img alt="image-20200713225810871" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173547.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200713225810871"></a></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p><p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="G1回收可选的过程4-Full-GC"><a href="#G1回收可选的过程4-Full-GC" class="headerlink" title="G1回收可选的过程4 - Full GC"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p><ul><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖</li></ul><p>暂停时间目标暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200714075738203" class="fancybox"><img alt="image-20200714075738203" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173542.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200714075738203"></a></p><p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="image-20200714080151020" class="fancybox"><img alt="image-20200714080151020" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224173531.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title="image-20200714080151020"></a></p><h1 id="推荐笔记"><a href="#推荐笔记" class="headerlink" title="推荐笔记"></a>推荐笔记</h1><p> <strong><a href="https://gitee.com/moxi159753" target="_blank" rel="noopener">陌溪</a> / <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">LearningNotes</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JVM
    
    </summary>
    
    
      <category term="JVM" scheme="http://raptor1998.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://raptor1998.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM——内存篇</title>
    <link href="http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/</id>
    <published>2021-12-14T16:00:00.000Z</published>
    <updated>2022-02-24T09:31:25.754Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="内存篇"><a href="#内存篇" class="headerlink" title="内存篇"></a>内存篇</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" data-fancybox="group" data-caption="image-20200705081813409" class="fancybox"><img alt="image-20200705081813409" title="image-20200705081813409" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" data-fancybox="group" data-caption="image-20200705082255746" class="fancybox"><img alt="image-20200705082255746" title="image-20200705082255746" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>完整的流程图如下所示</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" data-fancybox="group" data-caption="image-20200705082601441" class="fancybox"><img alt="image-20200705082601441" title="image-20200705082601441" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" data-fancybox="group" data-caption="image-20200705103636003" class="fancybox"><img alt="image-20200705103636003" title="image-20200705103636003" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己创建一个java.lang的包并创建String类</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"自定义的String类"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">   public static void main(String[] args)</span></span><br><span class="line"><span class="comment">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" data-fancybox="group" data-caption="image-20200705112416101" class="fancybox"><img alt="image-20200705112416101" title="image-20200705112416101" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" data-fancybox="group" data-caption="image-20200705112601211" class="fancybox"><img alt="image-20200705112601211" title="image-20200705112601211" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><p><strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h4><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" data-fancybox="group" data-caption="image-20200705161409533" class="fancybox"><img alt="image-20200705161409533" title="image-20200705161409533" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h4><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>栈是运行时的单位，而堆是存储的单位。</strong></p><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。<strong>是线程私有的。</strong></p><h3 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h3><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p><p><strong>可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" data-fancybox="group" data-caption="image-20211228155503154" class="fancybox"><img alt="image-20211228155503154" title="image-20211228155503154" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" data-fancybox="group" data-caption="image-20211228195446901" class="fancybox"><img alt="image-20211228195446901" title="image-20211228195446901" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" data-fancybox="group" data-caption="image-20211229144922052" class="fancybox"><img alt="image-20211229144922052" title="image-20211229144922052" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><p><a href="https://blog.csdn.net/weixin_43723712/article/details/92187693" target="_blank" rel="noopener">i++与++i在JVM层面上的分析</a></p><p><a href="https://blog.csdn.net/weixin_38405253/article/details/118470431" target="_blank" rel="noopener">从JVM层面来解释i++和++i的真正区别</a></p><h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><ul><li><p>举例栈溢出的情况？（StackOverflowError）</p><ul><li>通过 -Xss设置栈的大小</li></ul></li><li><p>调整栈大小，就能保证不出现溢出么？</p><ul><li>不能保证不溢出</li></ul></li><li><p>分配的栈内存越大越好么？</p><ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li><p>垃圾回收是否涉及到虚拟机栈？</p><ul><li>不会</li></ul></li><li><p>方法中定义的局部变量是否线程安全？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>{</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p>一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h3><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区 Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。  </p><p><strong>-Xms300m -Xmx300m -XX:+PrintGCDetails</strong></p><p><strong>设置为300M却不足，是因为幸存区只能有一个用来存储。</strong>  </p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" data-fancybox="group" data-caption="image-20211230203337495" class="fancybox"><img alt="image-20211230203337495" title="image-20211230203337495" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" data-fancybox="group" data-caption="image-20200707075847954" class="fancybox"><img alt="image-20200707075847954" title="image-20200707075847954" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p> 配置新生代与老年代在堆结构的占比。</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" data-fancybox="group" data-caption="image-20200707080154039" class="fancybox"><img alt="image-20200707080154039" title="image-20200707080154039" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：<strong>-Xx:MaxTenuringThreshold= N</strong>进行设置</p><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" data-fancybox="group" data-caption="image-20200707084714886" class="fancybox"><img alt="image-20200707084714886" title="image-20200707084714886" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" data-fancybox="group" data-caption="image-20200707085737207" class="fancybox"><img alt="image-20200707085737207" title="image-20200707085737207" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="幸存者区空间不足"><a href="#幸存者区空间不足" class="headerlink" title="幸存者区空间不足"></a>幸存者区空间不足</h4><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" data-fancybox="group" data-caption="image-20200707091058346" class="fancybox"><img alt="image-20200707091058346" title="image-20200707091058346" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><ul><li><p>Minor GC：新生代的GC</p></li><li><p>Major GC：老年代的GC</p></li><li><p>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ul><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h3 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h3><h4 id="Q-堆空间都是共享的吗"><a href="#Q-堆空间都是共享的吗" class="headerlink" title="Q: 堆空间都是共享的吗"></a>Q: 堆空间都是共享的吗</h4><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h4 id="为什么有TLAB"><a href="#为什么有TLAB" class="headerlink" title="为什么有TLAB"></a>为什么有TLAB</h4><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h4 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h4><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" data-fancybox="group" data-caption="image-20200707103547712" class="fancybox"><img alt="image-20200707103547712" title="image-20200707103547712" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h4 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h4><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" data-fancybox="group" data-caption="image-20200707104253530" class="fancybox"><img alt="image-20200707104253530" title="image-20200707104253530" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h3><ul><li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li><li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li><li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li><li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li><li>-Xmn：设置新生代的大小。（初始值及最大值）</li><li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li><li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li><li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li><li>-XX：+PrintGCDetails：输出详细的GC处理日志<ul><li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li></ul></li><li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li></ul><h3 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBufferON</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果想要StringBuffer sb不发生逃逸，可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBufferOFF</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h5><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="如何解决方法区的OOM"><a href="#如何解决方法区的OOM" class="headerlink" title="如何解决方法区的OOM"></a>如何解决方法区的OOM</h3><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h3><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" data-fancybox="group" data-caption="image-20200708211541300" class="fancybox"><img alt="image-20200708211541300" title="image-20200708211541300" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>JDK7的时候</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" data-fancybox="group" data-caption="image-20200708211609911" class="fancybox"><img alt="image-20200708211609911" title="image-20200708211609911" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" data-fancybox="group" data-caption="image-20200708211637952" class="fancybox"><img alt="image-20200708211637952" title="image-20200708211637952" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h4><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h2><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>给对象属性赋值的操作</p><ul><li>属性的默认初始化</li><li>显示初始化</li><li>代码块中的初始化</li><li>构造器初始化</li><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li></ul><h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h4 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul><li>String：字符串，使用一对 ”” 引起来表示<ul><li>String s1 = “mogublog” ; // 字面量的定义方式</li><li>String s2 = new String(“moxi”);</li></ul></li><li>string声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul><h4 id="JDK9改变了结构"><a href="#JDK9改变了结构" class="headerlink" title="JDK9改变了结构"></a>JDK9改变了结构</h4><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">private final char value[];</span><br><span class="line">// 之后</span><br><span class="line">private final byte[] value</span><br></pre></td></tr></tbody></table></figure></div><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h4 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h4><p>String：代表不可变的字符序列。简称：不可变性。</p><blockquote><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">"def"</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">'a'</span>, <span class="string">'m'</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//hello</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//abcdef</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//mbc</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>{</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = {<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>{</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);   <span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);    <span class="comment">//best</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h3><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><blockquote><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p></blockquote><p>Java8元空间，字符串常量在堆</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" data-fancybox="group" data-caption="image-20200711093546398" class="fancybox"><img alt="image-20200711093546398" title="image-20200711093546398" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" data-fancybox="group" data-caption="image-20200711093558709" class="fancybox"><img alt="image-20200711093558709" title="image-20200711093558709" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h4><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h3 id="拼接操作"><a href="#拼接操作" class="headerlink" title="拼接操作"></a>拼接操作</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String s1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;  <span class="comment">// 得到 abc的常量池</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>; <span class="comment">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true，因为存放在字符串常量池</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    String src = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        src += <span class="string">"a"</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        sb.append(<span class="string">"a"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><h4 id="new-String-“as”-会创建几个对象"><a href="#new-String-“as”-会创建几个对象" class="headerlink" title="new String(“as”)会创建几个对象"></a>new String(“as”)会创建几个对象</h4><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><h4 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h4><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_44259720/article/details/88237822" target="_blank" rel="noopener">Java 定义字符串时：String 和 new String() 的区别</a></p><h3 id="美团：深入解析String-intern"><a href="#美团：深入解析String-intern" class="headerlink" title="美团：深入解析String#intern"></a><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团：深入解析String#intern</a></h3><h3 id="intern题目"><a href="#intern题目" class="headerlink" title="intern题目"></a>intern题目</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" data-fancybox="group" data-caption="image-20220107101214463" class="fancybox"><img alt="image-20220107101214463" title="image-20220107101214463" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" data-fancybox="group" data-caption="image-20220107101237047" class="fancybox"><img alt="image-20220107101237047" title="image-20220107101237047" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" data-fancybox="group" data-caption="image-20220107101245959" class="fancybox"><img alt="image-20220107101245959" title="image-20220107101245959" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="idea安装jclasslib"><a href="#idea安装jclasslib" class="headerlink" title="idea安装jclasslib"></a>idea安装jclasslib</h2><p>选中字节码文件，view中show With Jclasslib即可查看字节码指令</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" data-fancybox="group" data-caption="image-20211227170720770" class="fancybox"><img alt="image-20211227170720770" title="image-20211227170720770" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="Notepad-字节码"><a href="#Notepad-字节码" class="headerlink" title="Notepad++字节码"></a>Notepad++字节码</h2><p><a href="https://github.com/chcg/NPP_HexEdit/releases/tag/0.9.5.11" target="_blank" rel="noopener">HexEdit下载地址</a></p><p>下载对应版本的dll文件，在notepad++插件文件夹创建HexEdit文件夹，将解压的dll文件放入，重启即可。</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" data-fancybox="group" data-caption="image-20211227170551121" class="fancybox"><img alt="image-20211227170551121" title="image-20211227170551121" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="VisualVM插件GC安装"><a href="#VisualVM插件GC安装" class="headerlink" title="VisualVM插件GC安装"></a>VisualVM插件GC安装</h2><p><a href="https://blog.csdn.net/weixin_45759791/article/details/107332860" target="_blank" rel="noopener">VisualVM安装VisualGC插件</a></p><p> <a href="https://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">Plugins Centers 插件中心</a></p><h1 id="推荐笔记"><a href="#推荐笔记" class="headerlink" title="推荐笔记"></a>推荐笔记</h1><p> <strong><a href="https://gitee.com/moxi159753" target="_blank" rel="noopener">陌溪</a> / <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">LearningNotes</a></strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JVM
    
    </summary>
    
    
      <category term="JVM" scheme="http://raptor1998.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://raptor1998.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>高频面试 Ι</title>
    <link href="http://raptor1998.top/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/"/>
    <id>http://raptor1998.top/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2022-02-24T09:34:06.337Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><h2 id="自增变量"><a href="#自增变量" class="headerlink" title="自增变量"></a>自增变量</h2><p>赋值=，最后计算<br>=右边的从左到右加载至一次压入操作数栈<br>实际先算那个，看远算符优先级<br>自增、自减操作都是字节修改变量的值，不经过操作数栈<br>最后额赋值之前，临时结果也存储在操作数栈中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//i=1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=1</span></span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="comment">// j =1 i = 2</span></span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="comment">// k=11 j=1 i=4</span></span><br><span class="line">    <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">    System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">    System.out.println(<span class="string">"j="</span> + j);</span><br><span class="line">    System.out.println(<span class="string">"k="</span> + k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有一个实例</span></span><br><span class="line"><span class="comment"> * 必须自行创建这个实例</span></span><br><span class="line"><span class="comment"> * 向整个系统提供这个实例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 饿汉式：直接创建对象，不存在线程安全问题</span></span><br><span class="line"><span class="comment"> * 1.直接实例化饿汉式</span></span><br><span class="line"><span class="comment"> * 2.枚举式</span></span><br><span class="line"><span class="comment"> * 3.静态代码块（适合复杂实例化）</span></span><br><span class="line"><span class="comment"> * 懒汉式：延迟创建对象</span></span><br><span class="line"><span class="comment"> * 4.线程不安全（使用单线程）</span></span><br><span class="line"><span class="comment"> * 5.线程安全</span></span><br><span class="line"><span class="comment"> * 6.静态内部类（使用多线程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Singleton2 {</span><br><span class="line">    INSTANCE</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当string需要动态获取</span></span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        String s1 = <span class="string">"xxx"</span>;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton3(s1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//部分逻辑  线程不安全</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton5();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态被不累不会自动随着外部类的加载和初始化而初始化，他是单独去加载和初始化的</span></span><br><span class="line">    <span class="comment">//因为实在内部类加载和初始化，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1.j=method()</span></span><br><span class="line"><span class="comment"> * 2.父类的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 父类实例化方法：</span></span><br><span class="line"><span class="comment"> * 1.super()（最前）</span></span><br><span class="line"><span class="comment"> * 2.i=test()</span></span><br><span class="line"><span class="comment"> * 3.父类的非静态代码块</span></span><br><span class="line"><span class="comment"> * 4.父类的无参构造（最后）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 非静态方法前面有一个默认地向this</span></span><br><span class="line"><span class="comment"> * this在构造器或&lt;init&gt;()它表示的是正在创建的对象，因为这里创建的Son对象，所以</span></span><br><span class="line"><span class="comment"> * test()执行的是子类重写的代码</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这里i=test()执行的是子类重写的test()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"(1)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Father() {</span><br><span class="line">        System.out.println(<span class="string">"(2)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"(3)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(4)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(5)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1.j=method()</span></span><br><span class="line"><span class="comment"> * 2.子类的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 先初始化父类  （5）（1）</span></span><br><span class="line"><span class="comment"> * 初始化子类 （10） （6）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 子类实例化方法：</span></span><br><span class="line"><span class="comment"> * 1.super()（最前）  （9） （3） （2）</span></span><br><span class="line"><span class="comment"> * 2.i=test()          （9）</span></span><br><span class="line"><span class="comment"> * 3.子类的非静态代码块    （8）</span></span><br><span class="line"><span class="comment"> * 4.子类的无参构造（最后）   （7）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 因为创建了两个Son对象，因此实例化方法&lt;init&gt;()执行两次</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * （9） （3） （2） （9） （8） （7）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 哪些方法不能被重写：</span></span><br><span class="line"><span class="comment"> * final方法</span></span><br><span class="line"><span class="comment"> * 静态方法</span></span><br><span class="line"><span class="comment"> * private等子类中不可见方法</span></span><br><span class="line"><span class="comment"> * 对象的多态：</span></span><br><span class="line"><span class="comment"> * 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</span></span><br><span class="line"><span class="comment"> * 非静态方法默认的调用对象是this</span></span><br><span class="line"><span class="comment"> * this对象在构选器或者说&lt;init&gt;方法中就是正在创建的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"(6)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Son() {</span><br><span class="line">        <span class="comment">//super();   写或不写，在子类构造器中一定会调用父类的构造器</span></span><br><span class="line">        System.out.println(<span class="string">"(7)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"(8)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(9)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"(10)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 类初始化过程：</span></span><br><span class="line"><span class="comment">         * 1.一个类的创建实例需要先加载初始化该类</span></span><br><span class="line"><span class="comment">         *      main方法所在的类需要先加载和初始化</span></span><br><span class="line"><span class="comment">         *      仅发生类初始化 ，不发生实例初始化 （5）（1）（10）（6）</span></span><br><span class="line"><span class="comment">         * 2.一个子类要初始化需要先初始化父类</span></span><br><span class="line"><span class="comment">         * 3.一个类初始化就是执行&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;clinit&gt;方法由静态类变量显示赋值代码和静态代码块组成</span></span><br><span class="line"><span class="comment">         *      类变量显式赋值代码和静态代码块代码从上到下顺序执行</span></span><br><span class="line"><span class="comment">         *      &lt;clinit&gt;方法只执行一次</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 实例初始化过程：</span></span><br><span class="line"><span class="comment">         * 1.实力初始化就是执行&lt;init&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;()方法可能重在有多个，有几个构造器就有几个&lt;init&gt;()方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</span></span><br><span class="line"><span class="comment">         *      非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行</span></span><br><span class="line"><span class="comment">         *      每次创建实例对象，调用对应构造器，执行的就是对应的&lt;init&gt;方法</span></span><br><span class="line"><span class="comment">         *      &lt;init&gt;方法的首行是super()或super(实参列表)，即对应父类的&lt;init&gt;方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Son son1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son son2 = <span class="keyword">new</span> Son();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>方法重载的规则？</strong></p><p>方法名一致，参数列表中参数的顺序，类型，个数不同。</p><p>重载与方法的返回值无关，存在于父类和子类，同类中。</p><p>可以抛出不同的异常，可以有不同修饰符。</p><p><strong>方法重写的规则？</strong></p><p>参数列表、方法名、返回值类型必须完全一致，构造方法不能被重写；</p><p>声明为 final 的方法 不能被重写；</p><p>声明为 static 的方法不存在重写(重写和多态联合才有意义);</p><p>访问权限不能比 父类更低;重写之后的方法不能抛出更宽泛的异常</p><p><strong>重载和重写的区别？</strong></p><p>方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。</p><p>重写 Overriding 是父类与子类之间多态性的一种表现，</p><p>重载 Overloading 是一个类中多态性的一种表现。</p><p>如 果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽” 了。</p><p>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型， 则称为方法的重载(Overloading)。</p><h2 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"num="</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">"my.a="</span> + my.a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实参给形参赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 基本数据类型  数据值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 引用数据类型  地址值     String、包装类等对象不可变性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>{</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">"world"</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println( m.a);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="E:%5Cmaterial%5Cmd%5Cimage-20211109105042940.png" data-fancybox="group" data-caption="image-20211109105042940" class="fancybox"><img alt="image-20211109105042940" title="image-20211109105042940" data-src="E:%5Cmaterial%5Cmd%5Cimage-20211109105042940.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="E:%5Cmaterial%5Cmd%5Cimage-20211109105119544.png" data-fancybox="group" data-caption="image-20211109105119544" class="fancybox"><img alt="image-20211109105119544" title="image-20211109105119544" data-src="E:%5Cmaterial%5Cmd%5Cimage-20211109105119544.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h2><p>n个台阶，一次只能走一阶或两阶，问有多少种走法？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    System.out.println(go(<span class="number">4</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> go(n - <span class="number">2</span>) + go(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam6</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量：每个线程，每次调用执行的都是新的声明周期</span></span><br><span class="line"><span class="comment">     * 实例变量：随着对象的创建而初始化，随着对象的回收而消亡，每一个实例变量都是独立的</span></span><br><span class="line"><span class="comment">     * 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量：栈</span></span><br><span class="line"><span class="comment">     * 实例变量：堆</span></span><br><span class="line"><span class="comment">     * 类变量：方法去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//就近原则</span></span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//作用域</span></span><br><span class="line">        i++;</span><br><span class="line">        s++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Exam6 obj1 = <span class="keyword">new</span> Exam6();</span><br><span class="line">        Exam6 obj2 = <span class="keyword">new</span> Exam6();</span><br><span class="line">        obj1.test(<span class="number">10</span>);</span><br><span class="line">        obj1.test(<span class="number">20</span>);</span><br><span class="line">        obj2.test(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        i=2,j=1,s=5</span></span><br><span class="line"><span class="comment">        i=1,j=1,s=5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"i="</span> + obj1.i + <span class="string">",j="</span> + obj1.j + <span class="string">",s="</span> + s);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + obj2.i + <span class="string">",j="</span> + obj2.j + <span class="string">",s="</span> + s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul><li><p>事务的属性</p><p>propagation：用来设置事务的传播行为</p><p>事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务</p><ul><li>Propagation.REQUIRED：默认值，使用原来的事务</li><li>Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务</li></ul></li><li><p>isolation：用来设置事物的隔离级别</p><ul><li><p>Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别</p></li><li><p>Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，并发誓通常使用的隔离级别 </p></li></ul></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>B2C电商实践</title>
    <link href="http://raptor1998.top/2021/10/15/B2C%E7%94%B5%E5%95%86/"/>
    <id>http://raptor1998.top/2021/10/15/B2C%E7%94%B5%E5%95%86/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2021-12-29T09:53:55.342Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="B2C"><a href="#B2C" class="headerlink" title="B2C"></a>B2C</h1><p>尚硅谷谷粒商城的demo及部分解决方法笔记，<strong>不是完整的代码</strong>。</p><p><a href="https://gitee.com/agoni_no/gulimall?_from=gitee_search" target="_blank" rel="noopener">夏沫止水/gulimall</a></p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="Nacos集群启动问题"><a href="#Nacos集群启动问题" class="headerlink" title="Nacos集群启动问题"></a>Nacos集群启动问题</h2><h3 id="数据库配置-bin"><a href="#数据库配置-bin" class="headerlink" title="数据库配置(bin/)"></a>数据库配置(bin/)</h3><p><code>将nacos-mysql.sql执行</code></p><h3 id="配置文件-conf"><a href="#配置文件-conf" class="headerlink" title="配置文件(conf/)"></a>配置文件(conf/)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################最后追加###################</span></span><br><span class="line"><span class="string">spring.datasource.platform=mysql</span></span><br><span class="line"></span><br><span class="line"><span class="string">db.num=1</span></span><br><span class="line"><span class="string">db.url.0=jdbc:mysql://127.0.0.1:3306/cloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="string">db.user=root</span></span><br><span class="line"><span class="string">db.password=****</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="配置cluster-conf"><a href="#配置cluster-conf" class="headerlink" title="配置cluster.conf"></a>配置cluster.conf</h3><p><strong>这个IP不能写127.0.0.1,必须是Linux命令hostname -i能够识别的IP</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp cluster.conf.example cluster.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置集群信息</span></span><br><span class="line">vim cluster.conf</span><br><span class="line"></span><br><span class="line">182.154.146.46:3333</span><br><span class="line">182.154.146.46:4444</span><br><span class="line">182.154.146.46:5555</span><br></pre></td></tr></tbody></table></figure></div><h3 id="启动脚本-bin"><a href="#启动脚本-bin" class="headerlink" title="启动脚本(bin/)"></a>启动脚本(bin/)</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175846.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175846.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175847.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211017175847.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p><strong>./startup.sh -p 3333</strong></p><h3 id="内存不足启动解决"><a href="#内存不足启动解决" class="headerlink" title="内存不足启动解决"></a>内存不足启动解决</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">standalone：表示单机模式运行，非集群模式</span><br><span class="line">-Xms: 设定程序启动时占用内存大小</span><br><span class="line">-Xmx: 设定程序运行期间最大可占用的内存大小</span><br><span class="line">-Xmn：新生代大小</span><br></pre></td></tr></tbody></table></figure></div><p><strong>JAVA_OPT=”${JAVA_OPT} -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m”</strong></p><p>更改为，比如，可根据机器调整</p><p><strong>JAVA_OPT=”${JAVA_OPT} -server -Xms300m -Xmx300m -Xmn100m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=160m”</strong></p><h3 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream cluster{                                                        </span><br><span class="line">    server 127.0.0.1:3333;</span><br><span class="line">    server 127.0.0.1:4444;</span><br><span class="line">    server 127.0.0.1:5555;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server{                       </span><br><span class="line">    listen 1111;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location /{</span><br><span class="line">         proxy_pass http://cluster;                                               </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="renren-fast-oss-报错问题"><a href="#renren-fast-oss-报错问题" class="headerlink" title="renren-fast oss 报错问题"></a>renren-fast oss 报错问题</h1><p><strong>依赖改为继承自root项目</strong></p><h1 id="idea热部署不生效"><a href="#idea热部署不生效" class="headerlink" title="idea热部署不生效"></a>idea热部署不生效</h1><ul><li><p><strong>File-Settings-Compiler-Build project automatically</strong></p></li><li><p><strong>ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running</strong></p></li></ul><h1 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h1><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="meta">@NotBlank</span>(message = <span class="string">"品牌名必须提交"</span>,groups = {AddGroup<span class="class">.<span class="keyword">class</span>,<span class="title">UpdateGroup</span>.<span class="title">class</span>})</span></span><br><span class="line"><span class="class">   给校验直接添加分组</span></span><br><span class="line"><span class="class">2. @<span class="title">Validated</span>(</span>{UpdateGroup<span class="class">.<span class="keyword">class</span>}) </span></span><br><span class="line"><span class="class">   标注校验的分组</span></span><br><span class="line"><span class="class">   默认没有指定的分组的注解，分组校验的情况下不会生效</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 编写自定义校验注解</span><br><span class="line"><span class="number">2</span>. 编写自定义校验器</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = {ListValueConstrainValidation<span class="class">.<span class="keyword">class</span>})</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>{ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue {</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>{com.raptor.common.valid.ListValue.message}<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default {};</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default {};</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] vals() default {};</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class ListValueConstrainValidation implements ConstraintValidator&lt;ListValue, Integer&gt; {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public void initialize(ListValue constraintAnnotation) {</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        int[] vals = constraintAnnotation.vals();</span></span><br><span class="line"><span class="string">        for (int val : vals) {</span></span><br><span class="line"><span class="string">            set.add(val);</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    //判断是否校验成功</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public boolean isValid(Integer s, ConstraintValidatorContext constraintValidatorContext) {</span></span><br><span class="line"><span class="string">        return set.contains(s);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">3. 编写自定义的返回信息 ValidationMessages.properties</span></span><br><span class="line"><span class="string">com.raptor.common.valid.ListValue.message=必须是指定的值</span></span><br><span class="line"><span class="string">4. 关联自定义的校验器和自定义的注解</span></span><br><span class="line"><span class="string">@Constraint(validatedBy = {ListValueConstrainValidation.class})</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><h2 id="docker安装elasticsearch"><a href="#docker安装elasticsearch" class="headerlink" title="docker安装elasticsearch"></a>docker安装elasticsearch</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. 下载镜像</span><br><span class="line">docker pull elasticsearch:7.6.2</span><br><span class="line">2. 创建一个挂载目录</span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line">echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line">3. 启动</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300  -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx128m" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line">其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件</span><br><span class="line"></span><br><span class="line">4. 权限问题</span><br><span class="line">docker logs elasticsearch 查看日志 发现报无权限错误</span><br><span class="line">"Caused by: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes"</span><br><span class="line">添加权限</span><br><span class="line">chmod -R 777 /mydata/elasticsearch/</span><br><span class="line"></span><br><span class="line">-e "discovery.type=single-node" 设置为单节点</span><br><span class="line">-e ES_JAVA_OPTS="-Xms256m -Xmx256m" \ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 访问http://your ipadress:9200/   说明启动成功</span><br><span class="line">{</span><br><span class="line">  "name" : "26e50cad52d5",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "RrKY3rRZRW2nh7Ap-rIjvQ",</span><br><span class="line">  "version" : {</span><br><span class="line">    "number" : "7.6.2",</span><br><span class="line">    "build_flavor" : "default",</span><br><span class="line">    "build_type" : "docker",</span><br><span class="line">    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    "build_date" : "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "8.4.0",</span><br><span class="line">    "minimum_wire_compatibility_version" : "6.8.0",</span><br><span class="line">    "minimum_index_compatibility_version" : "6.0.0-beta1"</span><br><span class="line">  },</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="docker安装Kibana"><a href="#docker安装Kibana" class="headerlink" title="docker安装Kibana"></a>docker安装Kibana</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.6.2</span><br><span class="line"></span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://your ipaddress:9200 -p 5601:5601 -d kibana:7.6.2</span><br></pre></td></tr></tbody></table></figure></div><h1 id="nginx转发到网关时请求的host丢失"><a href="#nginx转发到网关时请求的host丢失" class="headerlink" title="nginx转发到网关时请求的host丢失"></a>nginx转发到网关时请求的host丢失</h1><p>xxx</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存溢出问题"><a href="#缓存溢出问题" class="headerlink" title="缓存溢出问题"></a>缓存溢出问题</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 性能优化  改为一次查询数据库</span></span><br><span class="line"><span class="comment">// 堆外内存溢出  springboot 2.0默认使用lettuce操作redis客户端  使用netty进行网络通信</span></span><br><span class="line"><span class="comment">// lettuce的bug导致netty堆外内存溢出   -Xmx300m  netty如果乜有指定堆外内存 默认使用 -Xmx300m 不能使用 可以通过 -Dio.netty.maxDirectMeory去调到堆外内存</span></span><br><span class="line"><span class="comment">// 解决方案：升级lettuce客户端    切换使用jedis</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>只查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，数据库无此记录，没有将null写到缓存，导致每次请求都要取存储层查询。</p><p>可以利用不存在的数据进行攻击，数据库压力增大，最终导致崩溃</p><p>解决方案：null结果缓存，并加入短暂过期时间</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>值设置缓存是key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到db，cb压力过大雪崩</p><p>原有的时效基础上增加一个随机值，比如1-5分钟随机，这样每个缓存的过期时间重复率就会降低，很难引发集体失效时间。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被炒高并发访问，是一种热点数据，如果这个key在大量请求同时进来前刚好失效，所有对这个key 的查询都落到db</p><p>解决：加锁，大量并发只让一个人去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据。</p><h2 id="redis的分布式锁"><a href="#redis的分布式锁" class="headerlink" title="redis的分布式锁"></a>redis的分布式锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占分布式锁</span></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>,TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock) {</span><br><span class="line">    System.out.println(<span class="string">"获取分布式锁成功"</span>);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//加锁成功</span></span><br><span class="line">        dataFromDb = getDataFromDb();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        <span class="comment">//删锁</span></span><br><span class="line">        stringRedisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList("lock"), uuid);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//只删除自己的锁</span></span><br><span class="line">    <span class="comment">//获取值对比，对比成功删除=原子性 lua脚本解锁</span></span><br><span class="line">    <span class="comment">//可能会出现删除其他线程锁的情况   在业务执行尾，获取到自己的数据后，传输过程中锁过期，执行删除锁命令，将其他线程锁删除</span></span><br><span class="line">    <span class="comment">// String lockValue = stringRedisTemplate.opsForValue().get("lock");</span></span><br><span class="line">    <span class="comment">// if (uuid.equals(lockValue)) {</span></span><br><span class="line">    <span class="comment">//     //只能删除我自己的锁</span></span><br><span class="line">    <span class="comment">//     stringRedisTemplate.delete("lock");</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataFromDb;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    System.out.println(<span class="string">"获取分布式锁失败"</span>);</span><br><span class="line">    <span class="comment">//加锁失败</span></span><br><span class="line">    <span class="keyword">try</span> { TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); } <span class="keyword">catch</span> (InterruptedException e) { e.printStackTrace(); }</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> getCatalogJsonFromDbWithRedisLock();     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><h3 id="双写模式（更新完数据更新缓存）"><a href="#双写模式（更新完数据更新缓存）" class="headerlink" title="双写模式（更新完数据更新缓存）"></a>双写模式（更新完数据更新缓存）</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171156.png" data-fancybox="group" data-caption="双写模式" class="fancybox"><img alt="双写模式" title="双写模式" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171156.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="失效模式（更新完数据缓存失效）"><a href="#失效模式（更新完数据缓存失效）" class="headerlink" title="失效模式（更新完数据缓存失效）"></a>失效模式（更新完数据缓存失效）</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171157.png" data-fancybox="group" data-caption="失效模式" class="fancybox"><img alt="失效模式" title="失效模式" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171157.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171350.png" data-fancybox="group" data-caption="缓存一致性解决方案" class="fancybox"><img alt="缓存一致性解决方案" title="缓存一致性解决方案" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211104171350.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h1><p>xxx</p><h1 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175322.png" data-fancybox="group" data-caption="image-20211119191231370" class="fancybox"><img alt="image-20211119191231370" title="image-20211119191231370" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175322.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175329.png" data-fancybox="group" data-caption="image-20211119191430478" class="fancybox"><img alt="image-20211119191430478" title="image-20211119191430478" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175329.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175335.png" data-fancybox="group" data-caption="image-20211119191131013" class="fancybox"><img alt="image-20211119191131013" title="image-20211119191131013" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175335.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175342.png" data-fancybox="group" data-caption="image-20211119191741406" class="fancybox"><img alt="image-20211119191741406" title="image-20211119191741406" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175342.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h1 id="异步-amp-线程池"><a href="#异步-amp-线程池" class="headerlink" title="异步&amp;线程池"></a>异步&amp;线程池</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集成Thread</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> * 实现Callable接口+futureTask</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Thread01 thread01 = new Thread01();</span></span><br><span class="line"><span class="comment">//thread01.start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Runnable01 runnable01 = new Runnable01();</span></span><br><span class="line"><span class="comment">//new Thread(runnable01).start();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable01());</span></span><br><span class="line"><span class="comment">//new Thread(futureTask).start();</span></span><br><span class="line"><span class="comment">////阻塞等待</span></span><br><span class="line"><span class="comment">//Integer integer = futureTask.get();</span></span><br><span class="line"><span class="comment">//System.out.println(integer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该将所有的异步任务都交给线程池执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int corePoolSize,  核心线程数，线程池创建号以后就准备就绪的线程数量，就等待接受异步任务去执行</span></span><br><span class="line"><span class="comment"> * 只要线程池不销毁，就一直存在   除非奢姿了这个allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * int maximumPoolSize,  最大的线程数量  控制资源并发</span></span><br><span class="line"><span class="comment"> * long keepAliveTime,  存活时间，当正在运行线程数量大于核心数量，回释放空闲的线程，</span></span><br><span class="line"><span class="comment"> * 只要线程空闲大于执行的存活时间，释放的线程等于maximumPoolSize-corePoolSize</span></span><br><span class="line"><span class="comment"> * TimeUnit unit, 时间单位</span></span><br><span class="line"><span class="comment"> * BlockingQueue&lt;Runnable&gt; workQueue, 阻塞队列 如果任务很多，将多余的任务放在队列里，有现成空闲就回去队列里取新的任务</span></span><br><span class="line"><span class="comment"> * ThreadFactory threadFactory,  线程创建工厂，</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler handler   如果队列满了，按照指定的拒绝策略，拒绝执行任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作顺序：</span></span><br><span class="line"><span class="comment"> * 1. 线程池创建号，准备好core的核心线程数量，准备接受任务</span></span><br><span class="line"><span class="comment"> * 2. 新的任务进来，用core准备好的空闲线程去执行</span></span><br><span class="line"><span class="comment"> *  （1）core满了，将再进来的任务放到阻塞队列中，空闲的core就会自己去阻塞队列获取任务</span></span><br><span class="line"><span class="comment"> *  （2）阻塞队列满了，就直接开新的线程执行，最大只能开到max指定的数量</span></span><br><span class="line"><span class="comment"> *  （3）max都执行好了，Max-core数量空闲的线程会在keepAliveTime指定的时间后自动销毁，最终保持到core大小</span></span><br><span class="line"><span class="comment"> *  （4）如果线程开到了max的数量，还有新任务进来，就会使用reject指定的拒绝策略进行处理</span></span><br><span class="line"><span class="comment"> * 3.所有的线程创建都是由指定的factory创建的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  一个线程池 core 7，max 20 ，queue 50   100并发进来怎么分配</span></span><br><span class="line"><span class="comment"> *  先执行7个，后续50个请求进队列，然后创建13个新线程执行，</span></span><br><span class="line"><span class="comment"> *  现在执行了 7 + 13 个  50个在队列中   剩下30执行拒绝策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  new LinkedBlockingDeque&lt;&gt;()  默认integer的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">7</span>,</span><br><span class="line">                <span class="number">20</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"当前执行的线程是："</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }, String.valueOf(i)));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main....end"</span>);</span><br><span class="line">        executor.shutdown();</span><br></pre></td></tr></tbody></table></figure></div><h1 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h1><p>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。</p><ul><li><p>token机制</p><ol><li>服务端提供了发送token接口。那些业务存在幂等问题，就必须在这之前执行，先去获取token，服务器把token保存到redis</li><li>然后调用业务接口请求时，把token携带过去，一般放在请求头部</li><li>服务器判断是否存在redis中，存在表示第一次请求，然后删除token，继续执行业务</li><li>如果判断token不存在redis中，则表示是重复操作，直接返回重读标记给client</li></ol><p>危险性：</p><ul><li><p>先删除还是后删除token</p><ul><li><p>先删除可能导致，业务确实没有执行，重试还带上之前的token，由于防虫设计导致，接口还是不能执行</p><p>即分布式系统中两次请求同时从redis中取得token，服务端均校验通过，同时执行了业务</p></li><li><p>后删可能导致，业务处理成功，但是服务闪断，出现超时，没有删除token，继续重试，导致业务被执行两次+</p></li><li><p>最好设计为先删除token，如果业务嗲用失败，就重新获取token在此请求</p></li></ul></li><li><p>token获取、比较和删除必须是原子性</p><ul><li><p>redis.get(token)、token.equals、redis.del(token)如果这两个操作不是院子，可能导致，高并发下，都得到同样的token，判断都成功，继续业务并发执行</p></li><li><p>可以再redis使用lua脚本完成这个操作</p><p>if redis.call(‘get’,KEYS[1]) == ARGV[1] then return redis.call(‘del’,KEYS[1]) else return 0 end</p></li></ul></li></ul></li><li><p>锁机制</p><ul><li><p>数据库悲观锁</p><p>悲观锁使用时一般伴随事务一起使用,数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id字段一定是主键或者唯一索引不然可能造成锁表的结息，处理起来会非常麻烦。</p></li><li><p>数据库乐观锁</p><p>这种方法适合在更新的场景中,</p><p>updatet_goods set count = count -1 , version = version + 1 where good_id=2 and version= 1根据version 版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version 变成了2;但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行:因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</p><p>乐观锁主要使用于处理读多写少的问题</p></li><li><p>业务层分布式锁</p><p>如果多个机器可能在同一时间同时处理相同的数据,比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</p></li></ul></li><li><p>各种唯一约束</p><ul><li><p>数据库唯一约束</p><p>插入数据,应该按照唯一索引进行插入，比如订单号,相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。<br>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键,这样就需要业务生成全局唯一的主键。<br>如果是分库分表场景下，路由规则要保证相同请求下,落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p></li><li><p>redis set 防重</p><p>很多数据需要处理，只能被处理一次,比如我们可以计算数据的 MD5将其放入redis 的 set,每次处理数据,先看这个MD5是否已经存在,存在就不处理。</p></li></ul></li><li><p>防重表<br>  使用订单号 orderNo做为去重表的唯一索引,把唯一索引插入去重表,再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败,避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p></li><li><p>全局请求唯一id<br>调用接口时,生成一个唯一id,redis 将数据保存到集合中（去重)，存在即处理过。可以使用 nginx设置每一个请求的唯一 id;</p><p>proxy_set_header X-Request-ld Srequest_id;</p></li></ul><h1 id="本地事务与分布式事务"><a href="#本地事务与分布式事务" class="headerlink" title="本地事务与分布式事务"></a>本地事务与分布式事务</h1><p>事务保证：</p><ol><li><p>订单服务异常，库存锁定不运行，全部回滚，撤销操作</p></li><li><p>库存服务事务自制，锁定失败全部回滚，订单感受到继续回滚</p></li><li><p>库存服务锁定成功，但是网络原因返回数据途中问题</p><p>远程服务调用失败，远程服务成功，却由于网络故障等原因，没有返回，导致订单回滚，库存却扣减</p></li><li><p>库存服务锁定成功，库存服务下面的逻辑发生故障，订单回滚</p><p>远程服务执行完成，当前订单服务中调用远程服务的其他地方却发生故障，已执行的远程服务无法回滚</p></li></ol><p>利用消息队列实现最终一致，库存服务锁定成功后给消息队列消息，过段时间自动解锁，甲所示先查询订单的支付状态，解锁成功修改库存工作单详情状态为已解锁</p><h2 id="事务的基本特质"><a href="#事务的基本特质" class="headerlink" title="事务的基本特质"></a>事务的基本特质</h2><p>数据库事务的ACID特性：原子性（Atomicity）、已执行（Consistency）、隔离性或独立性（Isolation）、持久性（Durability）</p><ul><li><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</p></li><li><p>一致性：数据在事务的前后，业务整体一致</p><p>A（1000）给B（1000）转账200，事务成功则A（800）、B(1200)</p></li><li><p>隔离性：事务之间相互隔离</p></li><li><p>持久性：一旦事务成功，数据一定会落在数据库</p></li></ul><p>在单体应用中，多个业务操作使用同一条连接操作不同的数据表，一旦出现异常，很同意进行整体回滚。一个事务开始：代表一笑的所有操作都在一个连接里面。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p><p>3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>1、PROPAGATION_REQUIRED:如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>2、PROPAGATION_SUPPORTS:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>3、PROPAGATION_MANDATORY:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>4、PROPAGATION_REQUIRES_NEW:创建新事务，无论当前存不存在事务，都创建新事务。5、PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>6、PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。<br>7、PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h3 id="Springboot中事务传播的坑"><a href="#Springboot中事务传播的坑" class="headerlink" title="Springboot中事务传播的坑"></a>Springboot中事务传播的坑</h3><p><strong>同一个对象内事务方法互相调用默认失效，同一个类下的方法相互调用，即使设置了事务的隔离界别注解，依然以第一个执行的方法的事务为准。</strong></p><p><strong>原因：绕过了代理对象事务使用代理对象来执行的</strong>。</p><p>解决：使用代理对象来调用方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引入aspectj</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启aspectj动态代理功能，所有的动态代理都是aspectj创建的（即使没有接口也可以创建动态代理）</span><br><span class="line">    exposeProxy = <span class="keyword">true</span> 对外暴露代理对象</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(exposeProxy = <span class="keyword">true</span>)</span><br><span class="line">    </span><br><span class="line">从aopcontext中获取当前代理对象实现事务的传播</span><br></pre></td></tr></tbody></table></figure></div><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP原则指的实在一个分布式系统中：</p><ul><li><p>一致性（Consistency）</p><p>在分布式系统中的所有数据备份，在同一时刻是否同样的值，等同于所有接待您访问同一份最新的数据副本</p></li><li><p>可用性（Availablity）</p><p>在集群中一部分节点故障后，集群整体是否还能影响客户端的读写请求。（对数据更新具备更高的可用性）</p></li><li><p>分区容错性（Partition tolerance）</p><p>大多数人分布式系统都分布在多个子网络，每个子网络叫做一个区，分区容错的意思就是，区间通信可能失败，。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，他们之间可能无法通信。</p></li></ul><p>CAP原则指的是，这三个要素最多只能同时实现两点，不能三者兼顾。</p><p><strong>分布式系统中实现一致性的raft算法、paxos</strong></p><p><strong><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></strong></p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>是对CAP的延伸，思想史计时无法做到强一致性（CAP的一致性就是强一致性），也可以适当的采取弱一致性，即最终一致性。</p><ul><li><p>基本可用（Basically Available）</p><p>基本可用是指分布式系统在出现故障的时候,允许损失部分可用性(例如响应时间、功能上的可用性)，允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</p><p>响应时间上的损失:正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了1~2秒。</p><p>功能上的损失:购物网站在购物高峰(如双十一)时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</p></li><li><p>软状态（Soft State）</p><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p></li><li><p>最终一致性（Eventual Consistency）</p><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li></ul><h2 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h2><p>从客户端角度，多进程并发访间时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性</p><h2 id="分布式事务的几种方案"><a href="#分布式事务的几种方案" class="headerlink" title="分布式事务的几种方案"></a>分布式事务的几种方案</h2><p><a href="https://zhuanlan.zhihu.com/p/183753774" target="_blank" rel="noopener">分布式事务的解决方案</a></p><p>柔性事务+可靠消息+最终一致性方案</p><p>业务处理服务在业务事务提交之前，向实时消息.服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后:向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><h1 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h1><p><a href="https://github.com/Raptor1998/SpringCloud-Basic" target="_blank" rel="noopener">Springcloud基础</a></p><p><a href="https://github.com/Raptor1998/SpringCloud-Basic/blob/master/SpringCloud%20%E7%AC%AC%E4%BA%8C%E5%AD%A32020.03.05.mmap" target="_blank" rel="noopener">Springcloud笔记文档</a></p><h1 id="rabbit延迟队列释放库存"><a href="#rabbit延迟队列释放库存" class="headerlink" title="rabbit延迟队列释放库存"></a>rabbit延迟队列释放库存</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175349.png" data-fancybox="group" data-caption="image-20211208190908469" class="fancybox"><img alt="image-20211208190908469" title="image-20211208190908469" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20211229175349.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Queue(String name,  队列名字</span></span><br><span class="line"><span class="comment">        boolean durable,  是否持久化</span></span><br><span class="line"><span class="comment">        boolean exclusive,  是否排他</span></span><br><span class="line"><span class="comment">        boolean autoDelete, 是否自动删除</span></span><br><span class="line"><span class="comment">        Map&lt;String, Object&gt; arguments) 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order-event-exchange"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.release.order"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 1分钟</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseQueue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   String name,</span></span><br><span class="line"><span class="comment">     *   boolean durable,</span></span><br><span class="line"><span class="comment">     *   boolean autoDelete,</span></span><br><span class="line"><span class="comment">     *   Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateBinding</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * String destination, 目的地（队列名或者交换机名字）</span></span><br><span class="line"><span class="comment">     * DestinationType destinationType, 目的地类型（Queue、Exhcange）</span></span><br><span class="line"><span class="comment">     * String exchange,</span></span><br><span class="line"><span class="comment">     * String routingKey,</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseBinding</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="消息的可靠性"><a href="#消息的可靠性" class="headerlink" title="消息的可靠性"></a>消息的可靠性</h1><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><ul><li><p>消息发送出去，由于网络问题没有抵达服务器</p><ul><li><p>做好容错方法(try-catch)，发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</p></li><li><p>做好日志记录，每个消息状态是否都被服务器收到都应该记录</p></li><li><p>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</p></li></ul></li><li><p>消息抵达Broker，Broker要将消息写入磁盘(持久化)才算成功。此时Broker尚未持久化完成，宕机.</p><ul><li>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</li></ul></li><li><p>自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机</p><ul><li>一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</li></ul></li></ul><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><ul><li><p>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者</p></li><li><p>消息消费失败，由于重试机制，自动又将消息发送出去</p></li><li><p>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送</p><ul><li>消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志</li><li>使用防重表（redis/mysql)，发送消息每一个都有业务的唯一标识，处理过就不用处理</li><li>rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</li></ul></li></ul><h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><ul><li>消费者宕机积压</li><li>消费者消费能力不足宕机</li><li>发送者发送流量太大<ul><li>上线更多的消费者，进行正常消费</li><li>上线专门的队列消费服务，将消息先批量的取出来，记录数据库，离线慢慢处理</li></ul></li></ul><h1 id="收单"><a href="#收单" class="headerlink" title="收单"></a>收单</h1><ol><li><p>订单在支付页，不支付，一直刷新，订单过期了才支付，订单状态改为已经支付，但是库存已经释放了</p><p>可使用支付宝的自动收单功能，只要一段时间不支付，就不能支付了</p></li><li><p>由于时延等问题 ，订单解锁完成，正在等待锁库存的时候，异步通知才到</p><p>订单解锁，手动调用收单</p></li><li><p>网络阻塞问题，订单支付成功的异步通知一直不到达</p><p>查询订单列表时，ajax获取当前未支付的订单状态，查询订单状态时，再获取一下支付宝此订单的状态</p></li><li><p>其他各种问题</p><p>每天晚上闲时下载支付宝对账单，——进行对账</p></li></ol><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流＋异步＋缓存（页面静态化)＋独立部署。</p><p><strong>限流方式:</strong></p><ol><li><p>前端限流，一些高并发的网站直接在前端页面开始限流，例如:小米的验证码设计</p></li><li><p>nginx限流，直接负载部分请求到错误的静态页面:令牌算法漏斗算法</p></li><li><p>网关限流，限流的过滤器</p></li><li><p>代码中使用分布式信号量</p></li></ol><h2 id="Spring定时任务"><a href="#Spring定时任务" class="headerlink" title="Spring定时任务"></a>Spring定时任务</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="comment">//开启异步任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSchedule</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. Spring的corn由6位组成，不予许第七位的年</span></span><br><span class="line"><span class="comment">     * 2. 在周几的位置，1-7代表周一到周日，MON-SUN</span></span><br><span class="line"><span class="comment">     * 3. 定时任务不应该阻塞。默认是阻塞的</span></span><br><span class="line"><span class="comment">     *  1） 可以让业务运行以异步的方式，提交到自己的线程池</span></span><br><span class="line"><span class="comment">     *        CompletableFuture.runAsync(()-&gt;{</span></span><br><span class="line"><span class="comment">     *         }.executor);</span></span><br><span class="line"><span class="comment">     *  2) 支持异步线程池；设置spring.task.schedule.pool.size=5</span></span><br><span class="line"><span class="comment">     *  3) 异步任务  <span class="doctag">@EnableAsync</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"* * * ? * 4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        log.info(<span class="string">"hello ..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="商品上架的幂等性保证"><a href="#商品上架的幂等性保证" class="headerlink" title="商品上架的幂等性保证"></a>商品上架的幂等性保证</h2><p>在分布式环境中，多个应用的上架时间都一样，只需要保证有一台机器执行即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒杀商品上架功能的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String upload_lock = <span class="string">"seckill:upload:lock"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 保证幂等性问题</span></span><br><span class="line"><span class="comment">// @Scheduled(cron = "*/5 * * * * ? ")</span></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 1/1 * * ? "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadSeckillSkuLatest3Days</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//1、重复上架无需处理</span></span><br><span class="line">    log.info(<span class="string">"上架秒杀的商品..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分布式锁</span></span><br><span class="line">    RLock lock = redissonClient.getLock(upload_lock);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//上架商品逻辑 </span></span><br><span class="line">        seckillService.uploadSeckillSkuLatest3Days();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      SpringCloudAlibaba
    
    </summary>
    
    
      <category term="SpringCloudAlibaba" scheme="http://raptor1998.top/categories/SpringCloudAlibaba/"/>
    
    
      <category term="SpringCloudAlibaba" scheme="http://raptor1998.top/tags/SpringCloudAlibaba/"/>
    
  </entry>
  
  <entry>
    <title>NGINX配置HTTPS</title>
    <link href="http://raptor1998.top/2021/08/27/nginx%E4%B9%8Bhttps/"/>
    <id>http://raptor1998.top/2021/08/27/nginx%E4%B9%8Bhttps/</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-10-11T09:22:49.130Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="NGINX配置HTTPS"><a href="#NGINX配置HTTPS" class="headerlink" title="NGINX配置HTTPS"></a>NGINX配置HTTPS</h1><h2 id="域名解析到主机"><a href="#域名解析到主机" class="headerlink" title="域名解析到主机"></a>域名解析到主机</h2><h2 id="申请ssl证书"><a href="#申请ssl证书" class="headerlink" title="申请ssl证书"></a>申请ssl证书</h2><ol><li><p>到域名管理开启ssl证书</p></li><li><p><strong>为了解决免费证书近期存在的吊销、统计等问题，自2021年起，免费证书申请将切换到证书资源包下</strong></p><p>进入<strong>证书资源包</strong></p><p>选择免费版购买</p></li><li><p>进入ssl证书控制台，创建证书</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213255.png" data-fancybox="group" data-caption="创建证书" class="fancybox"><img alt="创建证书" title="创建证书" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213255.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>填写信息</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213256.png" data-fancybox="group" data-caption="信息填写" class="fancybox"><img alt="信息填写" title="信息填写" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213256.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>NDS验证</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213257.png" data-fancybox="group" data-caption="验证" class="fancybox"><img alt="验证" title="验证" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213257.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>等待审核通过后即可下载</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213258.png" data-fancybox="group" data-caption="证书类型" class="fancybox"><img alt="证书类型" title="证书类型" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827213258.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li></ol><h2 id="NGINX配置"><a href="#NGINX配置" class="headerlink" title="NGINX配置"></a>NGINX配置</h2><ol><li><p>nginx 的 ssl 模块安装</p><p><strong>/usr/local/nginx/sbin/nginx -V</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214255.png" data-fancybox="group" data-caption="ssl模块" class="fancybox"><img alt="ssl模块" title="ssl模块" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214255.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>如果未安装则</p><ul><li><p><strong>wget <a href="http://nginx.org/download/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.16.1.tar.gz</a></strong></p></li><li><p><strong>tar -zxvf nginx-1.16.1.tar.gz</strong></p></li><li><p><strong>cd nginx-1.16.1 $ ./configure –prefix=/usr/local/nginx –with-http_ssl_module</strong></p></li><li><p>使用 <code>make</code> 命令编译（<strong>使用<code>make install</code>会重新安装nginx</strong>），此时当前目录会出现 <code>objs</code> 文件夹。</p></li><li><p>用新的 nginx 文件覆盖当前的 nginx 文件。</p><p><strong>cp ./objs/nginx /usr/local/nginx/sbin/</strong></p></li><li><p>再次查看安装的模块（<code>configure arguments: --with-http_ssl_module</code>说明ssl模块已安装）</p></li></ul></li><li><p>配置SSL证书</p><p>在<code>/usr/local/nginx</code>下创建文件夹cert，将两个证书文件放入</p></li><li><p><strong>配置 https server</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/cert/xxx.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        root /disabled/admin;</span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">}</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>将 http 重定向 https</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>重启nginx</p></li><li><p>无法访问，此类情况稍等一会，具体原因未知</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214857.png" data-fancybox="group" data-caption="无法访问" class="fancybox"><img alt="无法访问" title="无法访问" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827214857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li><li><p>成功</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827215334.png" data-fancybox="group" data-caption="success" class="fancybox"><img alt="success" title="success" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210827215334.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></li></ol><h2 id="完整配置demo"><a href="#完整配置demo" class="headerlink" title="完整配置demo"></a>完整配置demo</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    fastcgi_intercept_errors on;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    server {</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  xxx.xx;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key  /usr/local/nginx/cert/xxx.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        root /disabled/admin;</span><br><span class="line">        #location / {</span><br><span class="line">        #    root   html;</span><br><span class="line">        #    index  index.html index.htm;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # 管理员页面</span><br><span class="line">        location / {</span><br><span class="line">            try_files $uri $uri/ @router;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">         }</span><br><span class="line">        location @router {</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /images {</span><br><span class="line">            root /disabled/files;</span><br><span class="line">            # 目录索引权限</span><br><span class="line">            autoindex on;</span><br><span class="line">            autoindex_exact_size on;</span><br><span class="line">            autoindex_localtime on;</span><br><span class="line">        }</span><br><span class="line">        location /mobile {</span><br><span class="line">            root   /disabled;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /wechat {</span><br><span class="line">            root   /disabled;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        location /api/mobiles {</span><br><span class="line">            rewrite ^/(.*)$ /$1 break;</span><br><span class="line">            proxy_pass   http://127.0.0.1:8081;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="NGINX的mater和worker"><a href="#NGINX的mater和worker" class="headerlink" title="NGINX的mater和worker"></a>NGINX的mater和worker</h1><ul><li><p><strong>一个</strong> <strong>master</strong> <strong>和多个</strong> <strong>woker</strong> <strong>有好处</strong></p><p>（1）可以使用<code>nginx –s reload</code> 热部署，利用 nginx 进行热部署操作</p><p>（2）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 独立的，继续进行争抢，实现请求过程，不会造成服务中断</p></li><li><p><strong>设置多少个</strong> <strong>woker</strong> <strong>合适</strong></p><p>worker 数和服务器的cpu数相等是最为适宜的</p></li><li><p><strong>连接数</strong> <strong>worker_connection</strong></p><ul><li><p><strong>第一个：发送请求，占用了</strong> <strong>woker</strong> <strong>的几个连接数？</strong></p><p>静态资源2个、反向代理4个</p></li><li><p><strong>nginx有一个master，有四个 woker，每个woker 支持最大的连接数1024，支持的</strong></p><p><strong>最大并发数是多少？</strong></p><p>普通的静态访问最大并发数是： worker_connections * worker_processes /2</p><p>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。</p></li></ul></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      NGINX
    
    </summary>
    
    
      <category term="NGINX" scheme="http://raptor1998.top/categories/NGINX/"/>
    
    
      <category term="NGINX" scheme="http://raptor1998.top/tags/NGINX/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程基础</title>
    <link href="http://raptor1998.top/2021/07/29/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://raptor1998.top/2021/07/29/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-08-20T01:18:03.712Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>真实对象和代理对象都要实现同一个接口，代理对象要代理真实角色</strong></p><p><strong>好处：代理对象可以做很多真是对象做不了的事情，真实对象专注做自己的事情</strong></p><p><code>线程体（也就是我们要执行的具体任务）实现了Runnable接口和run方法。同时Thread类也实现了Runnable接口。此时，线程体就相当于目标角色，Thread就相当于代理角色。当程序调用了Thread的start()方法后，Thread的run()方法会在某个特定的时候被调用。thread.run()方法</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ProxyImage(<span class="keyword">new</span> RealImage(<span class="string">"happy"</span>)).display();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"sad"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(RealImage realImage)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.realImage = realImage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//真是对象的方法</span></span><br><span class="line">        realImage.display();</span><br><span class="line">        after();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyTarget run..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/dennyzhangdd/p/7280032.html" target="_blank" rel="noopener">Thread类源码剖析</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="noopener">Java并发编程：Thread类的使用</a></p><p><a href="https://www.cnblogs.com/jamesvoid/p/10011694.html" target="_blank" rel="noopener">Thread类源码解析</a></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="jvm线程状态"><a href="#jvm线程状态" class="headerlink" title="jvm线程状态"></a>jvm线程状态</h3><p><strong>线程中断或者结束，一旦进入死亡状态，就不能再次启动。</strong></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210729144111.png" data-fancybox="group" data-caption="jvm线程状态" class="fancybox"><img alt="jvm线程状态" title="jvm线程状态" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210729144111.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>如上图，可见：<strong>RUNNABLE = 正在JVM中运行的（Running）+ 可能在等待操作系统级别的资源（Ready）</strong>，例如CPU时间片</p><p>　　线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源），只有线程运行需要的所有条件满足了，才进入就绪状态。</p><p>　　当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。</p><p>　　线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。</p><p>　　当由于突然中断或者子任务执行完毕，线程就会被消亡。</p><ol><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li><li>t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。</li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li><li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li></ol><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_22771739/article/details/82529874" target="_blank" rel="noopener">Java线程的6种状态及切换(透彻讲解)</a></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行。</p><p>线程的优先级用数字表示范围1~10,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>低优先级只意味着获得调度的概率低，并不是优先级低的就不会被调用了，这都取决于CPU的调度</strong></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>线程分为用户线程和守护线程</p><p>虚拟机必须确保用户线程执行完毕</p><p>虚拟机不用等待守护线程执行完毕，如后台记录操作日志、监控内存、垃圾回收等</p><p><strong>两者的区别：</strong></p><p><strong>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Human human = <span class="keyword">new</span> Human();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        <span class="comment">//默认为false表示用户线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(human).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"god still alive !"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">365</span> * <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"human alive "</span> + i);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"dead"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><strong>synchronized方法控制着“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</strong></p><p><strong>缺陷：若将一个打的方法声明为synchronized将会影响效率</strong></p><p><strong>synchronized（obj）{}，obj称之为同步监视器，可以使任何对象，但是推荐使用共享资源作为同步监视器，同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身或者是class</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="comment">//锁住list对象  变为安全的</span></span><br><span class="line">                <span class="keyword">synchronized</span> (list){</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                    System.out.println(<span class="string">"now size:"</span>+list.size());</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><span id="jump"><strong>同步锁 锁的对象</strong></span></p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802093658.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802093658.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><span id="deadLock">死锁</span></h2><p>死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><blockquote><p>必要条件</p></blockquote><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源关系</li></ul><blockquote><p>预防死锁——破坏任意一个或多个条件</p></blockquote><ul><li>破坏请求保持：一次性申请所有的资源，这样就不存在等待了。</li><li>不可抢占，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>循环等待，靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化申请后就不存在循环了。</li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="显示定义"><a href="#显示定义" class="headerlink" title="显示定义"></a>显示定义</h3><p>通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当</p><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</p><p>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) {</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="synchronized与lock对比"><a href="#synchronized与lock对比" class="headerlink" title="synchronized与lock对比"></a>synchronized与lock对比</h3><ul><li>lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放。</li><li>Lock锁只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用lock锁，JVM将花费较少的时间来调度进程，性能更高，并且具有更好的拓展性（提供更多的子类）</li><li>使用优先顺序  Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</li></ul><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="可用方法"><a href="#可用方法" class="headerlink" title="可用方法"></a>可用方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高于线程的优先调度</td></tr></tbody></table><p><strong>均是Object类中的方法，都只能在同步方法或者同步代码块中使用，否则异常</strong></p><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class TestPC {</span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Container container = new Container();</span><br><span class="line">        Provider provider = new Provider(container);</span><br><span class="line">        Consumer consumer = new Consumer(container);</span><br><span class="line">        provider.start();</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生产者</span><br><span class="line"> */</span><br><span class="line">class Provider extends Thread {</span><br><span class="line">    Container container;</span><br><span class="line"></span><br><span class="line">    public Provider(Container container) {</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println("生产者启动");</span><br><span class="line">        try {</span><br><span class="line">            for (int i = 1; i &lt;= 100; i++) {</span><br><span class="line">                container.push(new Product(i));</span><br><span class="line">                System.out.println("生产了第" + i + "个产品");</span><br><span class="line">            }</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> */</span><br><span class="line">class Consumer extends Thread {</span><br><span class="line">    Container container;</span><br><span class="line"></span><br><span class="line">    public Consumer(Container container) {</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println("消费者启动");</span><br><span class="line">        try {</span><br><span class="line">            for (int i = 1; i &lt;= 100; i++) {</span><br><span class="line">                System.out.println("---------消费了第" + container.pop().getId() + "个产品");</span><br><span class="line">            }</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓冲区</span><br><span class="line"> */</span><br><span class="line">class Container {</span><br><span class="line"></span><br><span class="line">    private Product[] products = new Product[100];</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public synchronized void push(Product product) throws InterruptedException {</span><br><span class="line">        //容器满了</span><br><span class="line">        if (count == products.length) {</span><br><span class="line">            //通知消费者消费，生产者等待</span><br><span class="line">            this.wait();</span><br><span class="line">        }</span><br><span class="line">        //缓冲区没有满  加入产品</span><br><span class="line"></span><br><span class="line">        products[count] = product;</span><br><span class="line">        count++;</span><br><span class="line">        //通知消费者消费</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public synchronized Product pop() throws InterruptedException {</span><br><span class="line">        //缓冲区是否存在产品</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            //等待生产者生产</span><br><span class="line">            this.wait();</span><br><span class="line">        }</span><br><span class="line">        count--;</span><br><span class="line">        Product product = products[count];</span><br><span class="line"></span><br><span class="line">        //通知生产者生产</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        return product;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 产品</span><br><span class="line"> */</span><br><span class="line">class Product {</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Product(int id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int getId() {</span><br><span class="line">        return id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setId(int id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730103700.png" data-fancybox="group" data-caption="管程" class="fancybox"><img alt="管程" title="管程" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730103700.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line">        Actor actor = <span class="keyword">new</span> Actor(program);</span><br><span class="line">        Audience audience = <span class="keyword">new</span> Audience(program);</span><br><span class="line">        actor.start();</span><br><span class="line">        audience.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Program program;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(Program program)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.program = program;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">this</span>.program.show(<span class="string">"男子乒乓球单打决赛"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">this</span>.program.show(<span class="string">"团体赛决赛"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audience</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Program program;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audience</span><span class="params">(Program program)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.program = program;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">this</span>.program.watching();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String perform;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String perform)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!flag) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"表演等待..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"表演了："</span> + perform);</span><br><span class="line">        <span class="comment">//通知观众</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.perform = perform;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watching</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"观看等待..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"观看了："</span> + perform);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730110949.png" data-fancybox="group" data-caption="信号量" class="fancybox"><img alt="信号量" title="信号量" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210730110949.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p><p>提前创建好朵儿线程池，放入线程池中没使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复利用。</p><blockquote><p>好处</p></blockquote><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低了资源消耗（重复利用线程中的线程，不需要每次都创建）</li><li>便于线程管理</li></ul><blockquote><p>简单使用</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">"   "</span>+ i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a><strong>JUC</strong>并发编程</h1><h2 id="JUC概述"><a href="#JUC概述" class="headerlink" title="JUC概述"></a>JUC概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p><p><strong>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程— —资源分配的最小单位。</strong></p><p><strong>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</strong></p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.新建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor. 准备就绪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> Object#wait() Object.wait}.阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait() Object.wait} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #join() Thread.join} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#park() LockSupport.park}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #sleep Thread.sleep}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait(long) Object.wait} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> #join(long) Thread.join} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;限时等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.终结</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="wait-sleep-的区别"><a href="#wait-sleep-的区别" class="headerlink" title="wait/sleep 的区别"></a><strong>wait/sleep 的区别</strong></h3><p>（1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。</p><p>（2）sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在 synchronized 中)。 </p><p>（3）它们都可以被 interrupted 方法中断。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><h4 id="串行模式"><a href="#串行模式" class="headerlink" title="串行模式"></a>串行模式</h4><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p><p><strong>串行是一次只能取得一个任务，并执行这个任务</strong>。</p><h4 id="并行模式"><a href="#并行模式" class="headerlink" title="并行模式"></a>并行模式</h4><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核 CPU。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行</strong>。</p><p><strong>并发：</strong>同一时刻多个线程在访问同一个资源，多个线程对一个点</p><p><strong>并行：</strong>多项工作一起执行，之后再汇总</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p><p>管程（Monitor）监视器，平时我们所说的锁，是一种同步的机制，保证同一时间，只有一个线程能对被保护的数据或者代码进行访问</p><p>jvm同步基于进入和退出，使用管程对象实现的</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><ul><li><p>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</p></li><li><p>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p></li></ul><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在两个线程的情况下，没有问题，当增加线程数之后，会出现问题。<strong>加入ABCD四个线程，分别作+1，-1，+1，-1，操作A先做+1，此时随机唤醒BCD，例如C得到，发现num不为0，则等待，此时ABD再抢，A抢到，直接等待，在此时，C又抢到了，此时C在this.wait();这一行等待，二wait方法有一个特点，“在那里睡就在那里醒”，此时C直接向下执行做+1操作。</strong></p><p><strong>避免：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  ::  "</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p><ul><li>await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行。</li><li>signal()用于唤醒一个等待的线程。</li></ul><p>在调用 Condition 的 await()/signal()方法前，也需要线程持有相关的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><h3 id="线程定制化通信"><a href="#线程定制化通信" class="headerlink" title="线程定制化通信"></a>线程定制化通信</h3><p><strong>案例: A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮</strong></p><p><strong>通用：通过标志位实现</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) {</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" :: "</span> + i + <span class="string">" :轮数"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知B线程</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print5(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print10(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print15(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h2><h3 id="ArrayList、HashSet、HashMap安全问题"><a href="#ArrayList、HashSet、HashMap安全问题" class="headerlink" title="ArrayList、HashSet、HashMap安全问题"></a>ArrayList、HashSet、HashMap安全问题</h3><h4 id="异常：ConcurrentModificationException"><a href="#异常：ConcurrentModificationException" class="headerlink" title="异常：ConcurrentModificationException"></a>异常：ConcurrentModificationException</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802100946.png" data-fancybox="group" data-caption="并发修改异常" class="fancybox"><img alt="并发修改异常" title="并发修改异常" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802100946.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="synchronizedList-or-Vector"><a href="#synchronizedList-or-Vector" class="headerlink" title="synchronizedList or Vector"></a>synchronizedList or Vector</h5><p>可以使用<code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());或者List&lt;String&gt; list =new Vector();</code>解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//vector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//synchronizedList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><ol><li><p>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</p></li><li><p>它是线程安全的。</p></li><li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。</p></li><li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p></li><li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></li></ol><p><strong>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写会内存，其他的线程就会读到了脏数据。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure></div><p>集合类型中存在线程安全与线程不安全的两种,常见例如: <strong>ArrayList —– Vector，HashMap —–HashTable</strong>，但是以上都是通过 synchronized 关键字实现,效率较低</p><h2 id="多线程锁演示"><a href="#多线程锁演示" class="headerlink" title="多线程锁演示"></a>多线程锁演示</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！</a></p><p><a href="https://www.cnblogs.com/heyouxin/p/13037146.html" target="_blank" rel="noopener">【并发编程】公平锁与非公平锁的区别</a></p><p><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></p><h3 id="synchronized锁演示"><a href="#synchronized锁演示" class="headerlink" title="synchronized锁演示"></a>synchronized锁演示</h3><p><strong><a href="#jump">查看synchronized锁对象图</a></strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone1.sendSMS();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//                phone1.sendEmail();</span></span><br><span class="line"><span class="comment">//                phone1.getHello()s;</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//停留 4 秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 8 锁</span></span><br><span class="line"><span class="comment"> * 1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 2 停 4 秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 3 新增普通的 hello 方法，是先打短信还是 hello</span></span><br><span class="line"><span class="comment"> * ------getHello</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 5 两个静态同步方法，1 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 6 两个静态同步方法，2 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * 7 1 个静态同步方法,1 个普通同步方法，1 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> * 8 1 个静态同步方法,1 个普通同步方法，2 部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ------sendEmail</span></span><br><span class="line"><span class="comment"> * ------sendSMS</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p><p>加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p><p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p><p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p><p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p><p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h3 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h3><h4 id="偏向锁-、-轻量级锁-、-重量级锁"><a href="#偏向锁-、-轻量级锁-、-重量级锁" class="headerlink" title="偏向锁 、 轻量级锁 、 重量级锁"></a>偏向锁 、 轻量级锁 、 重量级锁</h4><blockquote><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p></blockquote><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>非公平锁：可能出现线程饿死，效率高</p><p>公平锁：阳光普照，效率相对较低</p><p>公平锁是多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序</strong>来一次得到锁(默认的是不公平锁)；</p><p>非公平锁就是一种获取锁的抢占机制，是<strong>随机得到锁的</strong>，和公平锁不同的就是先来的不必定先获得锁。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>{</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line"> sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看到非公平锁里，判断当前锁占用状态==0直接会进行compareAndSetState尝试获取锁。若此时有线程排队，可能争夺不过资源。所以这是非公平的</span></span><br><span class="line"><span class="comment">在非公平锁里，因为可以直接compareAndSetState来获取锁，不需要加入队列，然后等待队列头线程唤醒再获取锁这一步骤，所以效率较快</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在公平锁里，判断当前锁占用状态==0后，会继续判断hasQueuedPredecessors，即当前队列是否有排队的情况，如果没有才会尝试获取锁</span></span><br><span class="line"><span class="comment">这样可以保证遵循FIFO的原则，每一个先来的线程都可以最先获取到锁，但是增加了上下文切换与等待线程的状态变换时间。所以效率相较于非公平锁较慢。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p><strong>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</strong></p><p>synchronized（隐式）和Lock（显示）都是可重入锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>{</span><br><span class="line">    add();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">           <span class="keyword">synchronized</span> (o) {</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"外层"</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (o){</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">"中层"</span>);</span><br><span class="line">                   <span class="keyword">synchronized</span> (o){</span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"内层"</span>);</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }, <span class="string">"t1"</span>).start();</span><br></pre></td></tr></tbody></table></figure></div><p><strong>ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样</strong></p><h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><p><strong><a href="#deadLock">死锁产生</a></strong></p><h4 id="死锁验证"><a href="#死锁验证" class="headerlink" title="死锁验证"></a>死锁验证</h4><h5 id="死锁演示代码"><a href="#死锁演示代码" class="headerlink" title="死锁演示代码"></a>死锁演示代码</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Number number1 = <span class="keyword">new</span> Number(<span class="number">10</span>);</span><br><span class="line">Number number2 = <span class="keyword">new</span> Number(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span> (number1) {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number1锁"</span>);</span><br><span class="line">        number1.setA(<span class="number">11</span>);</span><br><span class="line">        System.out.println(number1);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (number2) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number2锁"</span>);</span><br><span class="line">            number2.setA(<span class="number">21</span>);</span><br><span class="line">            System.out.println(number2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"小明"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span> (number2) {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number2锁"</span>);</span><br><span class="line">        number2.setA(<span class="number">22</span>);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (number1) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到number1锁"</span>);</span><br><span class="line">            number1.setA(<span class="number">12</span>);</span><br><span class="line">            System.out.println(number1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"小红"</span>).start();</span><br></pre></td></tr></tbody></table></figure></div><h5 id="死锁验证-1"><a href="#死锁验证-1" class="headerlink" title="死锁验证"></a>死锁验证</h5><p><strong>jps是用于查看有权访问的hotspot虚拟机的进程. 当未指定hostid时，默认查看本机jvm进程，否者查看指定的hostid机器上的jvm进程，此时hostid所指机器必须开启jstatd服务。 jps可以列出jvm进程lvmid，主类类名，main函数参数, jvm参数，jar名称等信息。</strong></p><p><strong>jstack是java虚拟机自带的一种堆栈跟踪工具。</strong></p><ol><li>jps查看进程id</li></ol><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173215.png" data-fancybox="group" data-caption="jps查看进程号" class="fancybox"><img alt="jps查看进程号" title="jps查看进程号" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173215.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><ol start="2"><li>jstack查看结果</li></ol><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173312.png" data-fancybox="group" data-caption="jstack结果" class="fancybox"><img alt="jstack结果" title="jstack结果" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210802173312.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程</p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p><p>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</p><p>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p><p>一旦计算完成，就不能再重新开始或取消计算</p><p>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完</p><p>成状态，然后会返回结果或者抛出异常get 只计算一次,因此 get 方法放到最后</p><h3 id="Callable创建线程"><a href="#Callable创建线程" class="headerlink" title="Callable创建线程"></a>Callable创建线程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        FutureTask futureTask1 = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        FutureTask futureTask2 = <span class="keyword">new</span> FutureTask(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  come in callable"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        });</span><br><span class="line"><span class="comment">//        new Thread(futureTask1, "A").start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask2, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!futureTask2.isDone()){</span><br><span class="line">            System.out.println(<span class="string">"wait..."</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  is over"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  hello callable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   out: </span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">B  come in callable</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">wait...</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">main  is over</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="JUC-辅助类"><a href="#JUC-辅助类" class="headerlink" title="JUC-辅助类"></a>JUC-辅助类</h2><h3 id="CountDownLatch-减少计数"><a href="#CountDownLatch-减少计数" class="headerlink" title="CountDownLatch: 减少计数"></a>CountDownLatch: 减少计数</h3><blockquote><p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p><p>用给定的<em>计数</em> 初始化 <code>CountDownLatch</code>。由于调用了<code>awaitawait</code> 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。</p></blockquote><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p><ul><li><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这些线程会阻塞</p></li><li><p>其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程不会阻塞) </p></li><li><p>当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 号"</span>);</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" ok"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">0 号</span></span><br><span class="line"><span class="comment">4 号</span></span><br><span class="line"><span class="comment">2 号</span></span><br><span class="line"><span class="comment">3 号</span></span><br><span class="line"><span class="comment">1 号</span></span><br><span class="line"><span class="comment">5 号</span></span><br><span class="line"><span class="comment">main ok</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier: 循环栅栏"></a>CyclicBarrier: 循环栅栏</h3><blockquote><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为<em>循环</em> 的 barrier。</p></blockquote><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; {</span><br><span class="line">        System.out.println(<span class="string">"集齐七龙珠"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 星 get"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">1 星 get</span></span><br><span class="line"><span class="comment">7 星 get</span></span><br><span class="line"><span class="comment">6 星 get</span></span><br><span class="line"><span class="comment">5 星 get</span></span><br><span class="line"><span class="comment">4 星 get</span></span><br><span class="line"><span class="comment">2 星 get</span></span><br><span class="line"><span class="comment">3 星 get</span></span><br><span class="line"><span class="comment">集齐七龙珠</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore: 信号灯"></a>Semaphore: 信号灯</h3><blockquote><p>一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 <code>acquire()</code>，然后再获取该许可。每个 <code>release()</code> 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，<code>Semaphore</code> 只对可用许可的号码进行计数，并采取相应的行动。</p></blockquote><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//抢占</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ------离开"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                semaphore.release();</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">2 抢到</span></span><br><span class="line"><span class="comment">0 抢到</span></span><br><span class="line"><span class="comment">1 抢到</span></span><br><span class="line"><span class="comment">1 ------离开</span></span><br><span class="line"><span class="comment">3 抢到</span></span><br><span class="line"><span class="comment">3 ------离开</span></span><br><span class="line"><span class="comment">4 抢到</span></span><br><span class="line"><span class="comment">0 ------离开</span></span><br><span class="line"><span class="comment">5 抢到</span></span><br><span class="line"><span class="comment">2 ------离开</span></span><br><span class="line"><span class="comment">4 ------离开</span></span><br><span class="line"><span class="comment">5 ------离开</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></strong></p><p><strong><a href="https://blog.csdn.net/yanyan19880509/article/details/52435135" target="_blank" rel="noopener">轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理</a></strong></p><h3 id="读写锁案例"><a href="#读写锁案例" class="headerlink" title="读写锁案例"></a>读写锁案例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                cache.put(finalI + <span class="string">""</span>, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> finalI2 = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                cache.get(finalI2 + <span class="string">""</span>);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String o)</span> </span>{</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---is writing: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.put(key, o);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---finished writing: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        String o = <span class="keyword">null</span>;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is reading: "</span> + key);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" finished reading: "</span> + key + <span class="string">",value:"</span> + o);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cache{"</span> +</span><br><span class="line">                <span class="string">"map="</span> + map +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><blockquote><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 </p><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210803113617.png" data-fancybox="group" data-caption="属性" class="fancybox"><img alt="属性" title="属性" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210803113617.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p></li><li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p></li><li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//三种常见分类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池多线程</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        ExecutorService pool2 = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池可扩容线程</span></span><br><span class="line">        ExecutorService pool3 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                pool3.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            pool3.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 能容纳的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//存活的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//存放提交但未执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//创建线程的工厂类</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span><span class="comment">//等待队列满后的拒绝策略</span></span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> <strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p>在创建了线程池后，线程池中的线程数为零</p></li><li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： </p><p>2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p>2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p><p>2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p><p>4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</p><p>4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p></li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p><p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p><p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p><p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210809105702.png" data-fancybox="group" data-caption="阿里开发手册" class="fancybox"><img alt="阿里开发手册" title="阿里开发手册" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210809105702.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></tbody></table></figure></div><h2 id="分之合并框架"><a href="#分之合并框架" class="headerlink" title="分之合并框架"></a>分之合并框架</h2><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      JUC并发编程
    
    </summary>
    
    
      <category term="JUC" scheme="http://raptor1998.top/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://raptor1998.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper案例</title>
    <link href="http://raptor1998.top/2021/07/28/Zookeeper-plus/"/>
    <id>http://raptor1998.top/2021/07/28/Zookeeper-plus/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-07-28T07:19:34.281Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="服务器动态上下线监听案例"><a href="#服务器动态上下线监听案例" class="headerlink" title="服务器动态上下线监听案例"></a>服务器动态上下线监听案例</h1><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728090857.png" data-fancybox="group" data-caption="服务器动态上下线监听案例" class="fancybox"><img alt="服务器动态上下线监听案例" title="服务器动态上下线监听案例" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728090857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="DistributeServer"><a href="#DistributeServer" class="headerlink" title="DistributeServer"></a>DistributeServer</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>{</span><br><span class="line">        DistributeServer server = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">        <span class="comment">//1. 连接zk</span></span><br><span class="line">        server.getConnect();</span><br><span class="line">        <span class="comment">//2. 注册服务到zk集群</span></span><br><span class="line">        server.register(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//3. 启动业务逻辑</span></span><br><span class="line">        server.business();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        String s = zkClient.create(<span class="string">"/servers/"</span> + hostname, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + <span class="string">"is online!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="DistributeClient"><a href="#DistributeClient" class="headerlink" title="DistributeClient"></a>DistributeClient</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>{</span><br><span class="line">        DistributeClient distributeClient = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">        distributeClient.getConnect();</span><br><span class="line">        <span class="comment">//监听、servers下节点的上下线</span></span><br><span class="line">        distributeClient.getServerList();</span><br><span class="line"></span><br><span class="line">        distributeClient.business();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/servers"</span>, <span class="keyword">true</span>);</span><br><span class="line">        ArrayList&lt;Object&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String child : children) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/servers/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    getServerList();</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><blockquote><p>什么叫做分布式锁?</p></blockquote><p>比如说”进程 1”在使用该资源的时候，会先去获得锁，”进程 1”获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，”进程 1”用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁.</p><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728100139.png" data-fancybox="group" data-caption="Zookeeper分布式锁" class="fancybox"><img alt="Zookeeper分布式锁" title="Zookeeper分布式锁" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210728100139.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h2><h3 id="DistributeLock"><a href="#DistributeLock" class="headerlink" title="DistributeLock"></a>DistributeLock</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String connectString = <span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> String waitPath;</span><br><span class="line">    <span class="keyword">private</span> String currentNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributeLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>{</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>{</span><br><span class="line">                <span class="comment">//connectLatch  已经连接上  可以释放</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected) {</span><br><span class="line">                    connectLatch.countDown();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//waitLatch 需要释放</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted &amp;&amp; watchedEvent.getPath().equals(waitPath)) {</span><br><span class="line">                    waitLatch.countDown();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待zk连接成功再继续执行</span></span><br><span class="line">        connectLatch.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断根结点/locks是否存在</span></span><br><span class="line">        Stat stat = zkClient.exists(<span class="string">"/locks"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"创建/locks"</span>);</span><br><span class="line">            <span class="comment">//创建根结点</span></span><br><span class="line">            zkClient.create(<span class="string">"/locks"</span>, <span class="string">"locks"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkLock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">//创建对应的临时带序号的节点</span></span><br><span class="line"></span><br><span class="line">        currentNode = zkClient.create(<span class="string">"/locks/"</span> + <span class="string">"seq-"</span>, <span class="keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//先判断创建的节点是否是最小的节点，如果是  获取到锁  不是的话 监听他序号前一个节点</span></span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/locks"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//如果只有一个节点  那就直接获取锁  如果有多个节点 需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (children.size() == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Collections.sort(children);</span><br><span class="line">            <span class="comment">//获取对应的节点名称  seq-000000000</span></span><br><span class="line">            String thisNode = currentNode.substring(<span class="string">"/locks/"</span>.length());</span><br><span class="line">            <span class="comment">// 通过seq-0000000在 集合中的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = children.indexOf(thisNode);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) {</span><br><span class="line">                System.out.println(<span class="string">"数据异常"</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//只有一个几点  直接获取锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//获取前一个节点变化</span></span><br><span class="line">                waitPath = <span class="string">"/locks/"</span> + children.get(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] data = zkClient.getData(waitPath, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//等待监听</span></span><br><span class="line">                waitLatch.await();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkUnlock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        zkClient.delete(currentNode, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="LockTest"><a href="#LockTest" class="headerlink" title="LockTest"></a>LockTest</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException, KeeperException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DistributeLock lock1 = <span class="keyword">new</span> DistributeLock();</span><br><span class="line">        <span class="keyword">final</span> DistributeLock lock2 = <span class="keyword">new</span> DistributeLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.zkLock();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 启动  获取到锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    lock1.zkUnlock();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock2.zkLock();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 启动  获取到锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    lock2.zkUnlock();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Curator实现、"><a href="#Curator实现、" class="headerlink" title="Curator实现、"></a>Curator实现、</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="CuratorTest"><a href="#CuratorTest" class="headerlink" title="CuratorTest"></a>CuratorTest</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建分布式锁1</span></span><br><span class="line">        InterProcessMutex lock1 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">"/locks"</span>);</span><br><span class="line">        <span class="comment">//创建分布式锁2</span></span><br><span class="line">        InterProcessMutex lock2 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">"/locks"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 获取到锁"</span>);</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 再次获取到锁"</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 释放锁"</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程1 再次释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 获取到锁"</span>);</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 再次获取到锁"</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 释放锁"</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 再次释放锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CuratorFramework <span class="title">getCuratorFramework</span><span class="params">()</span> </span>{</span><br><span class="line">        ExponentialBackoffRetry policy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="string">"192.168.131.132:2181,192.168.131.133:2181,192.168.131.134:2181"</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">                .retryPolicy(policy).build();</span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">"zookeeper 启动成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p><strong>半数机制，超过半数的投票通过，即通过。</strong></p><p>（1）第一次启动选举规则：</p><p><strong>投票过半数时，服务器 id 大的胜出</strong></p><p>（2）第二次启动选举规则：</p><p><strong>①EPOCH 大的直接胜出</strong></p><p><strong>②EPOCH 相同，事务 id 大的胜出</strong></p><p><strong>③事务 id 相同，服务器 id 大的胜出</strong></p><h2 id="生产集群安装多少-zk-合适？"><a href="#生产集群安装多少-zk-合适？" class="headerlink" title="生产集群安装多少 zk 合适？"></a><strong>生产集群安装多少</strong> <strong>zk</strong> 合适？</h2><p><strong>安装奇数台</strong></p><ul><li><p>生产经验：</p><p>10 台服务器：3 台 zk； </p><p>20 台服务器：5 台 zk；</p><p>100 台服务器：11 台 zk； </p><p>200 台服务器：11 台 zk</p></li></ul><p><strong>服务器台数多：好处，提高可靠性；坏处：提高通信延时</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      Zookeeper基础
    
    </summary>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://raptor1998.top/tags/Zookeeper/"/>
    
  </entry>
  
</feed>
