<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>raptor&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raptor1998.top/"/>
  <updated>2022-08-23T12:38:23.664Z</updated>
  <id>http://raptor1998.top/</id>
  
  <author>
    <name>陳 ？</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql日志</title>
    <link href="http://raptor1998.top/2022/08/23/mysql-%E6%97%A5%E5%BF%97/"/>
    <id>http://raptor1998.top/2022/08/23/mysql-%E6%97%A5%E5%BF%97/</id>
    <published>2022-08-22T16:00:00.000Z</published>
    <updated>2022-08-23T12:38:23.664Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body></body></html>]]></content>
    
    <summary type="html">
    
      desc
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
      <category term="MySQL" scheme="http://raptor1998.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://raptor1998.top/2022/08/19/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://raptor1998.top/2022/08/19/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-08-18T16:00:00.000Z</published>
    <updated>2022-08-19T03:28:47.390Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h1><h2 id="Serial-串行回收"><a href="#Serial-串行回收" class="headerlink" title="Serial  串行回收"></a>Serial  串行回收</h2><p>Serial采用的是<strong>复制算法</strong>的垃圾收集器，而且是<strong>单线程运作</strong>的。也就是说，当Serial进行垃圾收集时，必须要暂停其他所有线程的工作，直到垃圾收集完成，这个动作叫STW（Stop The World） 。Golang中的GC也会存在STW，在其标记阶段的准备过程中会暂停掉所有正在运行的Goroutine。</p><p>而且这个暂停动作对用户来说是不可见的，用户可能只会知道某个请求执行了很久，没有经验的话是很难跟GC挂上钩的。</p><p>但是从某些方面来看，如果你的系统就只有单核，那么Serial就不会存在线程之间的交互的开销，可以提高GC的效率。这也是为什么Serial仍然是Client模式下的默认新生代收集器。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182007931.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="ParNew-并行回收"><a href="#ParNew-并行回收" class="headerlink" title="ParNew 并行回收"></a>ParNew 并行回收</h2><p>ParNew与Serial只有一个区别，那就是ParNew是<strong>多线程</strong>的，而Serial是<strong>单线程</strong>的。除此之外，其使用的垃圾收集算法和收集行为完全一样。</p><p>该收集器如果在单核的环境下，其性能可能会比Serial更差一些，因为单核无法发挥多线程的优势。在多核环境下，其默认的线程与CPU数量相同。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182008541.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="Parallel-Scavenge-吞吐量优先"><a href="#Parallel-Scavenge-吞吐量优先" class="headerlink" title="Parallel Scavenge 吞吐量优先"></a>Parallel Scavenge 吞吐量优先</h2><p>Parallel Scavenge是一个多线程的收集器，也是在server模式下的默认垃圾收集器。上面的两种收集器关注的重点是如何减少STW的时间，而Parallel Scavenge则更加关注于系统的吞吐量。</p><p>例如JVM已经运行了100分钟，而GC了1分钟，那么此时系统的吞吐量为(100 - 1)/100 = 99% 。</p><p><code>吞吐量和短停顿时间其侧重的点不一样，需要根据自己的实际情况来判断。</code></p><ul><li><p>高吞吐量<br>  GC的总时间越短，系统的吞吐量则越高。换句话说，高吞吐量则意味着，STW的时间可能会比正常的时间多一点，也就更加适合那种不存在太多交互的后台的系统，因为对实时性的要求不是很高，就可以高效率的完成任务。</p></li><li><p>短停顿时间<br>  STW的时间短，则说明对系统的响应速度要求很高，因为要跟用户频繁的交互。因为低响应时间会带来较高的用户体验。</p></li></ul><h1 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h1><h2 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h2><p>Serial Old是Serial的老年代版本，使用的标记-整理算法， 其实从这看出来，新生代和老年代收集器的一个差别。</p><blockquote><p>新生代：大部分的资源都是需要被回收</p></blockquote><blockquote><p>老年代：大部分的资源都不需要被回收</p></blockquote><p>所以，新生代收集器基本都是用的<strong>复制算法</strong>，老年代收集器基本都是用的<strong>标记-整理</strong>算法。</p><p>Serial Old也是给Client模式下JVM使用的。</p><h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p>Parallel Old是Parallel Scavenge的老年代版本，也是一个多线程的、采用<strong>标记-整理</strong>算法的收集器，刚刚讨论过了系统吞吐量，那么在对CPU的资源十分敏感的情况下， 可以考虑Parallel Scavenge和Parallel Old这个新生代-老年代的垃圾收集器组合。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025950.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><p>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025973.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>从图中可以看出其核心的步骤：</p><blockquote><ul><li>首先会进行<strong>初始标记</strong>，标记从GCRoots出发能够关联到的所有对象，此时需要STW，但是不需要很多时间</li><li>然后会进行<strong>并发标记</strong>，多线程对所有对象通过GC Roots Tracing进行可达性分析，这个过程较为耗时</li><li>完成之后会<strong>重新标记</strong>，由于在并发标记的过程中，程序还在正常运行，此时有些对象的状态可能已经发生了变化，所以需要STW，来进行重新标记，所用的时间大小关系为<code>初始标记 &lt; 重新标记 &lt; 并发标记</code>。</li><li>标记阶段完成之后，开始执行<strong>并发清除</strong>。</li></ul></blockquote><p>CMS是一个优点很明显的的垃圾收集器，例如可以多线程的进行GC，且拥有较低的STW的时间。但是同样的，CMS也有很多缺点。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使用标记-清除算法会造成不连续的内存空间，也就是内存碎片。如果此时需要给较大的对象分配空间，会发现内存不足，重新触发一次Full GC。</p><p>其次，由于CMS可能会比注重<strong>吞吐量</strong>的收集器占用更多的CPU资源，但是如果应用程序本身就已经对CPU资源很敏感了，就会导致GC时的可用CPU资源变少，GC的整个时间就会变长，那么就会导致系统的吞吐量降低。</p><h3 id="为什么不使用标记整理算法"><a href="#为什么不使用标记整理算法" class="headerlink" title="为什么不使用标记整理算法"></a>为什么不使用标记整理算法</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><p>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><h3 id="如何选择回收器"><a href="#如何选择回收器" class="headerlink" title="如何选择回收器"></a>如何选择回收器</h3><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p><p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p><p>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1全称Garbage First，业界目前对其评价很高，JDK9中甚至提议将其设置为默认的垃圾收集器。Parallel Scavenge更加关注于吞吐量，而CMS更加关注于更短的STW时间，那么G1就是在实现高吞吐的同时，尽可能的减少STW的时间。</p><p>垃圾收集器都会把连续的堆内存空间分为新生代、老年代，新生代则被划分的更加的细，有Eden和两个较小的Survivor空间，而且都是连续的内存空间。而G1则与众不同，它引入了新的概念，叫<strong>Region</strong>。</p><p>Region是一堆<strong>大小相等</strong>但是<strong>不连续</strong>的内存空间，同样是采用了分代的思想，但是不存在其他的收集器的物理隔离，属于新生代和老年代的region分布在堆的各个地方。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182025992.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><code>H则代表大对象，也叫Humongous Object。为了防止大对象的频繁拷贝，会直接的将其放入老年代</code></p><h3 id="回收过程-1"><a href="#回收过程-1" class="headerlink" title="回收过程"></a>回收过程</h3><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220316160315.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><strong>从宏观上来看，其采用的是标记-整理算法， 而从region到region来看，其采用的是复制算法的，所以G1在运行期间不会像CMS一样产生内存碎片。</strong></p><h4 id="分区region"><a href="#分区region" class="headerlink" title="分区region"></a>分区region</h4><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208182042718.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h1><h2 id="JVM参数参考"><a href="#JVM参数参考" class="headerlink" title="JVM参数参考"></a>JVM参数参考</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jvmOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xms6144m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xmx6144m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Xmn1024m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:SurvivorRatio=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+UseG1GC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MaxGCPauseMillis=200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:ParallelGCThreads=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:ConcGCThreads=8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MetaspaceSize=256m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:MaxMetaspaceSize=512M</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+PrintGCDetails</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-XX:+PrintHeapAtGC</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-javaagent:/opt/tiger/skywalking/skywalking-agent/skywalking-agent.jar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-Dskywalking.agent.service_name=toutiao.cg.wolong</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="G1其他"><a href="#G1其他" class="headerlink" title="G1其他"></a>G1其他</h2><h3 id="关键细节"><a href="#关键细节" class="headerlink" title="关键细节"></a>关键细节</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191120320.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191124064.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191125838.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191108135.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="与CMS对比"><a href="#与CMS对比" class="headerlink" title="与CMS对比"></a>与CMS对比</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191109445.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://raptor1998.top/2022/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
    <id>http://raptor1998.top/2022/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/</id>
    <published>2022-08-17T16:00:00.000Z</published>
    <updated>2022-08-24T09:38:01.545Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>Volatile是Java虚拟机提供的轻量级的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p><code>Java Memory Model</code>，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208172139279.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208172139279.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设是主物理内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">60</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile的可见性</span></span><br><span class="line"><span class="comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args [])</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 资源类</span></span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AAA线程 实现了Runnable接口的，lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程睡眠3秒，假设在进行运算</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 修改number的值</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出修改后的值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t update number value:"</span> + myData.number);</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"AAA"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.number == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// main线程就一直在这里等待循环，直到number的值不等于零</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span></span><br><span class="line">        <span class="comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后输出结果：</span></span><br><span class="line"><span class="comment">         * AAA come in</span></span><br><span class="line"><span class="comment">         * AAA update number value:60</span></span><br><span class="line"><span class="comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建10个线程，线程里面进行1000次循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        <span class="comment">// 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) {</span><br><span class="line">            myData.addPlusPlus();</span><br><span class="line">        }</span><br><span class="line">    }, String.valueOf(i)).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="禁止指令重拍"><a href="#禁止指令重拍" class="headerlink" title="禁止指令重拍"></a>禁止指令重拍</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p><p><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></p><h4 id="DCL单例模式"><a href="#DCL单例模式" class="headerlink" title="DCL单例模式"></a>DCL单例模式</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1、分配对象内存空间</span></span><br><span class="line">instance(memory); <span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3、设置instance指向刚刚分配的内存地址，</span></span><br></pre></td></tr></tbody></table></figure></div><p>此时instance != null<br>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1、分配对象内存空间</span></span><br><span class="line">instance = memory; <span class="comment">// 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory); <span class="comment">// 2、初始化对象</span></span><br></pre></td></tr></tbody></table></figure></div><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span> <span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法SingletonDemo"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) //<span class="title">b</span></span></span><br><span class="line"><span class="class">            </span>{ </span><br><span class="line">           <span class="comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) { </span><br><span class="line">                <span class="comment">// d 此时才开始初始化</span></span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的<br>以AtomicInteger为例</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个原子类</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">     * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">"\t current data: "</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">"\t current data: "</span> + atomicInteger.get());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    } <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="什么叫ABA"><a href="#什么叫ABA" class="headerlink" title="什么叫ABA"></a>什么叫ABA</h3><p>在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="如何解决ABA"><a href="#如何解决ABA" class="headerlink" title="如何解决ABA"></a>如何解决ABA</h3><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第一次版本号"</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第二次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第三次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 第一次版本号"</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 修改成功否："</span> + result + <span class="string">"\t 当前最新实际版本号："</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 当前实际最新值"</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t4"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！</a></p><p><a href="https://www.cnblogs.com/heyouxin/p/13037146.html" target="_blank" rel="noopener">【并发编程】公平锁与非公平锁的区别</a></p><p><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></p><h2 id="synchronized锁实现"><a href="#synchronized锁实现" class="headerlink" title="synchronized锁实现"></a>synchronized锁实现</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p><p>加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p><p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p><p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p><p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p><p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><h4 id="偏向锁-、-轻量级锁-、-重量级锁"><a href="#偏向锁-、-轻量级锁-、-重量级锁" class="headerlink" title="偏向锁 、 轻量级锁 、 重量级锁"></a>偏向锁 、 轻量级锁 、 重量级锁</h4><blockquote><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ corePoolSize：核心线程数，线程池中的常驻核心线程数</span><br><span class="line">    </span><br><span class="line">    在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</span><br><span class="line">    </span><br><span class="line">    当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</span><br><span class="line">+ maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、</span><br><span class="line">    相当有扩容后的线程数，这个线程池能容纳的最多线程数</span><br><span class="line">+ keepAliveTime：多余的空闲线程存活时间</span><br><span class="line">    当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</span><br><span class="line">    </span><br><span class="line">    默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</span><br><span class="line">+ unit：keepAliveTime的单位</span><br><span class="line">+ workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）</span><br><span class="line">    LinkedBlockingQueue：链表阻塞队列</span><br><span class="line"></span><br><span class="line">    SynchronousBlockingQueue：同步阻塞队列</span><br><span class="line"></span><br><span class="line">+ threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</span><br><span class="line"></span><br><span class="line">+ handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</span><br></pre></td></tr></tbody></table></figure></div><h2 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h2><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</p><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p><p>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><strong>Executors返回的线程池对象弊端如下：</strong></p><p>FixedThreadPool和SingleThreadPool：运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</p><p>CacheThreadPool和ScheduledThreadPool<br>非核心线程数为：Integer.MAX_VALUE，线程数上限太大导致oom</p><h2 id="参数如何设置"><a href="#参数如何设置" class="headerlink" title="参数如何设置"></a>参数如何设置</h2><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><strong><em>1. 非核心线程的创建时机</em></strong></p><ul><li><p>核心线程的数量是 corePoolSize 的值，非核心线程的数量是 maxinumPoolSize - corePoolSize ；</p></li><li><p>非核心线程创建的触发时机是：当前线程池中核心线程已满，且没有空闲的线程，还有任务等待队列已满，满足上面的所有条件，才会去创建线程去执行新提交的任务；</p></li><li><p>如果线程池中的线程数量达到 maxinumPoolSize 的值，此时还有任务进来，就会执行拒绝策略，抛弃任务或者其他</p></li></ul><p><strong>如果拒绝策略是抛弃任务的话，有一种场景，就会造成大量任务的丢弃，就是瞬时冲高的情况下。</strong></p><p><strong><em>2. 排队任务调度策略</em></strong></p><ul><li><p>当线程池中核心线程数量已达标，且没有空闲线的情况下，在产生的任务，会加入到等待队列中去，这样一直持续下去，</p></li><li><p>等到等待队列已满，在来的任务，会创建非核心线程去执行新提交的任务，那么就产生一种结果，在等待队列中的任务是先提交的任务，反而没有在此时提交的任务先执行。</p></li></ul><p><strong>任务的执行顺序和任务的提交顺序不一致，如果业务需求的任务是有先后依赖关系的，就会降低线程的调度效率</strong></p><h2 id="拒绝策略使用场景"><a href="#拒绝策略使用场景" class="headerlink" title="拒绝策略使用场景"></a>拒绝策略使用场景</h2><p><strong>中止策略：无特殊场景。</strong><br><strong>丢弃策略：无关紧要的任务（博客阅读量）。</strong><br><strong>弃老策略：发布消息。</strong><br><strong>调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）。</strong></p><h3 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h3><p><strong>丢弃任务并抛出RejectedExecutionException异常。</strong></p><p>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.<br>使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h3 id="DiscardPolicy丢弃策略"><a href="#DiscardPolicy丢弃策略" class="headerlink" title="DiscardPolicy丢弃策略"></a>DiscardPolicy丢弃策略</h3><p><strong>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</strong></p><p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</p><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作。<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</p><h3 id="DiscardOldestPolicy弃老策略"><a href="#DiscardOldestPolicy弃老策略" class="headerlink" title="DiscardOldestPolicy弃老策略"></a>DiscardOldestPolicy弃老策略</h3><p><strong>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</strong></p><p>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</p><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</p><h3 id="CallerRunsPolicy调用者运行策略"><a href="#CallerRunsPolicy调用者运行策略" class="headerlink" title="CallerRunsPolicy调用者运行策略"></a>CallerRunsPolicy调用者运行策略</h3><p><strong>由调用线程处理该任务。</strong></p><p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p><h2 id="常见队列"><a href="#常见队列" class="headerlink" title="常见队列"></a>常见队列</h2><p><strong>1）ArrayBlockingQueue</strong></p><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><p><strong>（2）LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；</p><p>newFixedThreadPool线程池使用了这个队列。</p><p><strong>（3）DelayQueue</strong></p><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。</p><p>newScheduledThreadPool线程池使用了这个队列。</p><p><strong>（4）PriorityBlockingQueue</strong></p><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；</p><p><strong>（5）SynchronousQueue</strong></p><p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene</p><p>newCachedThreadPool线程池使用了这个队列。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从名字我们就可以看到ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p> 为每个线程复制一份变量副本。</p><p> 底层使用的一个ThreadLocalMap对象存储（键值对存储）。</p><p> 使用ThreadLocal会存在内存泄漏问题。</p><p> 使用ThreadLocal对象作为键存储，是弱引用的，可以被回收掉，键为null，但是value值是强引用，不能被回收。</p><p> 建议：在使用完后，主动调用remove()，删除</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191813112.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208191813112.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><h3 id="key-ThreadLocal是强引用"><a href="#key-ThreadLocal是强引用" class="headerlink" title="key=ThreadLocal是强引用"></a>key=ThreadLocal是强引用</h3><ul><li><p>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</p></li><li><p>但是因为threadLocalMap的Entry强引用了threadLocal(key就是threadLocal), 造成ThreadLocal无法被回收</p></li><li><p>在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, 始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏</p></li></ul><p>  <strong>也就是说: ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的</strong></p><h3 id="key-ThreadLocal是弱引用"><a href="#key-ThreadLocal是弱引用" class="headerlink" title="key=ThreadLocal是弱引用"></a>key=ThreadLocal是弱引用</h3><ul><li>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</li><li>由于threadLocalMap只持有ThreadLocal的弱引用, 没有任何强引用指向threadlocal实例（这里Entry不再强引用ThreadLocal了）, 所以threadlocal就可以顺利被gc回收, 此时Entry中的key = null</li><li>在没有手动删除Entry以及CurrentThread依然运行的前提下, 也存在始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry,value就不会被回收, 而这块value永远不会被访问到了（因为key=null）, 导致value内存泄漏</li></ul><p><strong>也就是说: ThreadLocalMap中的key使用了弱引用, 也有可能内存泄漏</strong></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>文末的解释写更加清晰</strong></p><p>如果<code>ThreadLocalMap</code>的<code>key</code>为强引用回收<code>ThreadLocal</code>时，因为<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>就不会被回收，导致<code>Entry</code>内存泄漏。</p><p><code>ThreadLocalMap</code>的<code>key</code>为弱引用回收<code>ThreadLocal</code>时，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。当key为null，在下一次<code>ThreadLocalMap</code>调用set(),get(),remove()时会清除value的值。</p><p><strong>因此，<code>ThreadLocal</code>内存泄漏的根源是由于<code>ThreadLocalMap</code>的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不因为弱引用。</strong></p><p><strong><code>ThreadLocal</code>正确的使用方法：</strong></p><ol><li>每次使用完<code>ThreadLocal</code>都要调用它的remove()清除数据。</li><li>将<code>ThreadLoca</code>l变量定义成<code>private static</code>，这样就一直存在<code>ThreadLocal</code>的强引用，也能保证任何时候都能通过<code>ThreadLocal</code>的弱引用访问到Entry的value值，进而清除掉。</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/JH39456194/article/details/107304997" target="_blank" rel="noopener">threadlocal内存泄露问题</a></p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h1 id="并发容器-amp-阻塞队列"><a href="#并发容器-amp-阻塞队列" class="headerlink" title="并发容器 &amp; 阻塞队列"></a>并发容器 &amp; 阻塞队列</h1><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrenthashmap" target="_blank" rel="noopener">https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrenthashmap</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://raptor1998.top/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://raptor1998.top/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-16T16:00:00.000Z</published>
    <updated>2022-08-19T06:20:50.660Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>1、物理层：实现计算机节点之间比特流的透明传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p><p>2、数据链路层：通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p><p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p><p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：实现网络地址与物理地址的转换，并通过路由选择算法为分组通过通信子网选择最适当的路径</p><p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p><p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p><p>网络层协议负责的是提供主机间的逻辑通信；<br>传输层协议负责的是提供进程间的逻辑通信。<br>5、会话层：是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持、终止通信。</p><p>6、表示层：处理用户数据的表示问题，如数据的编码、格式转换、加密和解密、压缩和解压缩。</p><p>7、应用层：为用户的应用进程提供网络通信服务，完成和实现用户请求的各种服务。</p><h1 id="浏览器中输入一个网址它的运行过程"><a href="#浏览器中输入一个网址它的运行过程" class="headerlink" title="浏览器中输入一个网址它的运行过程"></a>浏览器中输入一个网址它的运行过程</h1><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p><strong>1、查询DNS，获取域名对应的IP。</strong></p><p>（1）检查浏览器缓存、检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p><p>（2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。</p><p>（3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：</p><p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p><p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p><p>（4）如果本地DNS服务器也失效：</p><p>如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<a href="http://baidu.com/" target="_blank" rel="noopener">http://baidu.com</a>）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</p><p>如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</p><p><strong>2、得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文：</strong></p><p>（1）应用层：客户端发送HTTP请求报文。</p><p>（2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。</p><p>（3）网络层：（加入IP头）路由寻址。</p><p>（4）数据链路层：（加入frame头）传输数据。</p><p>（5）物理层：物理传输bit。</p><p><strong>3、服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。</strong></p><p><strong>4、关闭连接，TCP四次挥手。</strong></p><p><strong>5、客户端解析HTTP响应报文，浏览器开始显示HTML</strong></p><h1 id="TCP的连接建立与断开"><a href="#TCP的连接建立与断开" class="headerlink" title="TCP的连接建立与断开"></a>TCP的连接建立与断开</h1><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171127810" data-fancybox="group" data-caption="三次握手" class="fancybox"><img alt="三次握手" title="三次握手" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171127810" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128756.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128756.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><h3 id="为什么不能用两次握手进行建立连接？"><a href="#为什么不能用两次握手进行建立连接？" class="headerlink" title="为什么不能用两次握手进行建立连接？"></a>为什么不能用两次握手进行建立连接？</h3><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><ul><li><p>三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p><p>因为TCP协议是双向的，第三次握手是为了使得sever知道客户答应了连接的请求。其中两次握手只能确定<strong>从客户端到服务端的网络是可达的</strong>，但却<strong>无法保证从服务端到客户端的网络是可达的</strong>。所以我们一定要保证双向的可达。</p></li><li><p>三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p><p>客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文段后：</p><ul><li>假设不采用“三次握手”，那么只要Sever发出确认，新的连接就建立了。但由于现在Client并没有发出建立连接的请求，因此不会理睬Server的确认，也不会向Server发送数据。而Server却以为新的连接已经建立，并一直等待Client发来数据，这样，Server的很多资源就白白浪费掉了</li><li>而采用“三次握手”协议，只要Server收不到来自Client的确认，就知道Client并没有要求建立请求，就不会建立连接了。</li></ul></li></ul><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><h3 id="挥手过程"><a href="#挥手过程" class="headerlink" title="挥手过程"></a>挥手过程</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128075" data-fancybox="group" data-caption="四次挥手" class="fancybox"><img alt="四次挥手" title="四次挥手" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171128075" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129832.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129832.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h1 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP, UDP 协议的区别"></a>TCP, UDP 协议的区别</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129736.jpeg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171129736.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h1 id="什么是https和http"><a href="#什么是https和http" class="headerlink" title="什么是https和http"></a>什么是https和http</h1><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="http存在的问题"><a href="#http存在的问题" class="headerlink" title="http存在的问题"></a>http存在的问题</h2><ul><li>通信使用明文不加密，通信内容可能被窃听；</li><li>无法验证报文的完整性，数据内容可能被篡改</li><li>不验证通信方身份、可能遭到伪装，无法保证数据发送到正确的机器上；</li></ul><h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p>https 是基于tcp协议，在http的基础上加入了SSL/TLS，可看成是添加了加密和认证机制的http，使用对称加密、非对称加密、证书等技术进行进行客户端与服务端的数据加密传输，最终达到保证整个通信的安全性。</p><p>对称加密指加密和解密都使用同一个密钥的方式，这种方式存在如何安全地将密钥发送对方的问题；非对称加密使用两个密钥，公钥加密则需要私钥解密，私钥加密则需要公钥解密。不能私钥加密，私钥解密。非对称加密不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，速度非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><p><strong>证书通常包含这些内容：(1) 服务端的公钥；(2) 证书发行者(CA)对证书的数字签名；(3) 证书所用的签名算法；(4) 证书发布机构、有效期、所有者的信息等其他信息</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130100.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130100.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><h2 id="https的认证加密过程？如何保证内容不会被篡改的？"><a href="#https的认证加密过程？如何保证内容不会被篡改的？" class="headerlink" title="https的认证加密过程？如何保证内容不会被篡改的？"></a>https的认证加密过程？如何保证内容不会被篡改的？</h2><p>（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立<br>（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息<br>（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性<br>（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端<br>（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</p><h2 id="根证书如何保证签发的证书是安全有效的？"><a href="#根证书如何保证签发的证书是安全有效的？" class="headerlink" title="根证书如何保证签发的证书是安全有效的？"></a>根证书如何保证签发的证书是安全有效的？</h2><p>（1）服务器会预先生成非对称加密密钥，私钥S.pri自己保留，而公钥S.pub则发送给CA进行签名认证<br>（2）CA机构也会预先生成非对称加密密钥，其私钥C.pri用来对服务器的公钥S.pub进行签名，生成CA证书<br>（3）CA机构将签名生成的CA证书返回给服务器，也就是前面服务端给客户端那个证书<br>（4）因为CA机构比较权威，所以很多浏览器会内置包含它公钥C.pub的证书，称之为根证书，然后可以使用根证书来验证其颁发证书的合法性了</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130488.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171130488.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>1、本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器<br>2、中间人服务器返回中间人自己的证书<br>3、客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。<br>4、中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密<br>5、中间人以客户端的请求内容再向正规网站发起请求<br>6、因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据<br>7、中间人凭借与正规网站建立的对称加密算法对内容进行解密<br>8、中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输<br>9、客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</p><p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p><h2 id="非对称加密和对称加密"><a href="#非对称加密和对称加密" class="headerlink" title="非对称加密和对称加密"></a>非对称加密和对称加密</h2><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><strong>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</strong></p><h1 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h1><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如 </p><p>① 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；② 一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密。</p><h1 id="get和-post-请求的区别"><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a>get和 post 请求的区别</h1><p>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。<br>（2）幂等性：get 是幂等的，post 为非幂等的<br>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。<br>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。<br>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。<br>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。<br>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</p><h1 id="关于https的其他解释"><a href="#关于https的其他解释" class="headerlink" title="关于https的其他解释"></a>关于https的其他解释</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171131640.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208171131640.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p></body></html>]]></content>
    
    <summary type="html">
    
      desc
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ipv4到ipv6改造</title>
    <link href="http://raptor1998.top/2022/08/16/ByteStudy%20ipv4%E5%88%B0ipv6%E6%94%B9%E9%80%A0/"/>
    <id>http://raptor1998.top/2022/08/16/ByteStudy%20ipv4%E5%88%B0ipv6%E6%94%B9%E9%80%A0/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-08-15T13:32:04.571Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="IPv6的3种表示方法"><a href="#IPv6的3种表示方法" class="headerlink" title="IPv6的3种表示方法"></a>IPv6的3种表示方法</h1><ol><li><p>冒分十六进制表示法<br> 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    　　ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</span><br></pre></td></tr></tbody></table></figure></div><p> 　　这种表示法中，每个X的前导0是可以省略的，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    　　2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>0位压缩表示法<br> 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    　　FF01:0:0:0:0:0:0:1101 → FF01::1101</span><br><span class="line">    　　0:0:0:0:0:0:0:1 → ::1</span><br><span class="line">    　　0:0:0:0:0:0:0:0 → ::</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>内嵌IPv4地址表示法</p><p> 为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用 。</p></li></ol><h1 id="过度技术"><a href="#过度技术" class="headerlink" title="过度技术"></a>过度技术</h1><h2 id="双栈技术"><a href="#双栈技术" class="headerlink" title="双栈技术"></a>双栈技术</h2><p>主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。</p><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><p>在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。</p><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p><h2 id="协议翻译技术"><a href="#协议翻译技术" class="headerlink" title="协议翻译技术"></a>协议翻译技术</h2><p>对IPV6和IPV4报头时行相互翻译，实现IPV4/IPV6协议和地址的转换。</p><p>网络地址转换/协议转换技术 NAT-PT 通过与SIIT协议转换和传统的IPv4下的动态地址翻译（NAT）以及适当的应用层网关（ALG）相结合，实现了只安装了IPv6的主机和只安装了IPv4机器的大部分应用的相互通信。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.mfisp.com/6796.html" target="_blank" rel="noopener">详细对比IPv4与IPv6的区别 - 梦飞科技</a></p><p><a href="https://www.docin.com/p-2600732241.html" target="_blank" rel="noopener">浅析ＩＰｖ４到ＩＰｖ６的过渡技术（论文范文）</a></p><p><a href="https://blog.csdn.net/weixin_40228200/article/details/118737890" target="_blank" rel="noopener">IPv6-IPv4过渡技术详解及配置实例_永远是少年啊的博客-CSDN博客_ipv6toipv4</a></p><p><a href="https://blog.csdn.net/AIwenIPgeolocation/article/details/122925047" target="_blank" rel="noopener">从IPv4 到 IPv6 的过渡技术_AIwenIPgeolocation的博客-CSDN博客_ipv4到ipv6的过渡技术</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Java基础——集合</title>
    <link href="http://raptor1998.top/2022/08/15/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>http://raptor1998.top/2022/08/15/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</id>
    <published>2022-08-14T16:00:00.000Z</published>
    <updated>2022-08-16T06:58:44.099Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="与LinkedList的区别"><a href="#与LinkedList的区别" class="headerlink" title="与LinkedList的区别"></a>与LinkedList的区别</h3><ol><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</li><li>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</li><li>内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        } <span class="keyword">else</span> {<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">          <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入<code>grow(minCapacity)</code>方法。</p><p>当 add 第 2 个元素时，<code>minCapacity</code> 为 2，此时 <code>elementData.length(容量)</code>在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code>方法。</p><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p><p>直到添加第 11 个元素，<code>minCapacity(为 11)</code>比 <code>elementData.length（为 10）</code>要大。进入 grow 方法进行扩容。</p><h4 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h4><p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><p>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity(为 10)</code>。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</p><p>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入<code>hugeCapacity</code> 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。<br>以此类推······</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">       <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) {</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>HashMap中有两个重要的参数：初始容量大小和加载因子，初始容量大小是创建时给数组分配的容量大小，默认值为16，加载因子默认0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容.</p><p>在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能.</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>第一步首先将k,v封装到Node对象当中（节点）。</p><p>第二步它的底层会调用K的hashCode()方法得出hash值。第三步通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。</p><p>java1.8 中put 源码：put 中调用 putVal（）方法：</p><p>1.首先判断map中是否有数据，没有就执行resize方法</p><p>2.如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可</p><p>3.如果这个元素的key与要插入的一样，那么就替换一下。</p><p>4.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</p><p>5.遍历这条链子上的数据，完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</li><li>每次扩展的时候，都是扩展2倍；</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="为什么HashMap要树化"><a href="#为什么HashMap要树化" class="headerlink" title="为什么HashMap要树化"></a>为什么HashMap要树化</h3><p>之前在极客时间的专栏里看到过一个解释。本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p><p>用哈希碰撞发起拒绝服务攻击(DOS，Denial-Of-Service attack),常见的场景是攻击者可以事先构造大量相同哈希值的数据，然后以JSON数据的形式发送给服务器，服务器端在将其构建成为Java对象过程中，通常以Hashtable或HashMap等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数据级，进而耗费大量CPU资源。</p><h3 id="为什么要将链表中转红黑树的阈值设为8？"><a href="#为什么要将链表中转红黑树的阈值设为8？" class="headerlink" title="为什么要将链表中转红黑树的阈值设为8？"></a>为什么要将链表中转红黑树的阈值设为8？</h3><p>，当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）的要求，就会把链表转换为红黑树。同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。</p><p>每次遍历一个链表，平均查找的时间复杂度是 O(n)，n 是链表的长度。红黑树有和链表不一样的查找性能，由于红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n))。最初链表还不是很长，所以可能 O(n) 和 O(log(n)) 的区别不大，但是如果链表越来越长，那么这种区别便会有所体现。所以为了提升查找性能，需要把链表转化为红黑树的形式。</p><h3 id="hashmap、hashtable、treemap的却别"><a href="#hashmap、hashtable、treemap的却别" class="headerlink" title="hashmap、hashtable、treemap的却别"></a>hashmap、hashtable、treemap的却别</h3><p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。存储的内容是基于key-value的键值对映射，不能有重复的key，而且一个key只能映射一个value。HashSet底层就是基于HashMap实现的。</p><p>Hashtable的key、value都不能为null；HashMap的key、value可以为null，不过只能有一个key为null，但可以有多个null的value；TreeMap键、值都不能为null。</p><p>Hashtable、HashMap具有无序特性。TreeMap是利用红黑树实现的（树中的每个节点的值都会大于或等于它的左子树中的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需求排序的情况下首选TreeMap，默认按键的升序排序（深度优先搜索），也可以自定义实现Comparator接口实现排序方式。</p><h3 id="负载因子为什么是0-75"><a href="#负载因子为什么是0-75" class="headerlink" title="负载因子为什么是0.75"></a>负载因子为什么是0.75</h3><ul><li><p>负载1.0</p><p>  当负载因子是1.0时，也就意味着，只有当数组的8个值全部填充了，才会发生扩容。这就带来了很大的问题，因为Hash冲突时避免不了的。</p><p>  后果：当负载因子是1.0的时候，意味着会出现大量的Hash的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。</p><p>  <strong>虽然空间利用率上去了，但是时间效率降低了。</strong></p></li><li><p>负载0.5</p><p>  负载因子是0.5的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，Hash冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。<br>  此时空间利用率就会大大的降低，原本存储1M的数据，现在就意味着需要2M的空间。</p><p>  <strong>虽然时间效率提升了，但是空间利用率降低了。</strong></p></li></ul><h3 id="为什么是2倍扩容"><a href="#为什么是2倍扩容" class="headerlink" title="为什么是2倍扩容"></a>为什么是2倍扩容</h3><blockquote><p>第一是因为哈希函数的问题</p></blockquote><pre><code>通过除留余数法方式获取桶号，因为Hash表的大小始终为2的n次幂，因此可以将取模转为位运算操作，提高效率，容量n为2的幂次方，n-1的二进制会全为1，位运算时可以充分散列，避免不必要的哈希冲突，这也就是为什么要按照2倍方式扩容的一个原因</code></pre><blockquote><p>第二是因为是否移位的问题</p></blockquote><pre><code>是否移位，由扩容后表示的最高位是否1为所决定，并且移动的方向只有一个，即向高位移动。因此，可以根据对最高位进行检测的结果来决定是否移位，从而可以优化性能，不用每一个元素都进行移位，因为为0说明刚好在移位完之后的位置，为1说明不是需要移动oldCop，这也是其为什么要按照2倍方式扩容的第二个原因。</code></pre><h3 id="hashmap的线程安全问题"><a href="#hashmap的线程安全问题" class="headerlink" title="hashmap的线程安全问题"></a>hashmap的线程安全问题</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192000&amp;idx=1&amp;sn=118cee6d1c67e7b8e4f762af3e61643e&amp;chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">hashmap循环链表的形成</a></p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">1.7CurrentHashMap小灰漫画解释</a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161417058.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161417058.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></tbody></table></figure></div><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化 Segment 流程：</p><ul><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p><ol><li><p>检查计算得到的位置的 Segment 是否为null.</p></li><li><p>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</p></li><li><p>再次检查计算得到的指定位置的 Segment 是否为null.</p></li><li><p>使用创建的 HashEntry 数组初始化这个 Segment.</p></li><li><p>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment</p></li></ol></li><li><p>Get方法：</p><p>  1.为输入的Key做Hash运算，得到hash值。</p></li></ul><pre><code>2.通过hash值，定位到对应的Segment对象3.再次通过hash值，定位到Segment当中数组的具体位置。</code></pre><ul><li>Put方法：</li></ul><pre><code>1.为输入的Key做Hash运算，得到hash值。2.通过hash值，定位到对应的Segment对象3.获取可重入锁4.再次通过hash值，定位到Segment当中数组的具体位置。5.插入或覆盖HashEntry对象。6.释放锁。</code></pre><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><p>1 .tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。</p><ol start="2"><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><ul><li><p>如果这个位置上的 HashEntry 不存在：</p><p>  如果当前容量大于扩容阀值，小于最大容量，进行扩容。直接头插法插入。</p></li><li><p>如果这个位置上的 HashEntry 存在：<br>  判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</p><p>  不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。</p><pre><code>如果当前容量大于扩容阀值，小于最大容量，进行扩容。直接链表头插法插入。</code></pre></li></ul></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) {</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) {</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                e = e.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161444447.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208161444447.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h4><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</p></li></ol><p>#</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) {</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="面试总结" scheme="http://raptor1998.top/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://raptor1998.top/tags/Java/"/>
    
      <category term="面试总结" scheme="http://raptor1998.top/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy CICD</title>
    <link href="http://raptor1998.top/2022/08/12/ByteStudy%20CICD/"/>
    <id>http://raptor1998.top/2022/08/12/ByteStudy%20CICD/</id>
    <published>2022-08-11T16:00:00.000Z</published>
    <updated>2022-08-15T13:23:08.049Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152120447.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><blockquote><p>continuous integration (CI) is the practice of merging all developer working copies to a shared mainline several times a day.</p></blockquote><p><strong>频繁的（一天多次的）将所有开发者的工作合并到主干上。</strong></p><p><strong>优点：</strong></p><ul><li>易于定位错误：每一次的代码集成都需要执行相关的测试工作，持续集成频繁的集成次数天然的将复杂的代码逻辑切割为了小块，也就使得每一次测试中遇到的错误能够更加容易的被定位；</li><li>易于控制开发流程：更为细致的工作提交也就意味着更容易判断当前的工作进度，这对于管理者规划开发流程而言提供了一个有效的参考，同时也为开发人员省下了汇报工作的时间；</li><li>易于CodeReview：对于大块工作的切分自然也有助于做 CodeReview；</li><li>易于减少不必要的工作：build 以及 test 过程的自动化可以为你节约一大票的时间，从而投入到有价值的工作中去。<h1 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h1><blockquote><p>Continuous delivery (CD or CDE) is a software engineering approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time and, when releasing the software, doing so manually.</p></blockquote></li></ul><p><strong>一种能够使得软件在较短的循环中可靠的发布的软件工程方法。</strong> </p><p>与持续集成相比，持续交付的侧重点在于 交付，其核心对象不在于代码，而在于可交付的产物。由于持续集成仅仅针对于新旧代码的集成过程执行了一定的测试，其变动到持续交付后还需要一些额外的流程。</p><h1 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h1><blockquote><p>Continuous deployment (CD) is a software engineering approach in which software functionalities are delivered frequently through automated deployments.</p></blockquote><p><strong>通过自动化部署的手段将软件功能频繁的进行交付。</strong></p><p>与持续交付以及持续集成相比，持续部署强调了通过 automated deployment 的手段，对新的软件功能进行集成。</p><h1 id="基础泳道的规范"><a href="#基础泳道的规范" class="headerlink" title="基础泳道的规范"></a>基础泳道的规范</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152120464.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/xp178171640/article/details/124379156" target="_blank" rel="noopener">持续集成、持续交付、持续部署(转载)_xupeng1644的博客-CSDN博客_持续集成持续交付持续部署</a></p><p>CICD </p><p>基础泳道流程规范 </p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Month 2</title>
    <link href="http://raptor1998.top/2022/08/10/ByteDance6/"/>
    <id>http://raptor1998.top/2022/08/10/ByteDance6/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-15T12:39:10.824Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="一期上线"><a href="#一期上线" class="headerlink" title="一期上线"></a>一期上线</h1><p>正式开始第三个月，新小组满一个月，比之前小组的工作多多了，目前这条线只有我一个QA，所以会接触的更多一点，在一期需求上线过程中也是充满坎坷，一个是不熟悉bug流程规范，导致这之间的数据没有记录，到最后写报告啥也没得写；二是参与的团队极多，协调起来比较困难；三是上线过程中遇到的问题贼多，由于算法的能力没法在线下环境验证，所以只能等上下游均ready后，直接一刀切，生产商验证能力，导致产生了很多脏数据，由于搜索中台不稳定，导致很多脏数据遗留在了es中；最后是提供的物料不满足预期，只能三四个人大半夜的手动去处理。。。。上了几个12点后的班，这辈子没这么累过，谁也顶不住</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151950107.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>如果对于技术有追求，确实不适合来做QA，业务上的经验对于应届来讲实际意义不大，而且不断地有消息出来，整个部门一个hc都没有，最近准备开始回忆八股了，感觉有点晚了，没办法了，只能硬着头皮上了，准备这周末投几个试试水了，今年可太难了，去年字节8000+hc，今年3000+，实际可能只有1000+，说是政治任务，难顶。。。</p><h2 id="西湖晚霞"><a href="#西湖晚霞" class="headerlink" title="西湖晚霞"></a>西湖晚霞</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151951314.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151951521.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"hotkey":true,"preload":"metadata","video":{"url":"https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208151952688.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> </body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy filebeat原理</title>
    <link href="http://raptor1998.top/2022/08/05/ByteStudy%20filebeat%E5%8E%9F%E7%90%86/"/>
    <id>http://raptor1998.top/2022/08/05/ByteStudy%20filebeat%E5%8E%9F%E7%90%86/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-15T13:18:43.700Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ol><li>配置输入源, 可以是日志(log), 也可以是标准输入(stdin), 可以配置多个输入(input)</li><li>为每个日志启一个(Harvester) 收集器, 将不停的读取数据</li><li>数据卷轴, 将数据不断的输出到其它终端</li><li>终端, 如 es, kafaka, redis</li></ol><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152115374.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>工作原理是启动 filebeat 时, 它将启动一个或多个输入, 这些输入将在日志数据指定位置中查找, 对于 filebeat 所找到的每个日志, filebeat 都会启动收集器, 每个收割机都读取单个日志以获取新内容，并将新日志数据发送到libbeat，libbeat将聚集事件，并将聚集的数据发送到为Filebeat配置的输出</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="harvester-收割机"><a href="#harvester-收割机" class="headerlink" title="harvester(收割机)"></a>harvester(收割机)</h2><p>harvester :负责读取单个文件的内容。读取每个文件，并将内容发送到 the output</p><p>每个文件启动一个harvester, harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态</p><p>如果文件在读取时被删除或重命名，Filebeat将继续读取文件。</p><p>这有副作用，即在harvester关闭之前，磁盘上的空间被保留。默认情况下，Filebeat将文件保持打开状态，直到达到close_inactive状态</p><p>关闭harvester会产生以下结果：</p><p>1）如果在harvester仍在读取文件时文件被删除，则关闭文件句柄，释放底层资源。</p><p>2）文件的采集只会在scan_frequency过后重新开始。</p><p>3）如果在harvester关闭的情况下移动或移除文件，则不会继续处理文件。</p><p>要控制收割机何时关闭，请使用close_ *配置选项</p><h2 id="prospector-采矿者"><a href="#prospector-采矿者" class="headerlink" title="prospector(采矿者)"></a>prospector(采矿者)</h2><p>prospector 负责管理harvester并找到所有要读取的文件来源。</p><p>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个harvester。</p><p>每个prospector都在自己的Go协程中运行。</p><h1 id="Filebeat如何保持文件的状态？"><a href="#Filebeat如何保持文件的状态？" class="headerlink" title="Filebeat如何保持文件的状态？"></a>Filebeat如何保持文件的状态？</h1><p>Filebeat 保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中。<br>该状态用于记住harvester正在读取的最后偏移量，并确保发送所有日志行。</p><p>如果输出（例如Elasticsearch或Logstash）无法访问，Filebeat会跟踪最后发送的行，并在输出再次可用时继续读取文件。</p><p>在Filebeat运行时，每个prospector内存中也会保存的文件状态信息，<br>当重新启动Filebeat时，将使用注册文件的数据来重建文件状态，Filebeat将每个harvester在从保存的最后偏移量继续读取。</p><p>每个prospector为它找到的每个文件保留一个状态。</p><p>由于文件可以被重命名或移动，因此文件名和路径不足以识别文件。</p><p>对于每个文件，Filebeat存储唯一标识符以检测文件是否先前已采集过。</p><p>如果您的使用案例涉及每天创建大量新文件，您可能会发现注册文件增长过大。请参阅注册表文件太大？编辑有关您可以设置以解决此问题的配置选项的详细信息。</p><h1 id="Filebeat如何确保至少一次交付"><a href="#Filebeat如何确保至少一次交付" class="headerlink" title="Filebeat如何确保至少一次交付"></a>Filebeat如何确保至少一次交付</h1><p>Filebeat保证事件至少会被传送到配置的输出一次，并且不会丢失数据。 Filebeat能够实现此行为，因为它将每个事件的传递状态存储在注册文件中。</p><p>在输出阻塞或未确认所有事件的情况下，Filebeat将继续尝试发送事件，直<br>到接收端确认已收到。</p><p>如果Filebeat在发送事件的过程中关闭，它不会等待输出确认所有收到事件。</p><p>发送到输出但在Filebeat关闭前未确认的任何事件在重新启动Filebeat时会再次发送。</p><p>这可以确保每个事件至少发送一次，但最终会将重复事件发送到输出。<br>也可以通过设置shutdown_timeout选项来配置Filebeat以在关闭之前等待特定时间。</p><p>注意：</p><p>Filebeat的至少一次交付保证包括日志轮换和删除旧文件的限制。如果将日志文件写入磁盘并且写入速度超过Filebeat可以处理的速度，或者在输出不可用时删除了文件，则可能会丢失数据。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html</a></p><p><a href="https://blog.51cto.com/lansonli/5283480" target="_blank" rel="noopener">https://blog.51cto.com/lansonli/5283480</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ELK日志追踪</title>
    <link href="http://raptor1998.top/2022/08/04/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA/"/>
    <id>http://raptor1998.top/2022/08/04/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-15T13:11:00.756Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先食用此篇<br><a href="https://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/">ELK日志收集</a></p><p>MDC（Mapped Diagnostic Context）用于存储运行上下文的特定线程的上下文数据。因此，如果使用 log4j 进行日志记录，则每个线程都可以拥有自己的MDC，该 MDC 对整个线程是全局的。属于该线程的任何代码都可以轻松访问线程的 MDC 中存在的值。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152105838.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Nacos单节点启动"><a href="#Nacos单节点启动" class="headerlink" title="Nacos单节点启动"></a>Nacos单节点启动</h1><p><code>./bin/startup.sh -m standalone</code></p><h1 id="logback日志增加traceid"><a href="#logback日志增加traceid" class="headerlink" title="logback日志增加traceid"></a>logback日志增加traceid</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志输出格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">"%d{yyyy-MM-dd HH:mm:ss.SSS} | [%thread] | %-5level | %logger{50} | %X{traceId} | [%method,%line] | %msg%n"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="给上下游服务添加过滤器获取traceid"><a href="#给上下游服务添加过滤器获取traceid" class="headerlink" title="给上下游服务添加过滤器获取traceid"></a>给上下游服务添加过滤器获取traceid</h1><p><strong>启动类添加扫描</strong></p><p><strong>@ServletComponentScan</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>,filterName = <span class="string">"traceIdFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MDC_TRACE_ID = <span class="string">"traceId"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>{</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">        String traceId = httpRequest.getHeader(MDC_TRACE_ID);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(traceId)) {</span><br><span class="line">            traceId = IdUtil.fastSimpleUUID();;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" traceId "</span> + traceId);</span><br><span class="line">        MDC.put(MDC_TRACE_ID, traceId);</span><br><span class="line">        ThreadLocalUtils.setTraceId(traceId);</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        httpResponse.setHeader(MDC_TRACE_ID, traceId);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="调用者改造OpenFeign"><a href="#调用者改造OpenFeign" class="headerlink" title="调用者改造OpenFeign"></a>调用者改造OpenFeign</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>{</span><br><span class="line">        String traceId = MDC.get(TraceIdFilter.MDC_TRACE_ID);</span><br><span class="line">        System.out.println(<span class="string">"OpenFeignRequestInterceptor traceId "</span> + traceId);</span><br><span class="line">        requestTemplate.header(TraceIdFilter.MDC_TRACE_ID, traceId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152105857.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy ELK日志收集</title>
    <link href="http://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://raptor1998.top/2022/07/28/ByteStudy%20ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-08-15T13:04:09.666Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="日志收集意义"><a href="#日志收集意义" class="headerlink" title="日志收集意义"></a>日志收集意义</h1><p>分析日志是工程师发现问题，解决系统故障的主要手段。日志主要包括系统日志、应用程序日志和安全日志。</p><p>一般大型系统是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。通常，日志被分散的储存在不同的设备上。如果管理数十上百台服务器，还在使用依次登录每台机器的传统方法查阅日志，既繁琐又效率低下。为此，我们可以使用集中化的日志管理，例如：开源的 syslog，将所有服务器上的日志收集汇总。</p><p>集中化管理日志后，日志的统计和检查又成为一件比较麻烦的事情，一般我们使用 grep、awk 和 wc 等 Linux 命令能实现检索和统计，但是对于更高要求的查询、排序和统计等，再加上庞大的机器数量，使用这样的方法依然难免有点力不从心。</p><p>开源实时日志分析 ELK 平台能够完美的解决我们上述的问题，ELK 由 ElasticSearch、Logstash 和 Kibana 这三个开源工具组成。</p><h1 id="ELK组成"><a href="#ELK组成" class="headerlink" title="ELK组成"></a>ELK组成</h1><p>Elasticsearch、Logstash 和 Kibana 三个开源工具配合使</p><ul><li>filebeat：部署在需要采集日志的各个服务器上，负责监听log文件，Filebeat会将日志数据收集并结构化后传输到Logstash上；</li><li>Logstash：负责将日志进行过滤、收集，再传输到Elasticsearch上；</li><li>Elasticsearch：负责把日志作为索引进行存储并且构造对应倒排索引；</li><li>Kibana：负责可视化呈现日志，需要查询时Kibana调用Elasticsearch进行日志数据的查询；</li></ul><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152053343.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Quick-Start——监听nginx日志"><a href="#Quick-Start——监听nginx日志" class="headerlink" title="Quick Start——监听nginx日志"></a>Quick Start——监听nginx日志</h1><h2 id="安装filebeat"><a href="#安装filebeat" class="headerlink" title="安装filebeat"></a>安装filebeat</h2><p><code>tar -zxvf filebeat-7.7.0-linux-x86_64.tar.gz</code></p><h2 id="监听nginx的accss-log并输出到es"><a href="#监听nginx的accss-log并输出到es" class="headerlink" title="监听nginx的accss.log并输出到es"></a>监听nginx的accss.log并输出到es</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/local/nginx/logs/*.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["nginx"]</span></span><br><span class="line"><span class="attr">steup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["114.116.32.159:9200"]</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="kinaba展示日志并制作柱状图"><a href="#kinaba展示日志并制作柱状图" class="headerlink" title="kinaba展示日志并制作柱状图"></a>kinaba展示日志并制作柱状图</h1><h2 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h2><p>略</p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>Visualize选择柱状图并选择filebeat输出的nginx索引</p><p>Y轴位数量   X轴以时间为单位</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152056092.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="Metricbeat监听状态"><a href="#Metricbeat监听状态" class="headerlink" title="Metricbeat监听状态"></a>Metricbeat监听状态</h1><h2 id="nginx安装状态模块"><a href="#nginx安装状态模块" class="headerlink" title="nginx安装状态模块"></a>nginx安装状态模块</h2><h1 id="收集自定义服务的日志"><a href="#收集自定义服务的日志" class="headerlink" title="收集自定义服务的日志"></a>收集自定义服务的日志</h1><h2 id="Java服务"><a href="#Java服务" class="headerlink" title="Java服务"></a>Java服务</h2><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">3</span>){</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat slf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        String format = slf.format(date);</span><br><span class="line">        log.info(<span class="string">"hello info,{}"</span>,format);</span><br><span class="line">        log.debug(<span class="string">"hello debug,{}"</span>,format);</span><br><span class="line">        log.error(<span class="string">"hello error,{}"</span>,format);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"log hello"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">xmlns</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://ch.qos.logback/xml/ns/logback</span></span></span><br><span class="line"><span class="tag"><span class="string">               https://raw.githubusercontent.com/enricopulatzo/logback-XSD/master/src/main/xsd/logback.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"/Users/bytedance/IdeaProjects/bytestudy/ELK/log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"clr"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wex"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wEx"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">"%d{yyyy-MM-dd HH:mm:ss.SSS} | [%thread] | %-5level | %logger{50} | [%method,%line] | %msg%n"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/info-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是INFO级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/error-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是ERROR级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"sqlAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    文件路径    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.path}/infoSql.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义滚动策略。   基于时间的滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式  带有.gz 会自动压缩--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.path}/infoSql-%d{yyyy-MM-dd}.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果是ERROR级别，直接记录  匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果不是，拒绝   不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis log configure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.apache.ibatis"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Connection"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Statement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.PreparedStatement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--系统操作日志--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;root level="INFO"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;/root&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置自己写的代码的日志记录器    对应包里面的日志才会被记录  additivity表示我们自定义的日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.raptor"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.raptor.system.mapper"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"sqlAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h2><h3 id="监听Java服务的日志并输出到logstach"><a href="#监听Java服务的日志并输出到logstach" class="headerlink" title="监听Java服务的日志并输出到logstach"></a>监听Java服务的日志并输出到logstach</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/Users/bytedance/IdeaProjects/bytestudy/ELK/log/error.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["elkdemo"]</span></span><br><span class="line"><span class="attr">steup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="comment">#output.elasticsearch:</span></span><br><span class="line"><span class="comment">#  hosts: ["114.116.32.159:9200"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["127.0.0.1:5044"]</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="Logstach"><a href="#Logstach" class="headerlink" title="Logstach"></a>Logstach</h2><h3 id="简单测试控制台输出"><a href="#简单测试控制台输出" class="headerlink" title="简单测试控制台输出"></a>简单测试控制台输出</h3><p><code>./logstash -e "input {stdin {}} output {stdout{}}"</code></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152058000.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>监听5044 接收filebeat的输入 并输出 到控制台</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152058020.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input {</span><br><span class="line">  beats {</span><br><span class="line">    port =&gt; "5044"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output{</span><br><span class="line">        stdout{codec =&gt; rubydebug}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#output {</span><br><span class="line">#  elasticsearch {</span><br><span class="line">#    hosts =&gt; ["http://192.168.42.111:9200"]</span><br><span class="line">#    index =&gt; "mylogstash1"</span><br><span class="line">#    #user =&gt; "elastic"</span><br><span class="line">#    #password =&gt; "changeme"</span><br><span class="line">#  }</span><br><span class="line">#}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="输出到es"><a href="#输出到es" class="headerlink" title="输出到es"></a>输出到es</h2><h3 id="添加split效果"><a href="#添加split效果" class="headerlink" title="添加split效果"></a>添加split效果</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">         "input" =&gt; {</span><br><span class="line">        "type" =&gt; "log"</span><br><span class="line">    },</span><br><span class="line">           "ecs" =&gt; {</span><br><span class="line">        "version" =&gt; "1.10.0"</span><br><span class="line">    },</span><br><span class="line">          "tags" =&gt; [</span><br><span class="line">        [0] "elkdemo",</span><br><span class="line">        [<span class="number">1</span>] <span class="string">"beats_input_codec_plain_applied"</span></span><br><span class="line">    ],</span><br><span class="line">       "message" =&gt; [</span><br><span class="line">        [0] "2022-07-27 22:45:20.653 ",</span><br><span class="line">        [1] " [http-nio-8080-exec-1] ",</span><br><span class="line">        [2] " ERROR ",</span><br><span class="line">        [3] " com.raptor.elk.controller.LogController ",</span><br><span class="line">        [4] " [hello,28] ",</span><br><span class="line">        [<span class="number">5</span>] <span class="string">" hello error,22-7-27 下午10:45"</span></span><br><span class="line">    ],</span><br><span class="line">          "host" =&gt; {</span><br><span class="line">        "name" =&gt; "C02G94S8ML7H"</span><br><span class="line">    },</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">    "@timestamp" =&gt; 2022-07-27T14:45:24.480Z,</span><br><span class="line">         "agent" =&gt; {</span><br><span class="line">                "name" =&gt; "C02G94S8ML7H",</span><br><span class="line">                  "id" =&gt; "94db4c0d-006c-4e8a-999c-35e57c97099f",</span><br><span class="line">                "type" =&gt; "filebeat",</span><br><span class="line">             "version" =&gt; "7.14.0",</span><br><span class="line">        "ephemeral_id" =&gt; "bc8ce9a9-62c1-43f4-9826-e2f17a51cbe4",</span><br><span class="line">            "hostname" =&gt; "C02G94S8ML7H"</span><br><span class="line">    },</span><br><span class="line">           "log" =&gt; {</span><br><span class="line">          "file" =&gt; {</span><br><span class="line">            "path" =&gt; "/Users/bytedance/IdeaProjects/bytestudy/ELK/log/error.log"</span><br><span class="line">        },</span><br><span class="line">        "offset" =&gt; 1543</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="conf"><a href="#conf" class="headerlink" title=".conf"></a>.conf</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">input {</span><br><span class="line">  beats {</span><br><span class="line">    port =&gt; "5044"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">filter {</span><br><span class="line">    mutate{</span><br><span class="line">        split =&gt; {"message"=&gt;"|"}</span><br><span class="line">        }</span><br><span class="line">    mutate{</span><br><span class="line">        add_field =&gt; {</span><br><span class="line">                "controllerName" =&gt; "%{[message][3]}"</span><br><span class="line">                "errorMessage" =&gt; "%{[message][5]}"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    mutate{</span><br><span class="line">        convert =&gt; {</span><br><span class="line">                "controllerName" =&gt; "string"</span><br><span class="line">                "errorMessage" =&gt; "string"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output{</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        stdout{codec =&gt; rubydebug}</span></span><br><span class="line"><span class="meta">#</span><span class="bash">}</span></span><br><span class="line"></span><br><span class="line">output {</span><br><span class="line">  elasticsearch {</span><br><span class="line">    hosts =&gt; ["http://114.116.32.159:9200"]</span><br><span class="line">    index =&gt; "elkdemo"</span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="comment">#user =&gt; "elastic"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="comment">#password =&gt; "changeme"</span></span></span><br><span class="line">         }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="kibana制作表盘"><a href="#kibana制作表盘" class="headerlink" title="kibana制作表盘"></a>kibana制作表盘</h2><h3 id="访问量柱形图"><a href="#访问量柱形图" class="headerlink" title="访问量柱形图"></a>访问量柱形图</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100032.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100071.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="表格展示"><a href="#表格展示" class="headerlink" title="表格展示"></a>表格展示</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152100090.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h3 id="制作一个简单的表盘"><a href="#制作一个简单的表盘" class="headerlink" title="制作一个简单的表盘"></a>制作一个简单的表盘</h3><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152104124.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>同时监控多套环境、多个项目的日志：由于我们的测试环境和开发环境内网在同一个网段下，因此我基于多个（dev+test）环境创建了多个项目的索引，以dev、test开头作为索引的名称，以此区分环境类型，在索引列表中可手动切换索引查看对应项目的日志，无需像往常一样登录多台服务器、打开多个窗口；</li><li>不占用服务器资源：Elasticsearch、Logstash、Kibana分别部署在多台服务器上，Filebeat仅部署在需要采集日志的服务器上，它们彼此通过内外相互联通，因此并不会集中占用内存、CPU等资源；</li><li>外网访问，通过浏览器即可随时随地访问，无需任何工具：另由于Kibana所在的服务器可以通过外网IP访问，因此，即使回到家中，也能通过浏览器实时访问到各个环境下各个项目的日志信息；<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li>搭建过程较为繁琐：Elasticsearch、Logstash、Kibana、Filebeat等多个服务需要分别部署，在此过程中可能遇到各种问题；</li><li>日志访问有延时：由于日志的收集、过滤、解析需要一定的时间，因此，当发起请求后，并不能像命令行或浏览器的F12工具一样，在ELK实时看到响应日志信息，会带有5-10s左右的延时；</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal原理</title>
    <link href="http://raptor1998.top/2022/07/20/ByteStudy%20canal%E5%8E%9F%E7%90%86/"/>
    <id>http://raptor1998.top/2022/07/20/ByteStudy%20canal%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-08-23T12:41:14.688Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Canal工作原理"><a href="#Canal工作原理" class="headerlink" title="Canal工作原理"></a>Canal工作原理</h1><p>Canal是模拟Mysql主从复制原理。将自己伪装成Slave。向主库发起dump协议，拿到bin_log日志，解析之后对数据做相关操作</p><h1 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h1><h2 id="为什么要主从"><a href="#为什么要主从" class="headerlink" title="为什么要主从"></a>为什么要主从</h2><ol><li>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li>做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。</li><li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li>数据分布 (Data distribution )</li><li>负载平衡(load balancing)</li><li>数据备份(Backups) ，保证数据安全</li><li>高可用性和容错性(High availability and failover)</li><li>实现读写分离，缓解数据库压力</li></ul><p>注意：由于 mysql 实现的异步复制，所以主库和从库数据之间存在一定的差异，在从库执行查询操作需要考虑这些数据的差异，一般只有更新不频繁和对实时性要求不高的数据可以通过从库查询，实行要求高的仍要从主库查询。</p><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ol><li>读写分离<br>在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换(主从切换)<br>提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据；</li><li>高可用（HA）<br>1）因为数据库服务器中的数据都是相同的，当Master挂掉后，可以指定一台Slave充当Master继续保证服务的运行，因为数据是一致性的（如果当插入时Master就挂掉，可能不一致，因为同步也需要时间）当然这种配置不是简单的把一台Slave充当Master，毕竟还要考虑后续的Slave的数据同步到Master<br>2）在主服务器上执行写入和更新，在从服务器上向外提供读功能，达到读写分离的效果，也可以动态地调整从服务器的数量，从而调整整个数据库的性能。<br>3）在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li><li>架构扩展<br>随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h2 id="复制的基本过程"><a href="#复制的基本过程" class="headerlink" title="复制的基本过程"></a>复制的基本过程</h2><ol><li>在从节点上执行sart slave命令开启主从复制开关，开始进行主从复制。从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li><li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）；</li><li>从节点的I/O进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的relay-log（中继日志）的文件（Mysql-relay-bin.xxx）的最末端，并将读取到的binary log（bin-log）文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li><li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在主节点上实际执行过SQL语句，然后在本数据库中按照解析出来的顺序执行，并在relay-log.info中记录当前应用中继日志的文件名和位置点。</li></ol><h1 id="Canal会不会丢失数据"><a href="#Canal会不会丢失数据" class="headerlink" title="Canal会不会丢失数据"></a>Canal会不会丢失数据</h1><ol><li>ZK的数据可靠性或者安全性被破坏，比如ZK数据丢失，ZK的数据被人为串改，特别是有关Position的值。</li><li>MySQL binlog非正常运维，比如binglog迁移、重命名、丢失等。</li><li>切换MySQL源，比如原来基于M1实例，后来M1因为某种原因失效，那么Canal将数据源切换为M2，而且M1和M2可能binlog数据存在不一致（非常有可能）。</li><li>Consumer端ACK的时机不佳，比如调用get()方法，而不是getWithoutAck()，那么消息有可能尚未完全消费，就已经ACK，那么此时由异常或者Consumer实例失效，则可能导致消息丢失。我们需要在ACK时机上保障“at lease once”。</li></ol><h1 id="Canal会导致消息重复吗"><a href="#Canal会导致消息重复吗" class="headerlink" title="Canal会导致消息重复吗"></a>Canal会导致消息重复吗</h1><ol><li>Canal 实例初始化时，根据“消费者的Cursor”来确定binlog的起始位置，但是Cursor在ZK中的保存是滞后的（间歇性刷新），所以Canal 实例获得的起始位置一定不会大于消费者真实已见的位置。</li><li>客户端，因为某种原因的rollback，也可能导致一个batch内的所有消息重发，此时可能导致重复消费。</li></ol><p>我们建议，Consumer端需要保持幂等，对于重复数据可以进行校验或者replace。对于非幂等操作，比如累加、计费，需要慎重。</p><h1 id="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"><a href="#Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？" class="headerlink" title="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"></a>Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？</h1><p>比如有两个客户端集群，C1/C2，你希望C1和C2中的消费者都能够订阅到相同的消息，就像Kafka或者JMS Topic一样…但是非常遗憾，似乎Canal无法做到，这取决于Canal内部的存储模式，Canal内部是一个“即发即失”的内存队列，无法权衡、追溯不同客户端之间的消息，所以无法支持。</p><p>如果希望达到这种结果，有2个办法：第一，消费者收到消息以后转发到kafka或者MQ中，后继的其他客户端只与kafka或者MQ接入；第二：一个Canal中使用多个目的地，但是它们对应相同的MySQL源。</p><h1 id="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？-1"><a href="#Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？-1" class="headerlink" title="Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？"></a>Canal数据的集散问题，一个目的地的消息能否被多个客户端集群并行消费？</h1><p>比如有两个客户端集群，C1/C2，你希望C1和C2中的消费者都能够订阅到相同的消息，就像Kafka或者JMS Topic一样…但是非常遗憾，似乎Canal无法做到，这取决于Canal内部的存储模式，Canal内部是一个“即发即失”的内存队列，无法权衡、追溯不同客户端之间的消息，所以无法支持。</p><p>如果希望达到这种结果，有2个办法：第一，消费者收到消息以后转发到kafka或者MQ中，后继的其他客户端只与kafka或者MQ接入；第二：一个Canal中使用多个目的地，但是它们对应相同的MySQL源。</p><h1 id="Canal性能如何？"><a href="#Canal性能如何？" class="headerlink" title="Canal性能如何？"></a>Canal性能如何？</h1><p>Canal本身非常轻量级，主要性能开支就是在binlog解析，其转发、存储、提供消费者服务等都很简单。它本身不负责数据存储。原则上，canal解析效率几乎没有负载，canal的本身的延迟，取决于其与slave之间的网络IO。<br>如果Canal更换上游的主库或者从库，该怎么办？（比如迁库、迁表等）<br>背景要求，我们建议“新的数据库最好是旧的数据库的slave”或者“新、旧数据库为同源master”，平滑迁移；</p><pre><code>1）创建一个新的实例，使用新的目的地，并与新的Slave创建连接。2）在此期间，Consumer仍然与旧的目的地消费。3）通过“timestamp”确认，新的slave的最近binlog至少已经超过此值。4）Consumer切换，使用新的目的地消费，可能会消费到重复数据，但是不会导致数据丢失。</code></pre><p>当然，更简单的办法就是直接将原目的地中的数据库地址跟新即可，前提是新、旧两个数据库同源master，新库最好已经同步执行了一段时间。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/K_520_W/article/details/117135287" target="_blank" rel="noopener">mysql主从复制原理_爱上口袋的天空的博客-CSDN博客_mysql主从复制的原理</a><br><a href="https://blog.csdn.net/qq_36971119/article/details/122856561" target="_blank" rel="noopener">Canal原理及其使用_②⑦丶的博客-CSDN博客_canal</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal adaptor同步es</title>
    <link href="http://raptor1998.top/2022/07/18/ByteStudy-canal%E5%90%8C%E6%AD%A5es/"/>
    <id>http://raptor1998.top/2022/07/18/ByteStudy-canal%E5%90%8C%E6%AD%A5es/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-08-15T12:31:28.377Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="canal-工作原理"><a href="#canal-工作原理" class="headerlink" title="canal 工作原理"></a>canal 工作原理</h1><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul><h1 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h1><p>90%的问题都能在issues找到</p><p><a href="https://github.com/alibaba/canal/issues" target="_blank" rel="noopener">https://github.com/alibaba/canal/issues</a></p><h1 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">srcDataSources:</span></span><br><span class="line">    <span class="attr">defaultDS:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/canal?useUnicode=true&amp;useSSL=false</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">canalAdapters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">instance:</span> <span class="string">example</span> <span class="comment"># canal instance Name or mq topic name</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line">      <span class="attr">outerAdapters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">es7</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">exampleKey</span></span><br><span class="line">        <span class="attr">hosts:</span> <span class="number">114.116</span><span class="number">.32</span><span class="number">.159</span><span class="string">:9200</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">rest</span> <span class="comment"># or rest</span></span><br><span class="line">          <span class="comment"># security.auth: test:123456 #  only used for rest mode</span></span><br><span class="line">          <span class="attr">cluster.name:</span> <span class="string">elasticssearch</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="配置conf-es7-xxx-yml"><a href="#配置conf-es7-xxx-yml" class="headerlink" title="配置conf/es7/xxx.yml"></a>配置conf/es7/xxx.yml</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataSourceKey:</span> <span class="string">defaultDS</span> <span class="comment">#和上面canal.conf.srcDataSources.defaultDS要一样</span></span><br><span class="line"><span class="attr">outerAdapterKey:</span> <span class="string">exampleKey</span> <span class="comment">#和上面canal.conf.canalAdapters.instance.groups.outerAdapters.key要一样</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">example</span> <span class="comment">#和上面canal.conf.canalAdapters.instance要一样</span></span><br><span class="line"><span class="attr">groupId:</span> <span class="string">g1</span> <span class="comment">#和上面canal.conf.canalAdapters.instance.groups.groupId要一样</span></span><br><span class="line"><span class="attr">esMapping:</span></span><br><span class="line">  <span class="attr">_index:</span> <span class="string">test</span> <span class="comment">#索引名称</span></span><br><span class="line">  <span class="attr">_id:</span> <span class="string">_id</span> <span class="comment">#documentid</span></span><br><span class="line">  <span class="attr">_type:</span> <span class="string">_doc</span> <span class="comment"># type</span></span><br><span class="line"><span class="comment">#  upsert: true</span></span><br><span class="line"><span class="comment">#  pk: id</span></span><br><span class="line">  <span class="attr">sql:</span> <span class="string">"select a.id as _id, a.name_cn, a.name_en, a.email</span></span><br><span class="line"><span class="string">        from user a"</span>  <span class="comment"># 查询的sql返回的结构要使用as别名和es的filed对应</span></span><br><span class="line"><span class="comment">#  objFields:</span></span><br><span class="line"><span class="comment">#    _labels: array:;</span></span><br><span class="line">  <span class="attr">commitBatch:</span> <span class="number">3000</span> <span class="comment">#批量提交数量</span></span><br></pre></td></tr></tbody></table></figure></div><h1 id="es创建索引"><a href="#es创建索引" class="headerlink" title="es创建索引"></a>es创建索引</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT http://114.116.32.159:9200/test</span><br><span class="line">{</span><br><span class="line">    <span class="attr">"settings"</span>: {</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span>: <span class="number">2</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"mappings"</span>: {</span><br><span class="line">        <span class="attr">"properties"</span>: {</span><br><span class="line">            <span class="attr">"name_cn"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"name_en"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"email"</span>: {</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h1><p><code>curl http://localhost:8081/etl/es7/exampleKey/mytest_user.yml -X POST</code></p><p>params即 p.id&gt;{}的参数<br><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152029118.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h1 id="究极踩坑指南"><a href="#究极踩坑指南" class="headerlink" title="究极踩坑指南"></a>究极踩坑指南</h1><blockquote><p>mysql链接异常：Host is blocked because of many connection errors</p></blockquote><p><a href="https://blog.csdn.net/weixin_50180533/article/details/125254466" target="_blank" rel="noopener">MySQL 报错ERROR 1129 Host is blocked because of many connection errors。_皱皱小菜鸡的博客-CSDN博客</a></p><blockquote><p>Es failed driuid异常</p></blockquote><p><a href="https://github.com/alibaba/canal/issues/3466#issuecomment-825494336" target="_blank" rel="noopener">github.com</a></p><p>大多数并不适用，更换alpha2的es7依赖是亲测有效</p><blockquote><p>全量更新Task not found </p></blockquote><p>url格式为<a href="http://localhost:8081/etl/es7/exampleKey/mytest_user.yml" target="_blank" rel="noopener">http://localhost:8081/etl/es7/exampleKey/mytest_user.yml</a></p><p>application.yml 的 key: exampleKey   和   xxxyml的 key对应</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/Day_Day_No_Bug/article/details/116748553?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-116748553-blog-120271777.pc_relevant_sortByStrongTime&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-116748553-blog-120271777.pc_relevant_sortByStrongTime&amp;utm_relevant_index=5" target="_blank" rel="noopener">CanalAdapter同步ES7(全量&amp; 增量)_如果悲伤有颜色，那么一定是黄昏的博客-CSDN博客_canal 首次全量同步</a></p><p><a href="https://blog.csdn.net/qq_32419139/article/details/125232695" target="_blank" rel="noopener">2022-06-10 通过canal将mysql数据同步到es中_寂寞旅行的博客-CSDN博客</a></p><p><a href="https://github.com/alibaba/canal/issues/3714" target="_blank" rel="noopener">全量同步任务提示找不到任务 · Issue #3714 · alibaba/canal</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy canal监听</title>
    <link href="http://raptor1998.top/2022/07/16/ByteStudy-canal%E7%9B%91%E5%90%AC/"/>
    <id>http://raptor1998.top/2022/07/16/ByteStudy-canal%E7%9B%91%E5%90%AC/</id>
    <published>2022-07-15T16:00:00.000Z</published>
    <updated>2022-08-15T12:31:34.976Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p> Canal 是用 Java 开发的基于数据库增量日志解析，提供增量数据订阅&amp;消费的中间件。目前。Canal 主要支持了 MySQL 的 Binlog 解析，解析完成后才利用 Canal Client 来处理获得的相关数据。</p><h1 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h1><p>它记录了所有的 DDL 和 DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。<br>见末尾</p><h1 id="canal安装配置"><a href="#canal安装配置" class="headerlink" title="canal安装配置"></a>canal安装配置</h1><h2 id="canal-properties"><a href="#canal-properties" class="headerlink" title="canal.properties"></a>canal.properties</h2><p>canal.destinations = example</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014912.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>example/instance.properties</p><p>伪装从节点</p><p><strong>canal.instance.mysql.slaveId=20</strong></p><p>mysql服务地址</p><p><strong>canal.instance.master.address=127.0.0.1:3306</strong></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014888.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>伪装成 Slave</p><h3 id="mysql的主从复制"><a href="#mysql的主从复制" class="headerlink" title="mysql的主从复制"></a>mysql的主从复制</h3><ol><li>Master 主库将改变记录，写到二进制日志(BinLog)中;</li><li>Slave 从库向 MySQL Master 发送 dump 协议，将 Master 主库的 binary log events 拷贝<br>到它的中继日志(relay log);</li><li>Slave 从库读取并重做中继日志中的事件，将改变的数据同步到自己的数据库。</li></ol><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启binlog，并设置为ROW格式</span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">开启binlog日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog-format=Row</span><br></pre></td></tr></tbody></table></figure></div><p>查看模式<code>show variables like 'binlog_format'</code></p><p>给canal添加一个读角色</p><p><code>GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%' IDENTIFIED BY 'canal' ;</code></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>{</span><br><span class="line">    <span class="comment">//1.获取 canal 连接对象</span></span><br><span class="line">    CanalConnector canalConnector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">"114.116.32.159"</span>, <span class="number">11111</span>), <span class="string">"example"</span>, <span class="string">"canal"</span>, <span class="string">"canal"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        canalConnector.connect();</span><br><span class="line">        <span class="comment">// 3.指定要监控的数据库</span></span><br><span class="line">        <span class="comment">// 配指定数据库只监听到了事务结束开始，所以直接配置全部</span></span><br><span class="line">        canalConnector.subscribe(<span class="string">".*\\..*"</span>);</span><br><span class="line">        <span class="comment">//4.获取 Message</span></span><br><span class="line">        Message message = canalConnector.get(<span class="number">100</span>);</span><br><span class="line">        List&lt;CanalEntry.Entry&gt; entries = message.getEntries();</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &lt;= <span class="number">0</span>) {</span><br><span class="line">            System.out.println(<span class="string">"没有数据"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.Entry entry : entries) {</span><br><span class="line">                <span class="comment">//获取表名</span></span><br><span class="line">                String tableName = entry.getHeader().getTableName();</span><br><span class="line">                <span class="comment">//Entry 类型</span></span><br><span class="line">                CanalEntry.EntryType entryType = entry.getEntryType();</span><br><span class="line">                <span class="comment">//判断 entryType 是否为 ROWDATA</span></span><br><span class="line">                <span class="keyword">if</span> (CanalEntry.EntryType.ROWDATA.equals(entryType)) {</span><br><span class="line">                    <span class="comment">//序列化数据</span></span><br><span class="line">                    ByteString storeValue = entry.getStoreValue();</span><br><span class="line">                    <span class="comment">//反序列化</span></span><br><span class="line">                    CanalEntry.RowChange rowChange = CanalEntry.RowChange.parseFrom(storeValue);</span><br><span class="line">                    <span class="comment">//获取事件类型</span></span><br><span class="line">                    CanalEntry.EventType eventType = rowChange.getEventType();</span><br><span class="line">                    <span class="comment">//获取具体的数据</span></span><br><span class="line">                    List&lt;CanalEntry.RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">                    <span class="comment">//遍历并打印数据</span></span><br><span class="line">                    <span class="keyword">for</span> (CanalEntry.RowData rowData : rowDatasList) {</span><br><span class="line">                        JSONObject beforeData = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                        List&lt;CanalEntry.Column&gt; beforeColumnsList = rowData.getBeforeColumnsList();</span><br><span class="line">                        <span class="keyword">for</span> (CanalEntry.Column column : beforeColumnsList) {</span><br><span class="line">                            beforeData.put(column.getName(), column.getValue());</span><br><span class="line">                        }</span><br><span class="line">                        JSONObject afterData = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                        List&lt;CanalEntry.Column&gt; afterColumnsList = rowData.getAfterColumnsList();</span><br><span class="line">                        <span class="keyword">for</span> (CanalEntry.Column column : afterColumnsList) {</span><br><span class="line">                            afterData.put(column.getName(), column.getValue());</span><br><span class="line">                        }</span><br><span class="line">                        System.out.println(<span class="string">"TableName:"</span> + tableName + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"EventType:"</span> + eventType + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"before:"</span> + beforeData + <span class="string">"\n"</span> +</span><br><span class="line">                                <span class="string">"After:"</span> + afterData);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    System.out.println(<span class="string">"操作类型为："</span> + entryType);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> course <span class="keyword">SET</span> course_name = <span class="string">"增量多个更新"</span>,chapter_num=<span class="number">3</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208152014928.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="监测不到ROWDATA类型"><a href="#监测不到ROWDATA类型" class="headerlink" title="监测不到ROWDATA类型"></a>监测不到ROWDATA类型</h2><p>修改instance.properties的正则</p><p><code>canal.instance.filter.black.regex=.*\\..*</code></p><p>客户端设置</p><p><code>CanalConnector.subscribe(".*\\..*")</code></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.kancloud.cn/wenshunbiao/wenshunbiao/1403850" target="_blank" rel="noopener">mysql查看binlog日志 · 小温笔记 · 看云</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">MySQL三大日志(binlog、redo log和undo log)详解</a></p><p><a href="https://www.csdn.net/tags/NtzacgysMDkyMjctYmxvZwO0O0OO0O0O.html" target="_blank" rel="noopener">canal.instance.filter.black.regex - CSDN</a></p><p><a href="https://blog.csdn.net/Watermelon1986/article/details/121536631" target="_blank" rel="noopener">Canal部署运行问题记录_Watermel0n丶的博客-CSDN博客_canal启动很慢</a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Month 1</title>
    <link href="http://raptor1998.top/2022/07/10/ByteDance4/"/>
    <id>http://raptor1998.top/2022/07/10/ByteDance4/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:55.729Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h2><hr><p>呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p><hr><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142218372.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a><br>我的状态完全和樱木刚开始接触篮球一样，啥也不会，自己还挺有想法</p><blockquote><p>如何评价“樱木花道”这个人物？</p></blockquote><blockquote><p>樱木花道从一个自负、无知、单纯而且有点爱惹祸的小年轻，后来因为他心目中的女生晴子小姐而彻底改变了自己，成为一个刻苦上进，最终当上篮球手而且努力使自己做到了“灌篮高手”的境界。</p></blockquote><p>实习到目前已经一个月出头，前面两周都在看文档，熟悉业务，参与回归测试，其实对于自身技术上的成长可以说是几乎没有，只能靠自己探索内部基础工具的实现原理学习技术，毕竟业务这东西，对于目前的工作意义非凡，但对于个人成长来说，更多的还是业务背后的技术沉淀</p><p>第一次独立处理需求，PM是新加坡人，万幸的是她讲中文，还不算难理解，对于测试用例的编写还算有点新的理解，第一次写，更多的还是站在开发的角度去考虑事情，去扣一些极端操作，反而忽略了用户操作，对于功能测试来讲，更多的还是偏重于用户角度，这时其实就在思考测试岗位存在的意义了，毕竟之前在校内开发，写完代码，自测没问题就直接上了，并没有专门的同学把关</p><p>目前收获最大的的是学习需求上线流程，敏捷迭代的各时间点工作</p><h2 id="换线"><a href="#换线" class="headerlink" title="换线"></a>换线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142211306.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>本来高高兴兴，ld拉了一个群，群里只有ld、我、mentor和未来的新mentor，就说了一句话，长期支持一下非中机器人的方向，当我看到这个消息和上图表情一模一样，难顶。。。</p><p>SMB的业务还没完全理解，刚处理了两个需求，还都没有完全上线，一个外部依赖，另一个历史逻辑太多，理解的有点慢，现在又要去接触一个新的业务，我这短短几个月的实习里，若是按照目前的强度来看，我这实习期间可能并不会接触多过多的东西</p><h2 id="新业务线"><a href="#新业务线" class="headerlink" title="新业务线"></a>新业务线</h2><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142216915.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>SMB一共处理了两个需求，还有一个因为外部依赖没能上线，现在新业务线是基础服务，业务好理解，就是智能问答，多轮对话，提供工具，为客增赋能，让销售们更好的、更快的解决问题，类似于辅助型对话机器人</p><h3 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h3><p>问答：通过机器人发起提问，权限以及其他的一些校验通过后，将信息打包给KE，KE进行意图分析（KE可以理解为卧龙为KE提供了训练模型的数据，读书期间研究方向有部分nlp相关，目前在做的主要是自动构建领域KG），KE将分析的数据返回飞书卡片，测试根据会话人的部分、角色等判定是否返回某些FAQ的答案，然后根据用户的交互行为卧龙返回对应数据</p><p>人工：会话服务将从KE获取的用户意图以及用户部门等信息，发送给卧龙后台，卧龙后台查找符合条件的值班客服信息并返回给会话服务</p><p> 多轮对话：目前还没涉及，应该很有意思，根据之前的理解，对于NLP相关的，随着trans(E\H……)系列问世，再加上各类变形，bert等，有简单了解过基于知识图谱的KBQA</p><h3 id="新小组"><a href="#新小组" class="headerlink" title="新小组"></a>新小组</h3><p>随着业务线的更换，mentor也换了，看来是不用回去了，同时过来的还有之前租的rd同学，但是他支持一个月还要回去的。。。</p><p>换座位，周五开完最后一个smb的迭代总结会议，晚上就换座位了，都不认识，基本有问题就问新mentor和之前组的xiayan，最难受的是啥，就是我刚换完座位，立刻就有人坐在了我原来的位置，其实本来应该他过来这边，但是好像因为需求紧急，我来了有一点时间，已经熟悉的差不多了，换组的成本不大，就让我来了，那我只能一遍呜呜呜，哒哒哒。。。呜呜呜，哒哒哒。。。</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Week 4</title>
    <link href="http://raptor1998.top/2022/06/28/ByteDance2/"/>
    <id>http://raptor1998.top/2022/06/28/ByteDance2/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:44.861Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="入职第四周"><a href="#入职第四周" class="headerlink" title="入职第四周"></a>入职第四周</h1><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p> <a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142146986.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142128353.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>怎么说呢，除了有点卷，没什么个人时间，工作内容不符合我的预期，餐厅吃够了，天天当混子之外，其他的都还可以</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142148721.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142149703.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="业务线"><a href="#业务线" class="headerlink" title="业务线"></a>业务线</h2><p>万万没想到，目前最大的阻碍竟然是英语，面试的时候可没提过这个事，所在的团队是 Non-China 线，小组是 SMB，小微企业的跟进，PM 多是外国人，每日站会他们参与就要用英文，包括新的需求 PRD 以及迭代会议的总结，看我 mentor 之前说的英文不是事，再看看她在站会和迭代上讲的熟练程度，说她英语专业毕业我都信……</p><p>每天九点半左右去吃早餐，准备一下开始新一天的工作，十点半开每日站会，前面几天，每天都用同样的句式，</p><ul><li>Today I will continue to learn basic components and understand general business operations</li><li>Today I will continue to learn basic components and learn agile software development</li><li>learn develop and test process specification</li><li>Today I will write test case for pitch planner and understand interface logic</li><li>learn how to test</li><li>Contact other needs and sort out relevant businesses</li><li>“Living to death” related documents, and alarm learning</li></ul><p>“熟悉文档，学习说啥啥啥”，下迭代我要参与到站会的主持中去，难顶，这个迭代要记录 todo，后续还要参与到火车轮班，虽然现在还知道是啥，盲猜就是服务发布相关的东西</p><p>刚上没几天班，我旁边带我熟悉的军哥晋升奶爸，直接休假都七月多，（写到这赶紧停下来，去买个小礼物，过几天回来恭喜一下）此时就又换了一位组内成员夏嫣带我熟悉业务，前面一周多是以熟悉文档为主，包括几种平台的使用，非常枯燥，实际上的使用还得是在实践中了解，纸上谈兵的看意义不大，甚至没有真正理解；第二三周开始接触业务，跟着夏嫣、凤琳做一些回归测试，熟悉业务为主，目前针对业务的理解，实际上简单概括可以分为几个大角色，广告主、销售，因为是变现中台，按业务模块，简单概括用户管理，线索发现，商机管理，业务跟进，数据分析。目前在接触最多的业务属于定时任务的一块，将一些某些条件的广告主筛选出来，推进某些流程中，由业务进行跟进，可能没有 C 端产品好理解，但都是基于 C 端产品的，Tik Tok 等<br>截止到目前，处理了两个需求，都是和新加坡的 winter 对接的，pitch planner 相关的（这块原本是要我接受的，但是军哥陪产假，没人带着熟悉，所以后续嗯可能接手夏嫣 program 那块），后端改动不大的那种，多是一些前端的改造，通过 Charles 做一些断点即可</p><p>团队内的自动化测试工具，ate，基于 pytest 写的， 在 win 下安装出现了很多独占问题，为了避免后续我本地 win 可以运行，其他人或容器无法运行，又要重新 debug，非常低效，这周申请更换了 mac pro，其实入职申请的就是 mac，只不过不给我</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135241.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然了，虽然工作内容不符合预期，吃的还是不错的，疯狂炫零食饮料，包括其他也可以看很多其他东西的，内部的一些文章，架构都是可以学习的，QA 工作一部分也是要看 RD 代码，所以还是可惜学习一下如何设计的，比如在 shopify program 这块业务线，针对 cronjob 实际上，按照我预想的设计，就只是简单的在容器中设置一个定时任务，但是在实际此处的实现，还是与我想的有差别的，通过自定义注解，将所有将要执行的任务注册进容器中，然后在启动类中实现 CommandLineRunner，每次对定时任务的调度通过任务名实现，可以避免我们单个服务一直占用资源，而且可以随时对任务进行调度，说到这，我再次期间还犯了个错，在第一次进行定时任务测试的时候，将定时任务跑到了线上环境，造成当天的定时任务跑了两次，第二天策略同学火速赶来，应为数据对不上，还好没造成太大影响，不然直接因 P0 事故被开除。此次之后，我就小心了，每次操作前都反复跟组内的人确认，讲真，当时完全是认为工作枯燥，干完收工的一个心态</p><p>在实习期间，还要处理之前学校的项目，进入二期，讲给师弟，完全手把手交，人都麻了，又赶上服务器前移，溜了几个查询语句号让他们上手，将近一个月，毫无进展，当然，维护过程中，还是有收获，比如在 nginx 配置 https，但是此时服务不开放 443 如何解决等问题，说实话，对于此类项目，不该找连几行点吗都没写过的来维护，毕竟真实在用的业务，不断的新需求与更改，可能给后面接手的人造成更大的麻烦</p><h2 id="发钱了"><a href="#发钱了" class="headerlink" title="发钱了"></a>发钱了</h2><p>不说了，按天结算，算不错账<br>字节不打卡，考勤完全自己报，leader 审批通过了就行，问题很大，狗头……可能是怕打卡的话员工搞事，十点上班起点正常下班，but 实际大家上到九点十点，无脑卷，资本家的糖衣炮弹让人疯狂，我直接 反卷先锋 贴在飞书</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142135561.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><h2 id="春游"><a href="#春游" class="headerlink" title="春游"></a>春游</h2><p>竟然是死去的春游，实验室竟然还没忘记春游，现在夏天都快过完了<br>啥峡谷漂流来着，机智如我，有四个小机灵鬼没去，听说有人失温了，那天感觉是最近俩月最冷的一天，十几度吧，加上下雨，收集 n 张票，开了 n 次越野，攀岩 n 次，射击 n 次，</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142145894.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142136693.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance week 3</title>
    <link href="http://raptor1998.top/2022/06/25/ByteDance5/"/>
    <id>http://raptor1998.top/2022/06/25/ByteDance5/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-08-15T12:39:01.340Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h1><p>从高空看program这块业务，实际上通过cronjob的手段将符合预定条件的广告主添加进某个流程中（Handraiser、payment ready……），并赋予一些相关的状态标签，切换拥有者，为owner添加其目前的分配数量，判断条件来源于tcc</p><p>目前理解的tcc是类似spring cloud config </p><hr><p>从代码层面看，通过定时任务，检索配置，推进流程：实现ApplicationListener&lt; ContextRefreshedEvent&gt;一般被用于在项目初始化动作完成后执行的自己业务拓展动作，作为应用初始化完毕后执行的动作（先InitializingBean）获取加Schedule注解的类，将任务注册进taskRegMap中，实现CommandLineRunner接口，容器启动之后，加载实现类的逻辑资源，已达到完成资源初始化的任务，然后准备执行任务，调用TaskInvoker 的 invoke 方法，从taskRegisterListener中获取任务实例执行：获取TCC配置，不等步长获取需要检测的adv，对获取到的实体进行条件检测，符合条件进行下一步推进</p><h1 id="小组氛围"><a href="#小组氛围" class="headerlink" title="小组氛围"></a>小组氛围</h1><p>组内一共五个人，三位女生，另一位男生休陪产假目前接触还不是很多，前面一周都是跟着junge去吃的，现在恰饭都是我一个人，妈耶，孤单。。。mentor她们喜欢吃盒饭，我觉得有点难顶，所以都是自己去食堂，偶尔她们吃餐厅才会一起。</p><p>感觉mentor怀孕有点不喜欢说话，每次碰到我也不知道说啥玩意好，可能是因为是小组长，不能跟你嬉皮笑脸的吧（狗头保命）</p><p>业务都是我旁边的xiayan在带，人美心善就是她了，感觉还没我年龄大。<br>业务上关键是我啥也不会，问的我都不好意思再问了。。。这里要吐槽一下，字节这内部平台也太多了，而且感觉全是在市面上的工具的改版，功能上可能差不多，但是用法上可能会有很大差距</p><p>这边一般九点下班（2022.8.3半夜前来更新，还没下班。。。麻了），太难了，抛出房租、生活费，希望我的实习期间能剩下个学费的钱。。。</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142254091.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><p>希望能在实习过程中，接触更多技术相关的东西，像樱木一样，从初学者到”灌篮高手“在短短几个月完成蜕变</p><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142253172.jpg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteDance Culture</title>
    <link href="http://raptor1998.top/2022/06/20/ByteDance3/"/>
    <id>http://raptor1998.top/2022/06/20/ByteDance3/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-08-15T12:38:50.362Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="始终创业"><a href="#始终创业" class="headerlink" title="始终创业"></a>始终创业</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142151560.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li><p>保持创业心态，始终开创而不守成，创新而非依赖资源</p></li><li><p>敏捷有效，最简化流程，避免简单事情复杂化</p></li><li><p>对外敏锐谦逊，避免自满或优越感</p><h1 id="多元兼容"><a href="#多元兼容" class="headerlink" title="多元兼容"></a>多元兼容</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200521.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p></li><li><p>欣赏个体多样性，聚焦人的核心特质</p></li><li><p>全球视角，理解不同文化、观点和实践</p></li><li><p>善意假设，默认开放信任，有效合作</p></li></ul><h1 id="坦诚清晰"><a href="#坦诚清晰" class="headerlink" title="坦诚清晰"></a>坦诚清晰</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142200247.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>表达真实想法，不怕暴露问题，反对”向上管理”</li><li>准确、简洁、直接，少用抽象、模糊、空泛的词</li><li>就事论事，理性沟通，避免主观臆测和情绪化表达</li></ul><h1 id="求真务实"><a href="#求真务实" class="headerlink" title="求真务实"></a>求真务实</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201517.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>独立思考，刨根问底，找到本质</li><li>直接体验，深入事实，拿一手数据或信息</li><li>不自嗨，注重实际效果</li></ul><h1 id="敢为极致"><a href="#敢为极致" class="headerlink" title="敢为极致"></a>敢为极致</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201235.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>敢于为了更好的结果明智地冒险，注重整体ROI</li><li>尝试多种可能性，在更大范围里找最优解</li><li>追求卓越，高标准，不仅做了，更要做好</li></ul><h1 id="共同成长"><a href="#共同成长" class="headerlink" title="共同成长"></a>共同成长</h1><p><a href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/byte/202208142201471.jpeg" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload" title=""></a></p><ul><li>相信并认可使命和愿景，基于使命愿景自驱</li><li>面对短期波动有耐心、有韧性，共同解决问题</li><li>持续学习，不设边界，与组织一起成长</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="随笔" scheme="http://raptor1998.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://raptor1998.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy 消息队列</title>
    <link href="http://raptor1998.top/2022/06/10/ByteStudy%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://raptor1998.top/2022/06/10/ByteStudy%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2022-06-09T16:00:00.000Z</published>
    <updated>2022-08-15T12:21:42.276Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h1><p>解耦：通过Pub/Sub发布订阅消息这么一个模型，上游关注通知，而不关注校友处理。<br>缓冲：应对突发流量，假设一个每秒处理2k请求的服务，突然涌入很多流量，为防止为打宕机，可以使用mq，服务每秒从mq拉取2K个请求，保证不超过每秒能处理的最大请求数量即可，保证服务不会挂掉。高峰可能会堆积消息，短暂的积压是可以接受的，高峰过后每秒50个请求，但是服务依然以每秒2K的速度消费<br>广播：一条消息，可以被多个下游分别处理<br>持久化：消息可以被回溯</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h1 id="消息队列常见的一些问题处理思路"><a href="#消息队列常见的一些问题处理思路" class="headerlink" title="消息队列常见的一些问题处理思路"></a>消息队列常见的一些问题处理思路</h1><h2 id="队列的高可用"><a href="#队列的高可用" class="headerlink" title="队列的高可用"></a>队列的高可用</h2><p>rabbitmq的普通集群模式下，元数据存放在一个实例上，如果连接了其他实例，name那个实例会从queue所在的实例来取数据过来。这会导致消费者每次要么随机连接一个实例，或者固定那个queeu所在的实例消费，前者有数据拉取的开销，后者单实例瓶颈。</p><p>镜像集群：</p><p>在镜像集群下，创建的queue和元数据都存在于多个实例上，就是说每个mq的节点都有这个queue的完整镜像，每次些消息到queue时，会自动同步到多实例上<br>好处在于，任何一个机器宕机，其他节点都还有queue的完整数据<br>坏事处在于，性能开销大，消息同步到所有机器上，导致网络带宽压力和消耗都很大；没有拓展性可言，如果某个queue的负载很重，增加机器，新增的机器也是包含全部的数据，没办法线性拓展queue</p><h2 id="消息幂等性问题"><a href="#消息幂等性问题" class="headerlink" title="消息幂等性问题"></a>消息幂等性问题</h2><p>其实还是得结合实际业务场景来看，比如：<br>数据落库，可以先根据主键查一下，存在走update<br>写redis，天然幂等<br>或者生产者发送消息时，每条数据都加一个全局唯一id，消费的时候去redis查一下，之前是否消费过<br>或者基于数据库的唯一约束</p><h2 id="可靠性传输问题"><a href="#可靠性传输问题" class="headerlink" title="可靠性传输问题"></a>可靠性传输问题</h2><h2 id="顺序性问题"><a href="#顺序性问题" class="headerlink" title="顺序性问题"></a>顺序性问题</h2><p>rabbitmq的错乱场景，一个queue，多个consumer消费；一个queue，一个consumer，但是消费者多线程消费</p><ol><li>拆分queue，每个queue对应一个consumer，生产者发送的时候根据关键值哈希等操作，投放到同一个queue</li><li>一个queue对应一个consumer，consumer内部做内存队列做排队，然后分发给底层的worker处理<br>消费者获取消息后，不直接去消费消息，而是将消息根据关键值哈希放入内存队列，消费者线程去内存队列消费信息</li></ol><h2 id="堆积问题"><a href="#堆积问题" class="headerlink" title="堆积问题"></a>堆积问题</h2><p>一个简单的思路</p><p>先修复consumer的问题，确保其恢复消费速度，然后停掉现有的consumer<br>新建topic，partition是原来的十倍，临时建立好原来十倍的queue数量<br>写一个临时分发数据的consumer服务，去消费积压的数据，消费之后不做任何处理，直接轮询写入临时建立的queue中<br>接着征用十倍的机器来部署consumer，每一批consumer消费一个临时queue数据。这种做法相当于是将临时queeu资源和consumer资源扩大十倍，以十倍速度来消费数据<br>等加压数据消费完之后，再恢复原来的架构<br>如何设计一个消息队列</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>ByteStudy 为什么需要一把分布式锁？</title>
    <link href="http://raptor1998.top/2022/06/08/ByteStudy%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E6%8A%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/"/>
    <id>http://raptor1998.top/2022/06/08/ByteStudy%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E6%8A%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-08-15T12:42:22.935Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="为什么我们需要一把分布式锁？"><a href="#为什么我们需要一把分布式锁？" class="headerlink" title="为什么我们需要一把分布式锁？"></a>为什么我们需要一把分布式锁？</h1><p>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email（当然这取决于业务应用的容忍度）。</p><p>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，订单重复，超卖或者其它严重的问题。</p><h1 id="分布式锁的三个属性"><a href="#分布式锁的三个属性" class="headerlink" title="分布式锁的三个属性"></a>分布式锁的三个属性</h1><h2 id="互斥（Mutual-Exclusion）"><a href="#互斥（Mutual-Exclusion）" class="headerlink" title="互斥（Mutual Exclusion）"></a>互斥（Mutual Exclusion）</h2><p>这是锁最基本的功能，同一时刻只能有一个客户端持有锁；</p><h2 id="避免死锁（Dead-lock-free）"><a href="#避免死锁（Dead-lock-free）" class="headerlink" title="避免死锁（Dead lock free）"></a>避免死锁（Dead lock free）</h2><p>如果某个客户端获得锁之后花了太长时间处理，或者客户端发生了故障，锁无法释放会导致整个处理流程无法进行下去，所以要避免死锁。最常见的是通过设置一个 TTL(Time To Live，存活时间) 来避免死锁。</p><h2 id="容错（Fault-tolerance）"><a href="#容错（Fault-tolerance）" class="headerlink" title="容错（Fault tolerance）"></a>容错（Fault tolerance）</h2><p>为避免单点故障，锁服务需要具有一定容错性。大体有两种容错方式，一种是锁服务本身是一个集群，能够自动故障切换(ZooKeeper、etcd)；另一种是客户端向多个独立的锁服务发起请求，其中某个锁服务故障时仍然可以从其他锁服务读取到锁信息(Redlock)，代价是一个客户端要获取多把锁，并且要求每台机器的时钟都是一样的，否则 TTL 会不一致，可能有的机器会提前释放锁，有的机器会太晚释放锁，导致出现问题。</p><h1 id="常见的分布式锁实现方案"><a href="#常见的分布式锁实现方案" class="headerlink" title="常见的分布式锁实现方案"></a>常见的分布式锁实现方案</h1><ul><li>redis</li><li>mysql</li><li>zookeeper</li><li>。。。<h1 id="基于redis的分布式锁"><a href="#基于redis的分布式锁" class="headerlink" title="基于redis的分布式锁"></a>基于redis的分布式锁</h1><h2 id="错误的加锁：非原子操作"><a href="#错误的加锁：非原子操作" class="headerlink" title="错误的加锁：非原子操作"></a>错误的加锁：非原子操作</h2>使用redis的分布式锁，我们首先想到的是setnx命令，</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET if Not Exists：</span><br><span class="line">   SETNX lockKey value</span><br><span class="line">   EXPIRE lockKey 30</span><br></pre></td></tr></tbody></table></figure></div><p>使用jedis的客户端代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.setnx(lockKey, val) == 1) {</span><br><span class="line">    jedis.expire(lockKey, timeout);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。<br>加锁和设置超时两个操作是分开的，并非原子操作。假设加锁成功，但是设置锁超时失败，那么该lockKey永不失效。</p><blockquote><p>问题1：为什么这个锁必须要设置一个过期时间？</p></blockquote><p>当一个客户端获取锁成功之后，假如它崩溃了，或者它忘记释放锁，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了</p><blockquote><p>问题2：这个锁的有效时间设置多长比较合适？</p></blockquote><p>前面这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。看来真是个两难的问题。</p><h2 id="正确的加锁姿势"><a href="#正确的加锁姿势" class="headerlink" title="正确的加锁姿势"></a>正确的加锁姿势</h2><p>Redis客户端为了获取锁，向Redis节点发送如下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lockKey requestId NX PX 30000</span><br></pre></td></tr></tbody></table></figure></div><p>lockKey 是加锁的锁名；<br>requestId 是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的；（下面会分析它的作用）<br>NX 表示只有当lockKey对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁；<br>PX 30000 设置过期时间，表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</p><p>在java中使用jedis包的调用方法是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime)</span><br></pre></td></tr></tbody></table></figure></div><p><strong>问题：为什么要设置一个随机字符串requestId？如果没有会出现什么问题？</strong></p><p>下面释放锁的时候给出答案。</p><h2 id="依赖redis超时自动释放锁的问题"><a href="#依赖redis超时自动释放锁的问题" class="headerlink" title="依赖redis超时自动释放锁的问题"></a>依赖redis超时自动释放锁的问题</h2><p>如果按照如下方式加锁：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);</span><br><span class="line">if ("OK".equals(result)) {</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>加锁之后，每次都会到expireTime之后才会释放锁，哪怕业务使用完这把锁了。所以更合理的做法是：</p><p>1、加锁；</p><p>2、业务操作；</p><p>3、主动释放锁；</p><p>4、如果主动释放锁失败了，则达到超时时间，redis自动释放锁。</p><p>暂时无法在飞书文档外展示此内容</p><p>如何释放锁呢？java代码里在finally中释放锁，即无论代码执行成功或者失败，都要释放锁。</p><p>try{<br>    String result = jedis.set(lockKey, requestId, “NX”, “PX”, expireTime);<br>    if (“OK”.equals(result)) {<br>        return true;<br>    }<br>    return false;<br>} finally {<br>    unlock(lockKey);<br>}</p><h2 id="释放了别人的锁"><a href="#释放了别人的锁" class="headerlink" title="释放了别人的锁"></a>释放了别人的锁</h2><p>上面那个unlock(lockKey)代码释放锁有什么问题？可能会出现释放别人的锁的问题。</p><p>有的同学可能会反驳：线程A获取了锁之后，它要是没有释放锁，这个时候别的线程假如线程B、C……根本不可能获取到锁，何来释放别人锁之说？</p><p>暂时无法在飞书文档外展示此内容</p><p>【1】客户端1获取锁成功。</p><p>【2】客户端1在某个操作上阻塞了很长时间。</p><p>【3】过期时间到了，锁自动释放了。</p><p>【4】客户端2获取到了对应同一个资源的锁。</p><p>【5】客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</p><p>【6】另外线程客户端3此时可以成功请求到锁</p><p>如何解决这个问题：自己只能释放自己加的锁，不允许释放别人加的锁！</p><p>前面使用set命令加锁的时候，除了使用lockKey锁标识之外，还使用了一个requestId，这个requestId的作用是什么呢？</p><p>requestId是在释放锁的时候用的！！！</p><p>伪代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.get(lockKey).equals(requestId)) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>所以在释放锁的时候，先要获取到该锁的值（就是每个加锁线程自己设置的requestId），然后判断跟之前自己设置的值是否相同，如果相同才允许删除锁，返回成功，如果不同，直接返回失败。</p><p><strong>问题：为什么要设置一个随机字符串requestId？如果没有会出现什么问题？</strong></p><p>设置一个随机字符串requestId是必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能导致释放别人的锁。所以要保证requestId全局唯一。</p><h2 id="释放锁的问题：非原子操作"><a href="#释放锁的问题：非原子操作" class="headerlink" title="释放锁的问题：非原子操作"></a>释放锁的问题：非原子操作</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.get(lockKey).equals(requestId)) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line">return false;</span><br></pre></td></tr></tbody></table></figure></div><p>显然，jedis.get(lockKey).equals(requestId) 这行代码包含了【获取该锁的值】，【判断是否是自己加的锁】，【删除锁】这三个操作，万一这三个操作中间的某个时刻出现阻塞</p><p>暂时无法在飞书文档外展示此内容<br>【1】客户端1获取锁成功；<br>【2】客户端1进行业务操作；<br>【3】客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。<br>【4】客户端1判断随机字符串的值，与预期的值相等。<br>【5】客户端1由于某个原因阻塞住了很长时间。<br>【6】过期时间到了，锁自动释放了。<br>【7】客户端2获取到了对应同一个资源的锁。<br>【8】客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</p><p>实际上，如果不是客户端1阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>问题的根源：锁的判断在客户端，但是锁的删除却在服务端！</p><h2 id="正确的释放锁姿势"><a href="#正确的释放锁姿势" class="headerlink" title="正确的释放锁姿势"></a>正确的释放锁姿势</h2><p>正确的释放锁姿势——锁的判断和删除都在服务端（redis），使用lua脚本保证原子性：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure></div><p>这段Lua脚本在执行的时候要把前面的requestId作为ARGV[1]的值传进去，把lockKey作为KEYS[1]的值传进去。</p><p>释放锁的操作为什么要使用lua脚本？<br>释放锁其实包含三步操作：’GET’、判断和’DEL’，用Lua脚本来实现能保证这三步的原子性。</p><h2 id="锁超时问题"><a href="#锁超时问题" class="headerlink" title="锁超时问题"></a>锁超时问题</h2><p>如果客户端1请求锁成功了，但是由于业务处理、GC、操作系统等原因导致它处理时间过长，超过了锁的时间，这时候redis会自动释放锁，这种情况可能导致问题：</p><p>如何解决这种问题？</p><p>—- 续期，java里我们可以使用TimerTask类来实现自动续期的功能，伪代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer();</span><br><span class="line">timer.schedule(new TimerTask() {</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Timeout timeout) throws Exception {</span><br><span class="line">        //自动续期逻辑􁛔􀛖􁖅􀹗􁭦􁬋</span><br><span class="line">    }</span><br><span class="line">}, 10000, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure></div><p>这个机制在redisson框架中已经实现，而且还有一个比较霸气的名字watchdog（看门狗）：加锁时没有指定加锁时间时会启用watchdog机制，默认加锁30秒，每10秒钟检查一次，如果存在就重新设置 过期时间为30秒（即30秒之后它就不再续期了）</p><p>lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</p><p>默认值：30000</p><p>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用leaseTimeout参数的情况。如果该看门狗未使用lockWatchdogTimeout去重新调整一个分布式锁的</p><p>lockWatchdogTimeout超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</p><h1 id="Redis主从架构数据同步复制问题"><a href="#Redis主从架构数据同步复制问题" class="headerlink" title="Redis主从架构数据同步复制问题"></a>Redis主从架构数据同步复制问题</h1><p>我们通常使用「Redis Cluster」或者「哨兵模式」这两种方式实现redis的高可用，而这两种方式都是基于「主从架构数据同步复制」实现的，而redis默认的主从复制是异步的。</p><p>前面铺垫的redis锁在单点实例中是没有问题的，因为并没有涉及redis的高可用部署架构细节。但是如果多实例的情况下会出现什么问题呢？比如：主从、或者使用了哨兵模式、或者redis cluster。redis的主从架构如下所示：</p><p>Redis所有的写操作都是先在Master上操作，然后同步更新到Slave上，Slave只能读不能写。<br>丢失数据场景：当网络发生脑裂（split-brain）或者partitioned cluster集群分裂为多数派与少数派，如果数据继续写入少数派的Master，则当Cluster感知，并停止少数派Master，或者重新选主时，则面临丢失刚才已写入少数派的数据</p><p>主从发生重新选导致分布式锁出现问题的场景：<br>暂时无法在飞书文档外展示此内容</p><h1 id="WAIT命令能够为Redis实现强一致吗？"><a href="#WAIT命令能够为Redis实现强一致吗？" class="headerlink" title="WAIT命令能够为Redis实现强一致吗？"></a>WAIT命令能够为Redis实现强一致吗？</h1><p>WAIT numreplicas timeout </p><p>numreplicas：指定副本（slave）的数量。</p><p>timeout：超时时间，时间单位为毫秒；当设置为0 时，表示无限等待，即用不超时。</p><p>WAIT命令作用：WAIT 命令阻塞当前客户端，直到所有先前的写入命令成功传输，并且由至少指定数量的副本（slave）确认。在主从、sentinel和Redis群集故障转移中， WAIT能够增强（仅仅是增强，但不是保证）数据的安全性。</p><p>官方文档：<a href="https://redis.io/commands/wait" target="_blank" rel="noopener">https://redis.io/commands/wait</a></p><p>结论： WAIT 不能保证 Redis 的强一致性</p><h1 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h1><p>针对上面的问题，redis之父antirez设计了Redlock算法，Redlock的算法描述就放在Redis的官网上：<br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></p><p>在Redlock之前，很多人对于分布式锁的实现都是基于单个Redis节点的。而Redlock是基于多个Redis节点（都是Master）的一种实现。前面基于单Redis节点的算法是Redlock的基础。<br>加锁<br>Redlock算法基于N个完全独立的Redis节点，客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>【1】获取当前时间T1（毫秒数）。</p><p>【2】使用相同的key、value按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。</p><p>【3】获取当前时间T2减去步骤1中的T1，计算获取锁消耗了多长时间（T3= T2-T1），计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（大于等于 N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>【4】如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>【5】如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>注意！！！：redLock会直接连接多个redis主节点，不是通过集群机制连接的。<br>RedLock的写与主从集群无关，直接操作的是所有主节点，所以才能避开主从故障切换时锁丢失的问题。</p><h2 id="失败重试（脑裂问题）"><a href="#失败重试（脑裂问题）" class="headerlink" title="失败重试（脑裂问题）"></a>失败重试（脑裂问题）</h2><p>高并发场景下，当多个加锁线程并发抢锁时，可能导致脑裂，最终造成任何一个线程都无法抢到锁的情况。<br>暂时无法在飞书文档外展示此内容所以当一个加锁线程无法获得锁的时候，应该在一个随机延时后再一次尝试获得锁。加锁线程从多数redis实例中获得锁越快，出现脑裂的窗口越小（重试的次数也越少）。所以理想情况下，加锁线程应该多路复用地同时向N个实例发送加锁命令。</p><p>值得强调的是，如果获取大部分锁失败，加锁线程应该尽可能快的释放（部分）已经获得了的锁。所以为了让锁能够再次被获得就没有必要等待key过期（然而如果发生了网络分区导致客户端无法再与redis实例交互，那么就必须等待key过期才能重新抢到锁）。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>Redlock算法释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><blockquote><p>问题1：为什么要在多个实例上加锁？<br>本质上为了容错，部分实例异常宕机，剩余实例只要超过N/2+1依旧可用。多个实例节点，实际上构建了一个分布式锁系统。分布式系统中，总会有异常节点，所以需要考虑异常节点达到多少个，也不会影响整个系统的正确性。（可以参考一下拜占庭将军问题的分析）</p></blockquote><blockquote><p>问题2：为什么步骤3加锁成功之后，还要计算加锁的累计耗时？<br>因为加锁操作的针对的是分布式中的多个节点，所以耗时肯定是比单个实例耗时更久，至少需要N/2+1个网络来回，还要考虑网络延迟、丢包、超时等情况发生，网络请求次数越多，异常的概率越大。<br>所以即使N/2+1个节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那么此时的锁已经没有意义了。</p></blockquote><blockquote><p>问题3：为什么释放锁，要操作所有节点，对所有节点都释放锁？<br>因为当对某一个redis节点加锁时，可能因为网络原因导致加锁“失败”。注意这个“失败”，指的是redis节点实际已经加锁成功了，但是返回的结果因为网络延迟并没有传到加锁的线程，被加锁线程丢弃了，加锁线程误以为没有成功，于是加锁线程去尝试下一个节点了。</p></blockquote><p>所以释放锁的时候，不管以前有没有加锁成功，都要释放所有节点的锁，以保证清除节点上述图中发生的情况导致残留的锁。</p><p>崩## 溃恢复（AOF持久化）对Redlock算法影响</p><p>假设Rodlock算法中的redis发生了崩溃-恢复，那么锁的安全性将无法保证。假设加锁线程在5个实例中对其中3个加锁成功，获得了这把分布式锁，这个时候3个实例中有一个实例被重启了。重启后的实例将丢失其中的锁信息，这个时候另一个加锁线程可以对这个实例加锁成功，此时两个线程同时持有分布式锁。锁的安全性被破坏。</p><p>暂时无法在飞书文档外展示此内容如果我们配置了AOF持久化，只能减少它发生的概率而无法保证锁的绝对安全。断电的场景下，如果redis被配置了默认每秒同步数据到硬盘，重启之后lockKey可能会丢失，理论上，如果我们想要保证任何实例重启的情况下锁都是安全的，需要在持久化配置中设置<br>fsync=always，但此时redis的性能将大大打折扣。</p><p>为了保证这一点，我们只需要让一个崩溃时间、不可用时间（实例崩溃后存在的锁的所有key所需的时间）比最大TTL还要长的实例变成非法和自动释放的。<br>如果不配置redis持久化，那么只能使用延迟重启保证锁的安全性。</p><p>结论：为了保证Redlock算法的安全性，有如下两种手段</p><h2 id="持久化配置中设置"><a href="#持久化配置中设置" class="headerlink" title="持久化配置中设置"></a>持久化配置中设置</h2><p>fsync=always，性能大大降低<br>恰当的运维，把崩溃节点进行延迟重启，超过崩溃前所有锁的</p><p>TTL时间之后才加入Redlock节点组<br>redis分布式锁官方文档翻译</p><h2 id="Redlock算法存在的问题"><a href="#Redlock算法存在的问题" class="headerlink" title="Redlock算法存在的问题"></a>Redlock算法存在的问题</h2><p>Redlock论战：Martin Kleppmann vs. Antirez<br>Martin Kleppmann是剑桥大学的分布式系统专家，《数据密集型应用系统设计》一书的作者。<br>Antirez 是redis的作者，redlock算法的作者。<br>Redis之父Antirez实现Redlock算法之后。有一天，Martin Kleppmann写了一篇blog，分析了Redlock在安全性上存在的一些问题。然后Redis的作者立即写了一篇blog来反驳Martin的分析。但Martin表示仍然坚持原来的观点。随后，这个问题在Twitter和Hacker News上引发了激烈的讨论，很多分布式系统的专家都参与其中。</p><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a><br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a><br><a href="http://antirez.com/news/101" target="_blank" rel="noopener">http://antirez.com/news/101</a></p><p>Martin Kleppmann在2016-02-08这一天发表了一篇blog，名字叫“How to do distributed locking”，地址如下：<br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p><p>Martin在这篇文章中谈及了分布式系统的很多基础性的问题（特别是分布式计算的异步模型），对分布式系统的从业者来说非常值得一读。这篇文章大体可以分为两大部分：<br>前半部分，与Redlock无关。Martin指出，即使我们拥有一个完美实现的分布式锁（带自动过期功能），在没有共享资源参与进来提供某种fencing机制的前提下，我们仍然不可能获得足够的安全性。<br>后半部分，是对Redlock本身的批评。Martin指出，由于Redlock本质上是建立在一个同步模型之上，对系统的记时假设(timing assumption)有很强的要求，因此本身的安全性是不够的。<br>客户端长期阻塞导致锁过期<br>首先我们讨论一下前半部分的关键点。Martin给出了下面这样一份时序图：</p><p>在上面的时序图中，假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。上图中出现的lease这个词可以暂且认为就等同于一个带有自动过期功能的锁。客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p><p>初看上去，有人可能会说，既然客户端1从GC pause中恢复过来以后不知道自己持有的锁已经过期了，那么它可以在访问共享资源之前先判断一下锁是否过期。但仔细想想，这丝毫也没有帮助。因为GC pause可能发生在任意时刻，也许恰好在判断完之后。<br>也有人会说，如果客户端使用没有GC的语言来实现，是不是就没有这个问题呢？Martin指出，系统环境太复杂，仍然有很多原因导致进程的pause，比如虚存造成的缺页故障(page fault)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果。<br>总结起来就是说，即使锁服务本身是没有问题的，而仅仅是客户端有长时间的pause或网络延迟，仍然会造成两个客户端同时访问共享资源的冲突情况发生。而这种情况其实就是我们在前面已经提出来的“客户端长期阻塞导致锁过期”的那个疑问。<br>解决方案——fencing token<br>那怎么解决这个问题呢？Martin给出了一种方法，称为fencing token。fencing token是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图：</p><p>在上图中，客户端1先获取到的锁，因此有一个较小的fencing token，等于33，而客户端2后获取到的锁，有一个较大的fencing token，等于34。客户端1从GC pause中恢复过来之后，依然是向存储服务发送访问请求，但是带了fencing token = 33。存储服务发现它之前已经处理过34的请求，所以会拒绝掉这次33的请求。这样就避免了冲突。<br>（问题：考虑网络延迟导致33号token比34号先到的情景）<br>时间跳跃<br>Martin在文中构造了一些事件序列，能够让Redlock失效（两个客户端同时持有锁）。为了说明Redlock对系统记时(timing)的过分依赖，他首先给出了下面的一个例子（还是假设有5个Redis节点A, B, C, D, E）：<br>客户端1从Redis节点A, B, C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。<br>节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。<br>客户端2从Redis节点C, D, E成功获取了同一个资源的锁（多数节点）。<br>客户端1和客户端2现在都认为自己持有了锁。<br>上面这种情况之所以有可能发生，本质上是因为Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了了。Martin在这里其实是要指出分布式算法研究中的一些基础性问题，或者说一些常识问题，即好的分布式算法应该基于异步模型(asynchronous model)，算法的安全性不应该依赖于任何记时假设(timing assumption)。在异步模型中：进程可能pause任意长的时间，消息可能在网络中延迟任意长的时间，甚至丢失，系统时钟也可能以任意方式出错。一个好的分布式算法，这些因素不应该影响它的安全性(safety property)，只可能影响到它的活性(liveness property)，也就是说，即使在非常极端的情况下（比如系统时钟严重错误），算法顶多是不能在有限的时间内给出结果而已，而不应该给出错误的结果。这样的算法在现实中是存在的，像比较著名的Paxos，或Raft。但显然按这个标准的话，Redlock的安全性级别是达不到的。</p><p>在Martin的这篇文章中，还有一个很有见地的观点，就是对锁的用途的区分。他把锁的用途分为两种：<br>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email。<br>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其它严重的问题。<br>最后，Martin得出了如下的结论：<br>如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock则是个过重的实现(heavyweight)。<br>如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。而且，它没有一个机制能够提供fencing token。那应该使用什么技术呢？Martin认为，应该考虑类似Zookeeper的方案，或者支持事务的数据库。<br>Martin对Redlock算法的形容是：<br>neither fish nor fowl （不伦不类）</p><p>【其它疑问】<br>Martin提出的fencing token的方案，需要对提供共享资源的服务进行修改，这在现实中可行吗？<br>根据Martin的说法，看起来，如果资源服务器实现了fencing token，它在分布式锁失效的情况下也仍然能保持资源的互斥访问。这是不是意味着分布式锁根本没有存在的意义了？<br>资源服务器需要检查fencing token的大小，如果提供资源访问的服务也是包含多个节点的（分布式的），那么这里怎么检查才能保证fencing token在多个节点上是递增的呢？<br>Martin对于fencing token的举例中，两个fencing token到达资源服务器的顺序颠倒了（小的fencing token后到了），这时资源服务器检查出了这一问题。如果客户端1和客户端2都发生了GC pause，两个fencing token都延迟了，它们几乎同时到达了资源服务器，但保持了顺序，那么资源服务器是不是就检查不出问题了？这时对于资源的访问是不是就发生冲突了？</p><p>1、问题一：节点重启<br>N个Redis节点中如果有节点发生崩溃重启，会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。参考上面的“崩溃恢复（AOF持久化）对Redlock算法影响”分析。<br>【备注】在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。</p><p>如何解决这个问题？<br>redis之父antirez提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><p>2、问题二：时钟变迁<br>Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了了。<br>结论：redis的过期时间是依赖系统时钟的，如果时钟漂移过大时会影响到过期时间的计算。<br>为什么系统时钟会存在漂移呢？先简单说下系统时间，linux提供了两个系统时间：clock realtime和clock monotonic<br>clock realtime</p><p>也就是xtime/wall time，这个时间是可以被用户改变的，被NTP改变。redis的判断超时使用的gettimeofday函数取的就是这个时间，redis的过期计算用的也是这个时间。参考<a href="https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time.html" target="_blank" rel="noopener">https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time.html</a><br>clock monotonic</p><p>，直译过来是单调时间，不会被用户改变，但是会被NTP改变。<br>最理想的情况是：所有系统的时钟都时时刻刻和NTP服务器保持同步，但这显然是不可能的。<br>clock realtime可以被人为修改，在实现分布式锁时，不应该使用clock realtime。不过很可惜，redis使用的就是这个时间，Redis 5.0使用的还是clock realtime。Antirez说过后面会改成clock monotonic的。也就是说，人为修改redis服务器的时间，就能让redis出问题了。<br>暂时无法在飞书文档外展示此内容<br>【1】加锁线程1从节点Redis1, Redis2, Redis3成功获取了锁（多数节点）。由于网络问题，与Redis4、Redis5通信失败。<br>【2】节点Redis3上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。<br>【3】加锁线程2从Redis3, Redis4, Redis5成功获取了同一个资源的锁（多数节点）。<br>【4】加锁线程1和加锁线程2现在都认为自己持有了锁。</p><p>什么情况下会发生时钟变迁？<br>人为修改了时钟<br>从NTP服务收到了一个大的时钟更新事件导致时钟漂移<br>闰秒（是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中或者季末对协调世界时增加或减少1秒的调整，此时一分钟为59秒或者61秒，闰秒曾使许多大型系统崩溃）<br>……</p><p>如何解决这个问题？<br>（1）redis之父antirez在redlock论战中的解释：实际系统中是可以避免大的时钟跳跃的。当然，这取决于基础设施和运维方式。（实际上这种理想情况是很难达到的，不同的redis节点，毫秒级别的时间误差几乎是必然存在的。）<br>（2）Fencing token机制：类似raft算法、zab协议中的全局递增数字，对这个token的校验需要后端资源进行校验，如此一来，相当于后端资源具备了互斥机制，这种情况下为什么还要一把分布式锁呢？而且涉及到后端资源的改造。</p><p>总结<br>RedLock算法数建立在了 Time 是可信的模型上的一种分布式锁，所以时间被破坏的情况下它无法实现锁的绝对安全；<br>RedLock算法实现比较复杂，并且性能比较差；<br>RedLock需要恰当的运维保障它的正确性，故障-崩溃之后需要一套延迟重启的机制</p><p>RedLock的核心价值，在于多数派思想。相比于基于单点Redis的锁服务，RedLock解决了锁数据写入时多份的问题，从而可以克服单点故障下的数据一致性问题。在继承自基于单点的Redis锁服务缺陷（解锁不具备原子性；锁服务、调用方、资源方缺乏确认机制）的基础上，其核心的问题为：缺乏锁数据丢失的识别和感知机制。<br>RedLock中的每台Redis，充当的仍旧只是存储锁数据的功能，每台Redis之间各自独立，单台Redis缺乏全局的信息，自然也不知道自己的锁数据是否是完整的。在单台Redis数据的不完整的前提下，没有分布式共识机制，使得在各种分布式环境的典型场景下（结点故障、网络丢包、网络乱序），没有完整数据但参与决策，从而破坏数据一致性。</p><p>基于Mysql的分布式锁（ShedLock）<br>使用ShedLock需要在Mysql数据库创建一张加锁用的表：<br>CREATE TABLE shedlock<br>(<br>    name VARCHAR(64),<br>    lock_until TIMESTAMP(3) NULL,<br>    locked_at TIMESTAMP(3) NULL,<br>    locked_by VARCHAR(255),<br>    PRIMARY KEY (name)<br>)</p><p>加锁<br>通过插入同一个name(primary key)，或者更新同一个name来抢，对应的intsert、update的SQL为：</p><p>INSERT INTO shedlock<br>(name, lock_until, locked_at, locked_by)<br>VALUES<br>(锁名字,  当前时间+最多锁多久,  当前时间, 主机名)<br>UPDATE shedlock<br>SET lock_until = 当前时间+最多锁多久,<br>locked_at = 当前时间,<br>locked_by = 主机名 WHERE name = 锁名字 AND lock_until &lt;= 当前时间 </p><p>释放锁：<br>通过设置lock_until来实现释放，再次抢锁的时候需要通过lock_util来判断锁失效了没。对应的SQL为：<br>UPDATE shedlock<br>SET lock_until = lockTime WHERE name = 锁名字<br>问题分析<br>1、单点问题；<br>2、主从同步问题。假如使用全同步模式，分布式锁将会有性能上的问题。</p><p>基于zookeeper的分布式锁<br>zookeeper的节点类型<br>Zookeeper的数据存储结构就像一棵树，这棵树由节点组成，这种节点叫做Znode。Znode分为四种类型：<br>持久节点 （PERSISTENT）</p><p>默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。<br>持久节点顺序节点（PERSISTENT_SEQUENTIAL）</p><p>所谓顺序节点，就是在创建节点时，Zookeeper根据创建的顺序给该节点名称进行编号：<br>临时节点（EPHEMERAL）</p><p>和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除：<br>临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><p>【使用该类型节点实现分布式锁】<br>顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。<br>zookeeper的watch机制<br>zookeeper集群和客户端通过长连接维护一个session，当客户端试图创建/lock节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此返回获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。这样的特性redis的Redlock就无法实现。<br>暂时无法在飞书文档外展示此内容</p><p>加锁&amp;释放锁<br>客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。<br>持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。（<br>客户端删除锁）<br>znode应该被创建成<br>EPHEMERAL_SEQUENTIAL的。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除，。这保证了锁一定会被释放（zookeeper服务器自己删除锁）。另外保证了公平性，后面创建的节点会加在节点链最后的位置，等待锁的客户端会按照先来先得的顺序获取到锁。</p><p>暂时无法在飞书文档外展示此内容<br>惊群效应：错误的实现——如果实现zookeeper分布式锁的时候，所有后加入的节点都监听最小的节点。那么删除节点的时候，所有客户端都会被唤醒，这个时候由于通知的客户端很多，通知操作会造成zookeeper性能突然下降，这样会影响zookeeper的使用。<br>时钟变迁问题Zookeeper不依赖全局时间，它使用zab协议实现分布式共识算法，不存在该问题。<br>超时导致锁失效问题Zookeeper不依赖有效时间，它依靠心跳维持锁的占用状态，不存在该问题。</p><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但仔细考察的话，并不尽然。客户端可以删除锁，zookeeper服务器也可以删除锁，会引发什么问题。<br>zookeeper是怎么检测出某个客户端已经崩溃了呢？<br>实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>基于zookeeper的分布式锁存在的问题：<br>【1】客户端1创建了znode节点/lock，获得了锁。<br>【2】客户端1进入了长时间的GC pause。（或者网络出现问题、或者zk服务检测心跳线程出现问题等等）<br>【3】客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。<br>【4】客户端2创建了znode节点/lock，从而获得了锁。<br>【5】客户端1从GC pause中恢复过来，它仍然认为自己持有锁。<br>这个场景下，客户端1和客户端2在一段窗口时间内同时获取到锁。</p><p>结论：使用zookeeper的临时节点实现的分布式锁，它的锁安全期是在客户端取得锁之后到zk服务器会话超时的阈值（跨机房部署很容易出现）的时间之间。它无法设置占用分布式锁的时间，何时zk服务器会删除锁是不可预知的，所以这种方式它比较适合一些客户端获取到锁之后能够快速处理完毕的场景。</p><p>另一种方案<br>另外一种使用zk作分布式锁的实现方式：不使用临时节点，而是使用持久节点加锁，把zk集群当做一个mysql、或者一个单机版的redis，加锁的时候存储锁的到期时间，这种方案把锁的删除、判断过期这两个职责交给客户端处理。（当做一个可以容错的mysql，性能问题！）</p><p>ZooKeeper分布式锁的优点和缺点<br>总结一下ZooKeeper分布式锁：<br>优点：<br>（1）ZooKeeper分布式锁基于分布式一致性算法实现，能有效的解决分布式问题，不受时钟变迁影响，不可重入问题，使用起来也较为简单；<br>（2）当锁持有方发生异常的时候，它和Zookeeper之间的session无法维护。Zookeeper会在Session租约到期后，自动删除该Client持有的锁，以避免锁长时间无法释放而导致死锁。<br>缺点：<br>ZooKeeper实现的分布式锁，性能并不太高。为啥呢？因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同步不到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。<br>总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用特性，所以在并发量不是太高的场景，推荐使用ZooKeeper的分布式锁。</p><p>小结一下，基于ZooKeeper的锁和基于Redis的锁相比在实现特性上有两个不同：<br>在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。<br>基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。</p><p>Chubby<br>提到分布式锁，就不能不提Google的Chubby。<br>Chubby是Google内部使用的分布式锁服务，有点类似于ZooKeeper，但也存在很多差异。Chubby对外公开的资料，主要是一篇论文，叫做“The Chubby lock service for loosely-coupled distributed systems”，下载地址如下：<br><a href="https://research.google.com/archive/chubby.html" target="_blank" rel="noopener">https://research.google.com/archive/chubby.html</a></p><p>另外，YouTube上有一个的讲Chubby的talk，也很不错，播放地址：<br><a href="https://www.youtube.com/watch?v=PqItueBaiRg&amp;feature=youtu.be&amp;t=487" target="_blank" rel="noopener">https://www.youtube.com/watch?v=PqItueBaiRg&amp;feature=youtu.be&amp;t=487</a></p><p>Chubby自然也考虑到了延迟造成的锁失效的问题。论文里有一段描述如下：<br>a process holding a lock L may issue a request R, but then fail. Another process may ac- quire L and perform some action before R arrives at its destination. If R later arrives, it may be acted on without the protection of L, and potentially on inconsistent data.<br>（译文： 一个进程持有锁L，发起了请求R，但是请求失败了。另一个进程获得了锁L并在请求R到达目的方之前执行了一些动作。如果后来请求R到达了，它就有可能在没有锁L保护的情况下进行操作，带来数据不一致的潜在风险。）<br>这跟前面Martin的分析大同小异。</p><p>Chubby给出的用于解决（缓解）这一问题的机制称为sequencer，类似于fencing token机制。锁的持有者可以随时请求一个sequencer，这是一个字节串，它由三部分组成：<br>锁的名字。</p><p>锁的获取模式（排他锁还是共享锁）。</p><p>lock generation number（一个64bit的单调递增数字）。作用相当于fencing token或epoch number。</p><p>sequencer：客户端拿到sequencer之后，在操作资源的时候把它传给资源服务器。然后，资源服务器负责对sequencer的有效性进行检查。检查可以有两种方式：<br>调用Chubby提供的API，<br>CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效。<br>将客户端传来的sequencer与资源服务器当前观察到的<br>最新的sequencer进行对比检查。可以理解为与Martin描述的对于fencing token的检查类似。<br>锁延期机制：当然，如果由于兼容的原因，资源服务本身不容易修改，那么Chubby还提供了一种机制：<br>lock-delay</p><p>。Chubby允许客户端为持有的锁指定一个lock-delay的时间值（默认是1分钟）。当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空(draining the queue)，尽量防止出现延迟到达的未处理请求。</p><p>可见，为了应对锁失效问题，Chubby提供的两种处理方式：CheckSequencer()检查与上次最新的sequencer对比、lock-delay，它们对于安全性的保证是从强到弱的。而且，这些处理方式本身都没有保证提供绝对的正确性(correctness)。但是，Chubby确实提供了单调递增的lock generation number，这就允许资源服务器在需要的时候，利用它提供更强的安全性保障。</p><p>总结起来，Chubby引入了资源方和锁服务的验证，来避免了锁服务本身孤立地做预防死锁机制而导致的破坏锁安全性的风险。同时依靠Session来维持锁的持有状态，在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。</p><p>总结<br>（1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；<br>（2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。<br>（3）基于mysql的分布式锁一般均有单点问题，高并发场景下对数据库的压力比较大；</p><p>需要考虑的问题：我们的业务对极端情况的容忍度，为了一把绝对安全的分布式锁导致过度设计，引入的复杂性和得到的收益是否值得。</p></body></html>]]></content>
    
    <summary type="html">
    
      我无法忍受沉默，而与你交谈恰是良药。
    
    </summary>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/categories/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
    
      <category term="实习技术帖" scheme="http://raptor1998.top/tags/%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%B8%96/"/>
    
  </entry>
  
</feed>
