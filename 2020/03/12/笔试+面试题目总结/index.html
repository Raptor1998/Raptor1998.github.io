<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>笔试+面试题目总结 | raptor's blog</title><meta name="description" content="我无法忍受沉默，而与你交谈恰是良药。"><meta name="keywords" content="面试总结"><meta name="author" content="陳 ？"><meta name="copyright" content="陳 ？"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="笔试+面试题目总结"><meta name="twitter:description" content="我无法忍受沉默，而与你交谈恰是良药。"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg"><meta property="og:type" content="article"><meta property="og:title" content="笔试+面试题目总结"><meta property="og:url" content="http://raptor1998.top/2020/03/12/%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="raptor's blog"><meta property="og:description" content="我无法忍受沉默，而与你交谈恰是良药。"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://raptor1998.top/2020/03/12/%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><link rel="prev" title="Spring Review" href="http://raptor1998.top/2020/04/01/Spring5/"><link rel="next" title="Java中的String类" href="http://raptor1998.top/2020/01/10/Java%E4%B8%AD%E7%9A%84String%E7%B1%BB/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0b50707a55dfca710ef66e4071fa22cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://raptor1998.top/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"高大威猛,英俊潇洒,智勇双全,器宇不凡,风流倜傥,玉树临风,成熟稳重,风趣幽默,举世无双,绝无仅有,空前绝后,独一无二,前无古人,后无来者,只此一家,别无分店","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="raptor's blog" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">raptor's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> MV</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/20200102090650.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> MV</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java基础"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#和equals区别"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">&#x3D;&#x3D;和equals区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#hashcode"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">hashcode</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HashMap的底层实原理"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">HashMap的底层实原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HashMap概述"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">HashMap概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HashMap的数据结构"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">HashMap的数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#与hashtable的区别"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">与hashtable的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#hashSet实现原理"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">hashSet实现原理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#final、static"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">final、static</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#final关键字"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">final关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static关键字"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">static关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#final和static结合"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">final和static结合</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ceil-、floor-、round"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">ceil()、floor() 、round()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#String、StringBuffer和StringBuilder"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">String、StringBuffer和StringBuilder</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#三者区别"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">三者区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#StringBuffer和StringBuilder区别"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">StringBuffer和StringBuilder区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#抽象类"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">抽象类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抽象类可以被final修饰吗"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">抽象类可以被final修饰吗</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#接口和抽象类区别"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">接口和抽象类区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#IO"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">IO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ArrayList和LinkedList的区别"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">ArrayList和LinkedList的区别</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如果catch中return了，finally还会执行吗"><span class="toc_mobile_items-number">1.9.1.</span> <span class="toc_mobile_items-text">如果catch中return了，finally还会执行吗</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">线程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程（Process）-amp-线程（Thread）"><span class="toc_mobile_items-number">1.10.1.</span> <span class="toc_mobile_items-text">进程（Process）&amp;线程（Thread）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#并发、并行"><span class="toc_mobile_items-number">1.10.2.</span> <span class="toc_mobile_items-text">并发、并行</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程生命周期"><span class="toc_mobile_items-number">1.10.3.</span> <span class="toc_mobile_items-text">线程生命周期</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是守护线程daemon-thread"><span class="toc_mobile_items-number">1.10.4.</span> <span class="toc_mobile_items-text">什么是守护线程daemon thread</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建线程的几种方式"><span class="toc_mobile_items-number">1.10.5.</span> <span class="toc_mobile_items-text">创建线程的几种方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sleep-和wait-的区别"><span class="toc_mobile_items-number">1.10.6.</span> <span class="toc_mobile_items-text">sleep()和wait()的区别</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sleep"><span class="toc_mobile_items-number">1.10.6.1.</span> <span class="toc_mobile_items-text">sleep()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#wait"><span class="toc_mobile_items-number">1.10.6.2.</span> <span class="toc_mobile_items-text">wait()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#notify和notifyAll的区别"><span class="toc_mobile_items-number">1.10.7.</span> <span class="toc_mobile_items-text">notify和notifyAll的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的run和start有什么区别"><span class="toc_mobile_items-number">1.10.8.</span> <span class="toc_mobile_items-text">线程的run和start有什么区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#java中如何保证多线程运行安全"><span class="toc_mobile_items-number">1.10.9.</span> <span class="toc_mobile_items-text">java中如何保证多线程运行安全</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁"><span class="toc_mobile_items-number">1.10.10.</span> <span class="toc_mobile_items-text">死锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#概念"><span class="toc_mobile_items-number">1.10.10.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#死锁必要条件"><span class="toc_mobile_items-number">1.10.10.2.</span> <span class="toc_mobile_items-text">死锁必要条件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ThreadLocal"><span class="toc_mobile_items-number">1.10.11.</span> <span class="toc_mobile_items-text">ThreadLocal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized底层实现原理"><span class="toc_mobile_items-number">1.10.12.</span> <span class="toc_mobile_items-text">synchronized底层实现原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized和volatile的区别"><span class="toc_mobile_items-number">1.10.13.</span> <span class="toc_mobile_items-text">synchronized和volatile的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized和lock的区别"><span class="toc_mobile_items-number">1.10.14.</span> <span class="toc_mobile_items-text">synchronized和lock的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized和Reentrantlock的区别"><span class="toc_mobile_items-number">1.10.15.</span> <span class="toc_mobile_items-text">synchronized和Reentrantlock的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#深拷贝和浅拷贝"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">深拷贝和浅拷贝</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#J2EE"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">J2EE</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">Spring</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SpringAOP"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">SpringAOP</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SpringIOC"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">SpringIOC</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#web基础"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">web基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#session和cookie的区别"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">session和cookie的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#session工作原理"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">session工作原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#jsp和servlet的区别"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">jsp和servlet的区别</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据库"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">数据库</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#事务"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">事务</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#乐观锁与悲观锁"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">乐观锁与悲观锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#索引"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">索引</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#b-树"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">b+树</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#优化"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">优化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#算法"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#约瑟夫环问题"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">约瑟夫环问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#最大上升子序列和"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">最大上升子序列和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#筛素数"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">筛素数</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java基础"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#和equals区别"><span class="toc-number">1.1.</span> <span class="toc-text">&#x3D;&#x3D;和equals区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode"><span class="toc-number">1.2.</span> <span class="toc-text">hashcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap的底层实原理"><span class="toc-number">1.3.</span> <span class="toc-text">HashMap的底层实原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap概述"><span class="toc-number">1.3.1.</span> <span class="toc-text">HashMap概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的数据结构"><span class="toc-number">1.3.2.</span> <span class="toc-text">HashMap的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与hashtable的区别"><span class="toc-number">1.3.3.</span> <span class="toc-text">与hashtable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashSet实现原理"><span class="toc-number">1.3.4.</span> <span class="toc-text">hashSet实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final、static"><span class="toc-number">1.4.</span> <span class="toc-text">final、static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final关键字"><span class="toc-number">1.4.1.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字"><span class="toc-number">1.4.2.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final和static结合"><span class="toc-number">1.4.3.</span> <span class="toc-text">final和static结合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ceil-、floor-、round"><span class="toc-number">1.5.</span> <span class="toc-text">ceil()、floor() 、round()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String、StringBuffer和StringBuilder"><span class="toc-number">1.6.</span> <span class="toc-text">String、StringBuffer和StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三者区别"><span class="toc-number">1.6.1.</span> <span class="toc-text">三者区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer和StringBuilder区别"><span class="toc-number">1.6.2.</span> <span class="toc-text">StringBuffer和StringBuilder区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类"><span class="toc-number">1.7.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类可以被final修饰吗"><span class="toc-number">1.7.1.</span> <span class="toc-text">抽象类可以被final修饰吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口和抽象类区别"><span class="toc-number">1.7.2.</span> <span class="toc-text">接口和抽象类区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">1.8.</span> <span class="toc-text">IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList和LinkedList的区别"><span class="toc-number">1.9.</span> <span class="toc-text">ArrayList和LinkedList的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如果catch中return了，finally还会执行吗"><span class="toc-number">1.9.1.</span> <span class="toc-text">如果catch中return了，finally还会执行吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.10.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程（Process）-amp-线程（Thread）"><span class="toc-number">1.10.1.</span> <span class="toc-text">进程（Process）&amp;线程（Thread）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发、并行"><span class="toc-number">1.10.2.</span> <span class="toc-text">并发、并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程生命周期"><span class="toc-number">1.10.3.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是守护线程daemon-thread"><span class="toc-number">1.10.4.</span> <span class="toc-text">什么是守护线程daemon thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的几种方式"><span class="toc-number">1.10.5.</span> <span class="toc-text">创建线程的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-和wait-的区别"><span class="toc-number">1.10.6.</span> <span class="toc-text">sleep()和wait()的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">wait()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify和notifyAll的区别"><span class="toc-number">1.10.7.</span> <span class="toc-text">notify和notifyAll的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的run和start有什么区别"><span class="toc-number">1.10.8.</span> <span class="toc-text">线程的run和start有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java中如何保证多线程运行安全"><span class="toc-number">1.10.9.</span> <span class="toc-text">java中如何保证多线程运行安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">1.10.10.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">1.10.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁必要条件"><span class="toc-number">1.10.10.2.</span> <span class="toc-text">死锁必要条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.10.11.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized底层实现原理"><span class="toc-number">1.10.12.</span> <span class="toc-text">synchronized底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和volatile的区别"><span class="toc-number">1.10.13.</span> <span class="toc-text">synchronized和volatile的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和lock的区别"><span class="toc-number">1.10.14.</span> <span class="toc-text">synchronized和lock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和Reentrantlock的区别"><span class="toc-number">1.10.15.</span> <span class="toc-text">synchronized和Reentrantlock的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝和浅拷贝"><span class="toc-number">1.11.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#J2EE"><span class="toc-number">2.</span> <span class="toc-text">J2EE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">2.1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringAOP"><span class="toc-number">2.1.1.</span> <span class="toc-text">SpringAOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringIOC"><span class="toc-number">2.1.2.</span> <span class="toc-text">SpringIOC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web基础"><span class="toc-number">2.2.</span> <span class="toc-text">web基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#session和cookie的区别"><span class="toc-number">2.2.1.</span> <span class="toc-text">session和cookie的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session工作原理"><span class="toc-number">2.2.2.</span> <span class="toc-text">session工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp和servlet的区别"><span class="toc-number">2.2.3.</span> <span class="toc-text">jsp和servlet的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-number">3.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">3.1.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#乐观锁与悲观锁"><span class="toc-number">3.2.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引"><span class="toc-number">3.3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#b-树"><span class="toc-number">3.3.1.</span> <span class="toc-text">b+树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化"><span class="toc-number">3.4.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法"><span class="toc-number">4.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#约瑟夫环问题"><span class="toc-number">4.1.</span> <span class="toc-text">约瑟夫环问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最大上升子序列和"><span class="toc-number">4.2.</span> <span class="toc-text">最大上升子序列和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#筛素数"><span class="toc-number">4.3.</span> <span class="toc-text">筛素数</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">笔试+面试题目总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-12<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-03-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">面试总结</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 17 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="和equals区别"><a href="#和equals区别" class="headerlink" title="==和equals区别"></a>==和equals区别</h2><p><a href="http://raptor1998.top/2020/01/10/Java%E4%B8%AD%E7%9A%84String%E7%B1%BB/">见Java中的String类</a></p>
<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><p> 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。这样一来，当集合要添加新的元素时，先调用这个元素的HashCode方法，就一下子能定位到它应该放置的物理位置上。</p>
<ul>
<li>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；</li>
<li>如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了；</li>
<li>不相同的话，也就是发生了Hash key相同导致冲突的情况，那么就在这个Hash key的地方产生一个链表，将所有产生相同HashCode的对象放到这个单链表上去，串在一起。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。<br><a href="https://blog.csdn.net/SEU_Calvin/article/details/52094115?utm_source=blogxgwz1" target="_blank" rel="noopener">原文地址：Java面试——HashCode的作用原理和实例解析</a><br>hashcode相等，然而equals为false，因为在散列表中，hashcode相等即两个键值对的哈希值相等，哈希值相等，并不一定得出键值对相等。<h2 id="HashMap的底层实原理"><a href="#HashMap的底层实原理" class="headerlink" title="HashMap的底层实原理"></a>HashMap的底层实原理</h2><h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3>　　HashMap是基于哈希表的map接口的非同步实现，此实现提供所有可选的映射操作，并且允许使用null值和null键。不保证映射的顺序，特别是他不保证顺序恒久不变。<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3>在Java中，基本的结构就两种，数组和引用，它是“链表散列”的数据结构，即数组和链表的结合体。<br>当我们往HashMap中添加元素时，首先根据key的hashcode计算hash值，根据这个值得到元素在数组中的下标，如果该位置上已经有了元素，则这个位置上的元素将以链表的形式存放，新加入的元素在链表头，最先加入的元素在链尾。<br>jdk1.8中队HashMap实现了优化，当链表中的结点数据超过8个之后，链表会转变为红黑树。<h3 id="与hashtable的区别"><a href="#与hashtable的区别" class="headerlink" title="与hashtable的区别"></a>与hashtable的区别</h3></li>
<li>hashMap去掉了hashTable的contains方法，但是加上了containsValue()和containsKey()</li>
<li>hashTable是同步的，map是不同步的，效率上比hashTable要高</li>
<li>hashMap语序空键值<h3 id="hashSet实现原理"><a href="#hashSet实现原理" class="headerlink" title="hashSet实现原理"></a>hashSet实现原理</h3>hashSet底层由hashMap实现<br>hashSet的值存放于hashMap的key上<br>hashMap的value统一设为PRESENT<h2 id="final、static"><a href="#final、static" class="headerlink" title="final、static"></a>final、static</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3></li>
<li>final修饰的类不能被继承，最终类</li>
<li>final修饰的方法不能被重写</li>
<li>final修饰的变量叫常量，常量必须初始化，初始化之后不能被修改<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3></li>
<li>static变量：按照是否被static修饰成员变量分类，一种是被修饰的，叫做静态变量或者类变量；不能被修饰的叫做实例变量。<br>  区别：静态变量被所有对象所拥共享，在内存中只有一个副本，它当且仅当类除此加载时才会被初始化。实例变量是对象所拥有的，在创建对象是被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>static方法：静态方法，可以直接使用类名.方法名（）来调用。<br>因为静态方法可以直接通过类名调用，任何实例也可以调用，所以静态方法中不能使用super和this关键字；静态方法中不能使用非静态成员变量，也不能调用非静态方法；静态方法和静态变量都是独立于任何实例，所以静态方法不能被abstract修饰。</li>
<li>static代码块：静态代码块实在jvm加载类的时候执行的，并且只会执行一次，<h3 id="final和static结合"><a href="#final和static结合" class="headerlink" title="final和static结合"></a>final和static结合</h3>可以理解为“全局变量” <h2 id="ceil-、floor-、round"><a href="#ceil-、floor-、round" class="headerlink" title="ceil()、floor() 、round()"></a>ceil()、floor() 、round()</h2>分别为向上取证。向下取整和四舍五入<br>==Math.round(-1.5)  =  -1==0.5即向右取整<h2 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h2><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3>String类是不变的对象，每次操作都会产生新的String对象，然后将指针指向新的String对象；而StringBuffer和StringBuilder可以再原有的对象的基础上进行操作，所以经常改变字符串的内容尽量避免使用String。<h3 id="StringBuffer和StringBuilder区别"><a href="#StringBuffer和StringBuilder区别" class="headerlink" title="StringBuffer和StringBuilder区别"></a>StringBuffer和StringBuilder区别</h3>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。<br><a href="https://segmentfault.com/a/1190000017909550" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017909550</a><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2>不一定，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。 。抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了。一旦类中包含了abstract方法，那类该类必须声明为abstract类。<h3 id="抽象类可以被final修饰吗"><a href="#抽象类可以被final修饰吗" class="headerlink" title="抽象类可以被final修饰吗"></a>抽象类可以被final修饰吗</h3>不能，定义抽象类就是为了让其他类继承，定义为final类就不能被继承。<h3 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h3></li>
<li>抽象类extends来继承；接口implements来实现。</li>
<li>抽象类可以有构造函数；接口不行。</li>
<li>抽象类可以有main方法，接口不行。</li>
<li>类可以实现多个接口，但是只能继承一个抽象类</li>
<li>接口中方法默认public修饰，抽象类中可以使任意访问修饰符<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2>字节流和字符流，字节流是8位传输以字节为单位输入输出数据；字符流按16位传输以字符为单位输入输出。<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2>ArrayList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向循环链表，不支持随机访问，使用下标访问同一个元素，ArrayList的时间复杂度是O(1),而LinkedList是O(n)。<h3 id="如果catch中return了，finally还会执行吗"><a href="#如果catch中return了，finally还会执行吗" class="headerlink" title="如果catch中return了，finally还会执行吗"></a>如果catch中return了，finally还会执行吗</h3>会执行，在return前执行。<br>finally中如实没有return，则返回catch中已经形成的路径，如实finally中有返回，则形成新的返回路径，直径返回。<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程（Process）-amp-线程（Thread）"><a href="#进程（Process）-amp-线程（Thread）" class="headerlink" title="进程（Process）&amp;线程（Thread）"></a>进程（Process）&amp;线程（Thread）</h3>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分配的基本单位，是比程序更小的能独立运行得到基本单位。统一进程中的多个线程可以并发执行。<h3 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h3></li>
<li>并行是指两个或者多个事件在同一时间发生；并发是指多个事件在同一时间间隔发生。</li>
<li>并行是指在不同实体的多个事件，并发是同一实体的多个事件。</li>
<li>并发是在一台处理器上处理多个任务，并行在多台处理器处理多个任务。如hadoop分布式集群。<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3>在程序开发中，将一个对象从被实例化完成，到这个对象使用结束，并销毁，将这样的过程称为对象的生命周期。<br>线程被实例化完成，到这个线程被销毁，中间的过程称之为一个线程的生命周期。</li>
<li>新生态：（New）一个线程对象被实例化完成，但是还没有做任何操作。</li>
<li>就绪态：（Ready）一个线程已经被开启，已经开始去争取cpu时间片。</li>
<li>运行态：（Run）一个线程争取到了cpu时间片，开始执行这个线程中的逻辑。</li>
<li>阻塞态：（Interrupt）一个线程在运行过程中，收到了某些操作的影响，放弃了已经争抢到的cpu时间片，并且不再参与时间片的争抢，此时线程处于挂起状态。</li>
<li>死亡态：（Dead）一个线程对象被销毁。<h3 id="什么是守护线程daemon-thread"><a href="#什么是守护线程daemon-thread" class="headerlink" title="什么是守护线程daemon thread"></a>什么是守护线程daemon thread</h3>如果 JVM 中没有一个正在运行的非守护线程，这个时候，JVM 会退出。换句话说，守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点。JVM 中的垃圾回收线程就是典型的守护线程。<h3 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h3>。。。。。。<h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4>该方法是线程类Thread的静态方法，让调用的线程进入睡眠状态，让出时间片给其他线程，等到休眠时间结束，线程进入就绪态和其他线程一起争抢cpu时间片，因为sleep()是static方法，他不能改变对象的机锁，当一个synchronized代码块中调用了sleep方法，线程虽然在休眠，但是它并不释放对象的机锁，其他线程依然无法访问这个线程。如果线程在休眠时被打断，JVM就会抛出InterruptedException异常。<h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4>wait是Object类的方法，当一个线程执行wait()方法时，他就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其它线程可以访问，可以通过notify或notifyall唤醒。<h3 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a>notify和notifyAll的区别</h3>锁池：假设线程A已经拥有对象锁，线程B、C想要获取锁就会被阻塞，进入一个地方去等待锁的等待，这个地方就是该对象的锁池；<br>等待池：假设线程A调用某个对象的wait方法，线程A就会释放该对象锁，同时线程A进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。<br>notify和notifyAll的区别：</li>
<li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；</li>
<li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；<h3 id="线程的run和start有什么区别"><a href="#线程的run和start有什么区别" class="headerlink" title="线程的run和start有什么区别"></a>线程的run和start有什么区别</h3>start方法用来启动一个线程。这时无需等待run方法执行完毕，可以直接执行下面的代码，这时的线程处于就绪状态，并没有运行。<br>run方法是本线程里的，只是线程的一个函数，不是多线程的。直接调用run方法，想防御调用了一个普通方法，必须等待run执行完成才能执行下面的代码，执行路径还是一条。<h3 id="java中如何保证多线程运行安全"><a href="#java中如何保证多线程运行安全" class="headerlink" title="java中如何保证多线程运行安全"></a>java中如何保证多线程运行安全</h3></li>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作做。</li>
<li>可见性：一盒现成对主内存中的修改可以及时的被其他线程看见。</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令的重排序，该观察结果一般杂乱无序。<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4>死锁是指两个或者多个进程在执行过程中，由于竞争彼此需要的资源或者由于彼此通信中造成的一种阻塞的现象，这些永远相互等待的进程成为死锁进程。<h4 id="死锁必要条件"><a href="#死锁必要条件" class="headerlink" title="死锁必要条件"></a>死锁必要条件</h4></li>
<li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>
<li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>
<li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><a href="https://www.cnblogs.com/cjsblog/p/9773079.html" target="_blank" rel="noopener">ThreadLocal原理</a><br><a href="https://blog.csdn.net/Oeljeklaus/article/details/80545749?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">切底明白ThreadLocal的原理与使用</a><h3 id="synchronized底层实现原理"><a href="#synchronized底层实现原理" class="headerlink" title="synchronized底层实现原理"></a>synchronized底层实现原理</h3><a href="https://blog.csdn.net/weixin_43213517/article/details/89713899" target="_blank" rel="noopener">synchronized的底层实现原理及各种优化</a><h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3></li>
<li>volatile本质是告诉jvm当前变量在寄存器（工作主存）中的值是不确定的，需要从主存中去读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。</li>
<li>volatile只能使用在变量级别；synchronized可以使用在变量、方法和类级别。</li>
<li>volatile仅能实现变量修改的可见性，不保证原子性；synchronized可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程堵塞；synchronized可能会造成堵塞</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。<h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3></li>
<li>sy是java的内置关键字，在jvm层面，而lock是个类</li>
<li>sy会自动释放锁（执行完成释放锁或者执行中发生异常会释放锁）；lock需要手工在finally中释放，否则容易死锁。</li>
<li>用synchronized关键字，两个线程，线程1获得锁，线程而等待；若是线程1阻塞，线程2会一直等下去，而Lock可以让等待锁的线程响应中断。</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。<br><a href="https://blog.csdn.net/suchahaerkang/article/details/80456085" target="_blank" rel="noopener">干货：synchronized和volatile的区别</a><h3 id="synchronized和Reentrantlock的区别"><a href="#synchronized和Reentrantlock的区别" class="headerlink" title="synchronized和Reentrantlock的区别"></a>synchronized和Reentrantlock的区别</h3>sy是关键字，后者是类，提供了比sy更加灵活的特性</li>
<li>可以对获取锁的等待时间进行设置，这样就避免了死锁。</li>
<li>可以获取各种的锁信息。</li>
<li>可以灵活的实现多路通知。<br><a href="https://blog.csdn.net/zheng548/article/details/54426947" target="_blank" rel="noopener">synchronized和Reentrantlock的区别</a><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。<h1 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3>aop面向切面编程，面向对象的补充和完善（oop），oop通过引入封装继承多态等来建立一种对象层次结构，用以模拟公共行为的一个集合，当我们需要为这些分散的对象引入共公共行为的时候，oop显得无能为力。oop适合定义从上到下的关系，不适合从左到右的关系，例如日志功能，日志代码往往水平的分散在所有对象层次中，而且与它分布到的对象的核心功能毫无关系，这种被散布在各种无关处的代码称为横切代码，在oop中，它导致了大量代码的冗余，而不利于模块的重用。<br>而aop技术它是利用一种成为横切的技术，剖解开封装的对象的内部，并将那些影响了多个类的公共行为封装到一个可重用的模块中，并将其命名为“Aspect”，即方面。简单来说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于为来的可操作性和可维护性。<br>aop的核心思想就是：将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。<h3 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h3>ioc最早在一篇探讨面向对象的框架的文章中提出。对于面向对象，就是吧复杂的系统分解成相互合作的对象，这些对象通过封装以后，内部实现对外部是透明的，从而降低的解决问题的复杂度，而且可以重用和拓展。<br>IOC是借助于“第三方”实现具有依赖关系的对象之间的解耦，全部对象的控制权全部交给ioc容器，起到一种粘合剂的作用，当去掉ioc容器后，就是要实现的全部内容，对象之间的关系已经没有了耦合关系，每一成员只需要实现自己的类就可以了。<br>在没有引入ioc之前，对象A要调用B，A必须要主动的去创建B，控制权都在自己手上。引入ioc后，由于ioc的注入，A与B失去直接联系，当A运行中需要使用对象B时，ioc会会主动去创建一个B到A需要的地方。<br>对象A获得依赖对象B的过程，由主动行为变为被动行为，控制权点到过来，这就是“控制反转”.<h2 id="web基础"><a href="#web基础" class="headerlink" title="web基础"></a>web基础</h2><h3 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h3><blockquote>
<p>1.分给顾客一张卡片，每消费一次记录一次；</p>
</blockquote>
</li>
</ul>
<p>2.发给顾客一张卡片，上面有卡号，顾客每消费一次，由店员在操作机上记录一次。<br>分析： 方案1和2正是对应的客户端记录和服务端记录。与之相对应的正是cookie和session。 </p>
<h3 id="session工作原理"><a href="#session工作原理" class="headerlink" title="session工作原理"></a>session工作原理</h3><p>session类似于独立于服务器上的一个散列表格文件，像一个map，键值存的是用户的sessionid，用户向服务器发送请求时会带上这个sessionid，去除value。<br>禁止cookie之后session不能使用，session需要sessionid来确定当前对话所对应服务器的session，而sessionid是通过cookie传递的。</p>
<h3 id="jsp和servlet的区别"><a href="#jsp和servlet的区别" class="headerlink" title="jsp和servlet的区别"></a>jsp和servlet的区别</h3><ol>
<li><p>sp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</p>
</li>
<li><p>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</p>
</li>
<li><p>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</p>
</li>
<li><p>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2></li>
<li><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p>
</li>
<li><p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p>
</li>
<li><p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2></li>
<li><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
</li>
<li><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="b-树"><a href="#b-树" class="headerlink" title="b+树"></a>b+树</h3><p><a href="https://blog.csdn.net/qq_26222859/article/details/80631121" target="_blank" rel="noopener">https://blog.csdn.net/qq_26222859/article/details/80631121</a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>为搜索字段设置索引</li>
<li>避免使用select * ，列出需要查询的字段</li>
<li>垂直分割分表</li>
<li>选择正确的存储引擎<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> died=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(died&lt;n)</span><br><span class="line">    {</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)   <span class="comment">//暴力循环</span></span><br><span class="line">            i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)   <span class="comment">//没有死亡  则报数</span></span><br><span class="line">            num++;</span><br><span class="line">        <span class="keyword">if</span>(num==m)     <span class="comment">//当前人死亡 则清零重新开始</span></span><br><span class="line">        {</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            ++died;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;died&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2></li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">      <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//以第i个数为结尾的最长上升子序列和</span></span><br><span class="line">      {</span><br><span class="line">          max=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">          {</span><br><span class="line">              <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">              {</span><br><span class="line">                  <span class="keyword">if</span>(sum[j]&gt;max)<span class="comment">//搜索左端最大上升子序列和</span></span><br><span class="line">                      max=sum[j];</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      sum[i]+=max;</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="筛素数"><a href="#筛素数" class="headerlink" title="筛素数"></a>筛素数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Aila</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//埃氏筛法，线性筛</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        {</span><br><span class="line">            prime[k++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;n;j+=i)</span><br><span class="line">            {</span><br><span class="line">                vis[j]=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Oula</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//欧拉筛法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            prime[k++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k&amp;&amp;i*prime[j]&lt;n;j++)</span><br><span class="line">        {</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="comment">//此保证了合数只会被他的最小质因数筛掉，当i是prime[j]的整数倍时，i*prime[j+1]肯定被筛过，跳出循环。因为i可以看做prime[j]*某个数， i*prime[j+1]就可以看做 prime[j]*某个数*prime[j+1] 。而 prime[j] 必定小于 prime[j+1]，</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陳 ？</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://raptor1998.top/2020/03/12/%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">http://raptor1998.top/2020/03/12/%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://raptor1998.top">raptor's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">面试总结    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/2222.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/JavaEE/zhifubao.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/01/Spring5/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210414153515.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Spring Review</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/10/Java%E4%B8%AD%E7%9A%84String%E7%B1%BB/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/JavaEE/program.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java中的String类</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODEyMS8yNDYxOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 陳 ？</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">show me the code</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/ClickShowText.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>