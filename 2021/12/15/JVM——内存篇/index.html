<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>JVM——内存篇 | raptor's blog</title><meta name="description" content="JVM"><meta name="keywords" content="JVM"><meta name="author" content="陳 ？"><meta name="copyright" content="陳 ？"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM——内存篇"><meta name="twitter:description" content="JVM"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JVM——内存篇"><meta property="og:url" content="http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/"><meta property="og:site_name" content="raptor's blog"><meta property="og:description" content="JVM"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/"><link rel="prev" title="JVM——垃圾回收篇" href="http://raptor1998.top/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><link rel="next" title="高频面试 Ι" href="http://raptor1998.top/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0b50707a55dfca710ef66e4071fa22cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://raptor1998.top/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"高大威猛,英俊潇洒,智勇双全,器宇不凡,风流倜傥,玉树临风,成熟稳重,风趣幽默,举世无双,绝无仅有,空前绝后,独一无二,前无古人,后无来者,只此一家,别无分店","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="raptor's blog" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">raptor's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 日常</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> MV</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/20200102090650.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 日常</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> MV</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#内存篇"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">内存篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类加载子系统"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">类加载子系统</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类加载子系统的作用"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">类加载子系统的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类的加载过程"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">类的加载过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#虚拟机自带的加载器"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">虚拟机自带的加载器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><span class="toc_mobile_items-number">1.1.3.1.</span> <span class="toc_mobile_items-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#扩展类加载器（Extension-ClassLoader）"><span class="toc_mobile_items-number">1.1.3.2.</span> <span class="toc_mobile_items-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#应用程序类加载器（系统类加载器，AppClassLoader）"><span class="toc_mobile_items-number">1.1.3.3.</span> <span class="toc_mobile_items-text">应用程序类加载器（系统类加载器，AppClassLoader）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#双亲委派机制"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">双亲委派机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#工作原理"><span class="toc_mobile_items-number">1.1.4.1.</span> <span class="toc_mobile_items-text">工作原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#如何判断两个class对象是否相同"><span class="toc_mobile_items-number">1.1.4.2.</span> <span class="toc_mobile_items-text">如何判断两个class对象是否相同</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#运行时数据区"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">运行时数据区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#程序计数器"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">程序计数器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#概念"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#QA"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">QA</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#使用PC寄存器存储字节码指令地址有什么用呢？"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">使用PC寄存器存储字节码指令地址有什么用呢？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#PC寄存器为什么被设定为私有的？"><span class="toc_mobile_items-number">1.3.2.2.</span> <span class="toc_mobile_items-text">PC寄存器为什么被设定为私有的？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#CPU时间片"><span class="toc_mobile_items-number">1.3.2.3.</span> <span class="toc_mobile_items-text">CPU时间片</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟机栈"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">虚拟机栈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#栈中可能出现的异常"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">栈中可能出现的异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#栈运行原理"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">栈运行原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#栈帧的内部结构"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">栈帧的内部结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#局部变量表"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">局部变量表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Slot的重复利用"><span class="toc_mobile_items-number">1.4.4.1.</span> <span class="toc_mobile_items-text">Slot的重复利用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#操作数栈"><span class="toc_mobile_items-number">1.4.5.</span> <span class="toc_mobile_items-text">操作数栈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#i-和-i的区别"><span class="toc_mobile_items-number">1.4.5.1.</span> <span class="toc_mobile_items-text">i++和++i的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#栈的相关面试题"><span class="toc_mobile_items-number">1.4.6.</span> <span class="toc_mobile_items-text">栈的相关面试题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#本地方法接口"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">本地方法接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#本地方法栈"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">本地方法栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">堆</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#堆的核心概念"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">堆的核心概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#堆内存细分"><span class="toc_mobile_items-number">1.7.1.1.</span> <span class="toc_mobile_items-text">堆内存细分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置堆内存大小与OOM"><span class="toc_mobile_items-number">1.7.1.2.</span> <span class="toc_mobile_items-text">设置堆内存大小与OOM</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#年轻代与老年代"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">年轻代与老年代</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#对象分配过程"><span class="toc_mobile_items-number">1.7.3.</span> <span class="toc_mobile_items-text">对象分配过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#概念-1"><span class="toc_mobile_items-number">1.7.3.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#幸存者区空间不足"><span class="toc_mobile_items-number">1.7.3.2.</span> <span class="toc_mobile_items-text">幸存者区空间不足</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#特殊情况"><span class="toc_mobile_items-number">1.7.3.3.</span> <span class="toc_mobile_items-text">特殊情况</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Minor-GC，MajorGC、Full-GC"><span class="toc_mobile_items-number">1.7.4.</span> <span class="toc_mobile_items-text">Minor GC，MajorGC、Full GC</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Minor-GC"><span class="toc_mobile_items-number">1.7.4.1.</span> <span class="toc_mobile_items-text">Minor GC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Major-GC"><span class="toc_mobile_items-number">1.7.4.2.</span> <span class="toc_mobile_items-text">Major GC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Full-GC"><span class="toc_mobile_items-number">1.7.4.3.</span> <span class="toc_mobile_items-text">Full GC</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内存分配策略"><span class="toc_mobile_items-number">1.7.5.</span> <span class="toc_mobile_items-text">内存分配策略</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为对象分配内存：TLAB"><span class="toc_mobile_items-number">1.7.6.</span> <span class="toc_mobile_items-text">为对象分配内存：TLAB</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Q-堆空间都是共享的吗"><span class="toc_mobile_items-number">1.7.6.1.</span> <span class="toc_mobile_items-text">Q: 堆空间都是共享的吗</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为什么有TLAB"><span class="toc_mobile_items-number">1.7.6.2.</span> <span class="toc_mobile_items-text">为什么有TLAB</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#什么是TLAB"><span class="toc_mobile_items-number">1.7.6.3.</span> <span class="toc_mobile_items-text">什么是TLAB</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#TLAB分配过程"><span class="toc_mobile_items-number">1.7.6.4.</span> <span class="toc_mobile_items-text">TLAB分配过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#堆空间的参数设置"><span class="toc_mobile_items-number">1.7.7.</span> <span class="toc_mobile_items-text">堆空间的参数设置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#堆是分配对象的唯一选择么？"><span class="toc_mobile_items-number">1.7.8.</span> <span class="toc_mobile_items-text">堆是分配对象的唯一选择么？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#逃逸分析"><span class="toc_mobile_items-number">1.7.8.1.</span> <span class="toc_mobile_items-text">逃逸分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#代码优化"><span class="toc_mobile_items-number">1.7.8.1.1.</span> <span class="toc_mobile_items-text">代码优化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#栈上分配"><span class="toc_mobile_items-number">1.7.8.2.</span> <span class="toc_mobile_items-text">栈上分配</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#方法区"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">方法区</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JDK8以后"><span class="toc_mobile_items-number">1.8.1.</span> <span class="toc_mobile_items-text">JDK8以后</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何解决方法区的OOM"><span class="toc_mobile_items-number">1.8.2.</span> <span class="toc_mobile_items-text">如何解决方法区的OOM</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#non-final的类变量"><span class="toc_mobile_items-number">1.8.3.</span> <span class="toc_mobile_items-text">non-final的类变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法区的演变"><span class="toc_mobile_items-number">1.8.4.</span> <span class="toc_mobile_items-text">方法区的演变</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为什么永久代要被元空间替代？"><span class="toc_mobile_items-number">1.8.4.1.</span> <span class="toc_mobile_items-text">为什么永久代要被元空间替代？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法区的垃圾回收"><span class="toc_mobile_items-number">1.8.5.</span> <span class="toc_mobile_items-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象实例化内存布局与访问定位"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">对象实例化内存布局与访问定位</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建对象的步骤"><span class="toc_mobile_items-number">1.9.1.</span> <span class="toc_mobile_items-text">创建对象的步骤</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#判断对象对应的类是否加载、链接、初始化"><span class="toc_mobile_items-number">1.9.1.1.</span> <span class="toc_mobile_items-text">判断对象对应的类是否加载、链接、初始化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为对象分配内存"><span class="toc_mobile_items-number">1.9.1.2.</span> <span class="toc_mobile_items-text">为对象分配内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#处理并发问题"><span class="toc_mobile_items-number">1.9.1.3.</span> <span class="toc_mobile_items-text">处理并发问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#初始化分配到的内存"><span class="toc_mobile_items-number">1.9.1.4.</span> <span class="toc_mobile_items-text">初始化分配到的内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置对象的对象头"><span class="toc_mobile_items-number">1.9.1.5.</span> <span class="toc_mobile_items-text">设置对象的对象头</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#执行init方法进行初始化"><span class="toc_mobile_items-number">1.9.1.6.</span> <span class="toc_mobile_items-text">执行init方法进行初始化</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#String"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">String</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#String的基本特性"><span class="toc_mobile_items-number">1.10.1.</span> <span class="toc_mobile_items-text">String的基本特性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#JDK9改变了结构"><span class="toc_mobile_items-number">1.10.1.1.</span> <span class="toc_mobile_items-text">JDK9改变了结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#String的不可变性"><span class="toc_mobile_items-number">1.10.1.2.</span> <span class="toc_mobile_items-text">String的不可变性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#String的内存分配"><span class="toc_mobile_items-number">1.10.2.</span> <span class="toc_mobile_items-text">String的内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为什么StringTable从永久代调整到堆中"><span class="toc_mobile_items-number">1.10.2.1.</span> <span class="toc_mobile_items-text">为什么StringTable从永久代调整到堆中</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拼接操作"><span class="toc_mobile_items-number">1.10.3.</span> <span class="toc_mobile_items-text">拼接操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拼接操作和append性能对比"><span class="toc_mobile_items-number">1.10.4.</span> <span class="toc_mobile_items-text">拼接操作和append性能对比</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#intern"><span class="toc_mobile_items-number">1.10.5.</span> <span class="toc_mobile_items-text">intern()</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#new-String-“as”-会创建几个对象"><span class="toc_mobile_items-number">1.10.5.1.</span> <span class="toc_mobile_items-text">new String(“as”)会创建几个对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#new-String-“a”-new-String-“b”-会创建几个对象"><span class="toc_mobile_items-number">1.10.5.2.</span> <span class="toc_mobile_items-text">new String(“a”) + new String(“b”) 会创建几个对象</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#美团：深入解析String-intern"><span class="toc_mobile_items-number">1.10.6.</span> <span class="toc_mobile_items-text">美团：深入解析String#intern</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#intern题目"><span class="toc_mobile_items-number">1.10.7.</span> <span class="toc_mobile_items-text">intern题目</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#相关工具"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">相关工具</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#idea安装jclasslib"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">idea安装jclasslib</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Notepad-字节码"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Notepad++字节码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#VisualVM插件GC安装"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">VisualVM插件GC安装</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#推荐笔记"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">推荐笔记</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#内存篇"><span class="toc-number">1.</span> <span class="toc-text">内存篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载子系统"><span class="toc-number">1.1.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载子系统的作用"><span class="toc-number">1.1.1.</span> <span class="toc-text">类加载子系统的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载过程"><span class="toc-number">1.1.2.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机自带的加载器"><span class="toc-number">1.1.3.</span> <span class="toc-text">虚拟机自带的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展类加载器（Extension-ClassLoader）"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用程序类加载器（系统类加载器，AppClassLoader）"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">应用程序类加载器（系统类加载器，AppClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">1.1.4.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判断两个class对象是否相同"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">如何判断两个class对象是否相同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区"><span class="toc-number">1.2.</span> <span class="toc-text">运行时数据区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器"><span class="toc-number">1.3.</span> <span class="toc-text">程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QA"><span class="toc-number">1.3.2.</span> <span class="toc-text">QA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用PC寄存器存储字节码指令地址有什么用呢？"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">使用PC寄存器存储字节码指令地址有什么用呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PC寄存器为什么被设定为私有的？"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">PC寄存器为什么被设定为私有的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU时间片"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">1.4.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈中可能出现的异常"><span class="toc-number">1.4.1.</span> <span class="toc-text">栈中可能出现的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈运行原理"><span class="toc-number">1.4.2.</span> <span class="toc-text">栈运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧的内部结构"><span class="toc-number">1.4.3.</span> <span class="toc-text">栈帧的内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量表"><span class="toc-number">1.4.4.</span> <span class="toc-text">局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot的重复利用"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Slot的重复利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数栈"><span class="toc-number">1.4.5.</span> <span class="toc-text">操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i-和-i的区别"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">i++和++i的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的相关面试题"><span class="toc-number">1.4.6.</span> <span class="toc-text">栈的相关面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法接口"><span class="toc-number">1.5.</span> <span class="toc-text">本地方法接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈"><span class="toc-number">1.6.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-number">1.7.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#堆的核心概念"><span class="toc-number">1.7.1.</span> <span class="toc-text">堆的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#堆内存细分"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">堆内存细分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置堆内存大小与OOM"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">设置堆内存大小与OOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#年轻代与老年代"><span class="toc-number">1.7.2.</span> <span class="toc-text">年轻代与老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象分配过程"><span class="toc-number">1.7.3.</span> <span class="toc-text">对象分配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念-1"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#幸存者区空间不足"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">幸存者区空间不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊情况"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">特殊情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC，MajorGC、Full-GC"><span class="toc-number">1.7.4.</span> <span class="toc-text">Minor GC，MajorGC、Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Minor-GC"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">Minor GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Major-GC"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">Major GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配策略"><span class="toc-number">1.7.5.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为对象分配内存：TLAB"><span class="toc-number">1.7.6.</span> <span class="toc-text">为对象分配内存：TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-堆空间都是共享的吗"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">Q: 堆空间都是共享的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么有TLAB"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">为什么有TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是TLAB"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">什么是TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB分配过程"><span class="toc-number">1.7.6.4.</span> <span class="toc-text">TLAB分配过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆空间的参数设置"><span class="toc-number">1.7.7.</span> <span class="toc-text">堆空间的参数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆是分配对象的唯一选择么？"><span class="toc-number">1.7.8.</span> <span class="toc-text">堆是分配对象的唯一选择么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逃逸分析"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#代码优化"><span class="toc-number">1.7.8.1.1.</span> <span class="toc-text">代码优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈上分配"><span class="toc-number">1.7.8.2.</span> <span class="toc-text">栈上分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">1.8.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8以后"><span class="toc-number">1.8.1.</span> <span class="toc-text">JDK8以后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决方法区的OOM"><span class="toc-number">1.8.2.</span> <span class="toc-text">如何解决方法区的OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-final的类变量"><span class="toc-number">1.8.3.</span> <span class="toc-text">non-final的类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的演变"><span class="toc-number">1.8.4.</span> <span class="toc-text">方法区的演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么永久代要被元空间替代？"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">为什么永久代要被元空间替代？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的垃圾回收"><span class="toc-number">1.8.5.</span> <span class="toc-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象实例化内存布局与访问定位"><span class="toc-number">1.9.</span> <span class="toc-text">对象实例化内存布局与访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象的步骤"><span class="toc-number">1.9.1.</span> <span class="toc-text">创建对象的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#判断对象对应的类是否加载、链接、初始化"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">判断对象对应的类是否加载、链接、初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为对象分配内存"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">为对象分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理并发问题"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">处理并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化分配到的内存"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">初始化分配到的内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置对象的对象头"><span class="toc-number">1.9.1.5.</span> <span class="toc-text">设置对象的对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行init方法进行初始化"><span class="toc-number">1.9.1.6.</span> <span class="toc-text">执行init方法进行初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.10.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String的基本特性"><span class="toc-number">1.10.1.</span> <span class="toc-text">String的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK9改变了结构"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">JDK9改变了结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String的不可变性"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">String的不可变性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的内存分配"><span class="toc-number">1.10.2.</span> <span class="toc-text">String的内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么StringTable从永久代调整到堆中"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">为什么StringTable从永久代调整到堆中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接操作"><span class="toc-number">1.10.3.</span> <span class="toc-text">拼接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接操作和append性能对比"><span class="toc-number">1.10.4.</span> <span class="toc-text">拼接操作和append性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern"><span class="toc-number">1.10.5.</span> <span class="toc-text">intern()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-String-“as”-会创建几个对象"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">new String(“as”)会创建几个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-String-“a”-new-String-“b”-会创建几个对象"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">new String(“a”) + new String(“b”) 会创建几个对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#美团：深入解析String-intern"><span class="toc-number">1.10.6.</span> <span class="toc-text">美团：深入解析String#intern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern题目"><span class="toc-number">1.10.7.</span> <span class="toc-text">intern题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相关工具"><span class="toc-number">2.</span> <span class="toc-text">相关工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#idea安装jclasslib"><span class="toc-number">2.1.</span> <span class="toc-text">idea安装jclasslib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notepad-字节码"><span class="toc-number">2.2.</span> <span class="toc-text">Notepad++字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VisualVM插件GC安装"><span class="toc-number">2.3.</span> <span class="toc-text">VisualVM插件GC安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#推荐笔记"><span class="toc-number">3.</span> <span class="toc-text">推荐笔记</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">JVM——内存篇</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2021-12-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2022-02-24</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">13.9k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 44 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="内存篇"><a href="#内存篇" class="headerlink" title="内存篇"></a>内存篇</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705081813409" class="fancybox"><img alt="image-20200705081813409" title="image-20200705081813409" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224171950.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<ul>
<li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p>
</li>
<li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>
</li>
<li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172000.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<ul>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705082255746" class="fancybox"><img alt="image-20200705082255746" title="image-20200705082255746" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>完整的流程图如下所示</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705082601441" class="fancybox"><img alt="image-20200705082601441" title="image-20200705082601441" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172009.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul>
<li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705103636003" class="fancybox"><img alt="image-20200705103636003" title="image-20200705103636003" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172018.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己创建一个java.lang的包并创建String类</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"自定义的String类"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">   public static void main(String[] args)</span></span><br><span class="line"><span class="comment">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">	自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div>

<h4 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>
</ul>
<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705112416101" class="fancybox"><img alt="image-20200705112416101" title="image-20200705112416101" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172759.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705112601211" class="fancybox"><img alt="image-20200705112601211" title="image-20200705112601211" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172754.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>
<p><strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172027.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h4><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200705161409533" class="fancybox"><img alt="image-20200705161409533" title="image-20200705161409533" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172029.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h4 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h4><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>栈是运行时的单位，而堆是存储的单位。</strong></p>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。<strong>是线程私有的。</strong></p>
<h3 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h3><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p>
<p><strong>可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211228155503154" class="fancybox"><img alt="image-20211228155503154" title="image-20211228155503154" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172033.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172036.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p>
<p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211228195446901" class="fancybox"><img alt="image-20211228195446901" title="image-20211228195446901" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172039.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</strong></p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211229144922052" class="fancybox"><img alt="image-20211229144922052" title="image-20211229144922052" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172041.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><p><a href="https://blog.csdn.net/weixin_43723712/article/details/92187693" target="_blank" rel="noopener">i++与++i在JVM层面上的分析</a></p>
<p><a href="https://blog.csdn.net/weixin_38405253/article/details/118470431" target="_blank" rel="noopener">从JVM层面来解释i++和++i的真正区别</a></p>
<h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><ul>
<li><p>举例栈溢出的情况？（StackOverflowError）</p>
<ul>
<li>通过 -Xss设置栈的大小</li>
</ul>
</li>
<li><p>调整栈大小，就能保证不出现溢出么？</p>
<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li><p>分配的栈内存越大越好么？</p>
<ul>
<li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li><p>垃圾回收是否涉及到虚拟机栈？</p>
<ul>
<li>不会</li>
</ul>
</li>
<li><p>方法中定义的局部变量是否线程安全？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>{</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ul>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p>一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
<p>本地方法是使用C语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h3><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>
<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Permanent Space永久区 Perm</li>
</ul>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>
<ul>
<li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Meta Space 元空间 Meta</li>
</ul>
<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>
<h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。  </p>
<p><strong>-Xms300m -Xmx300m -XX:+PrintGCDetails</strong></p>
<p><strong>设置为300M却不足，是因为幸存区只能有一个用来存储。</strong>  </p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211230203337495" class="fancybox"><img alt="image-20211230203337495" title="image-20211230203337495" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172734.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>
<li>生命周期短的，及时回收即可</li>
</ul>
</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707075847954" class="fancybox"><img alt="image-20200707075847954" title="image-20200707075847954" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172046.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p> 配置新生代与老年代在堆结构的占比。</p>
<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707080154039" class="fancybox"><img alt="image-20200707080154039" title="image-20200707080154039" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172701.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<blockquote>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p>
<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<blockquote>
<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>
<p>这个参数一般使用默认值就可以了。</p>
</blockquote>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ul>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ul>
<p>可以设置参数：<strong>-Xx:MaxTenuringThreshold= N</strong>进行设置</p>
<p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707084714886" class="fancybox"><img alt="image-20200707084714886" title="image-20200707084714886" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172053.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707085737207" class="fancybox"><img alt="image-20200707085737207" title="image-20200707085737207" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172653.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h4 id="幸存者区空间不足"><a href="#幸存者区空间不足" class="headerlink" title="幸存者区空间不足"></a>幸存者区空间不足</h4><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707091058346" class="fancybox"><img alt="image-20200707091058346" title="image-20200707091058346" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172549.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><ul>
<li><p>Minor GC：新生代的GC</p>
</li>
<li><p>Major GC：老年代的GC</p>
</li>
<li><p>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
</li>
</ul>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>
<li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul>
<li>目前，只有CMSGC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>
<h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>
<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>
<h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>
</ul>
<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>触发FullGC执行的情况有如下五种：</p>
<ul>
<li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
</ul>
</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
</ul>
<p>空间分配担保： -Xx:HandlePromotionFailure</p>
<ul>
<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>
</ul>
<h3 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h3><h4 id="Q-堆空间都是共享的吗"><a href="#Q-堆空间都是共享的吗" class="headerlink" title="Q: 堆空间都是共享的吗"></a>Q: 堆空间都是共享的吗</h4><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>
<h4 id="为什么有TLAB"><a href="#为什么有TLAB" class="headerlink" title="为什么有TLAB"></a>为什么有TLAB</h4><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<h4 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h4><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707103547712" class="fancybox"><img alt="image-20200707103547712" title="image-20200707103547712" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172532.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>
<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<h4 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h4><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200707104253530" class="fancybox"><img alt="image-20200707104253530" title="image-20200707104253530" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172104.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h3 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h3><ul>
<li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li>
<li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li>
<li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li>
<li>-Xmn：设置新生代的大小。（初始值及最大值）</li>
<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li>
<li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX：+PrintGCDetails：输出详细的GC处理日志<ul>
<li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li>
</ul>
</li>
<li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li>
</ul>
<h3 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBufferON</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果想要StringBuffer sb不发生逃逸，可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBufferOFF</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h5 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h5><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ul>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p>
<p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>
<h3 id="如何解决方法区的OOM"><a href="#如何解决方法区的OOM" class="headerlink" title="如何解决方法区的OOM"></a>如何解决方法区的OOM</h3><ul>
<li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul>
<li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
</ul>
</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ul>
<h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li>
</ul>
<h3 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h3><table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>有永久代，静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody></table>
<p>JDK6的时候</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200708211541300" class="fancybox"><img alt="image-20200708211541300" title="image-20200708211541300" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172108.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>JDK7的时候</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200708211609911" class="fancybox"><img alt="image-20200708211609911" title="image-20200708211609911" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172521.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p>JDK8的时候，元空间大小只受物理内存影响</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200708211637952" class="fancybox"><img alt="image-20200708211637952" title="image-20200708211637952" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172323.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h4 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h4><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。</li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li>对永久代进行调优是很困难的。<ul>
<li>主要是为了降低Full GC</li>
</ul>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h2 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h2><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>
<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<ul>
<li>如果内存规整：指针碰撞</li>
<li>如果内存不规整<ul>
<li>虚拟表需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul>
<li>在Eden区给每个线程分配一块区域</li>
</ul>
</li>
</ul>
<h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>给对象属性赋值的操作</p>
<ul>
<li>属性的默认初始化</li>
<li>显示初始化</li>
<li>代码块中的初始化</li>
<li>构造器初始化</li>
<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
</ul>
<h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul>
<li>String：字符串，使用一对 ”” 引起来表示<ul>
<li>String s1 = “mogublog” ; // 字面量的定义方式</li>
<li>String s2 = new String(“moxi”);</li>
</ul>
</li>
<li>string声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li>
<li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li>
</ul>
<h4 id="JDK9改变了结构"><a href="#JDK9改变了结构" class="headerlink" title="JDK9改变了结构"></a>JDK9改变了结构</h4><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p>
<p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p>
<p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">private final char value[];</span><br><span class="line">// 之后</span><br><span class="line">private final byte[] value</span><br></pre></td></tr></tbody></table></figure></div>

<p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p>
<h4 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h4><p>String：代表不可变的字符序列。简称：不可变性。</p>
<blockquote>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">"def"</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>{</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">'a'</span>, <span class="string">'m'</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//hello</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//abcdef</span></span><br><span class="line">        <span class="comment">//----------------</span></span><br><span class="line">        <span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//mbc</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>{</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = {<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>{</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);   <span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);    <span class="comment">//best</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h3><p>Java 6及以前，字符串常量池存放在永久代</p>
<p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
<blockquote>
<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
<p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p>
</blockquote>
<p>Java8元空间，字符串常量在堆</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200711093546398" class="fancybox"><img alt="image-20200711093546398" title="image-20200711093546398" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172314.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20200711093558709" class="fancybox"><img alt="image-20200711093558709" title="image-20200711093558709" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172309.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h4 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h4><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p>
<ul>
<li>永久代的默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<h3 id="拼接操作"><a href="#拼接操作" class="headerlink" title="拼接操作"></a>拼接操作</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String s1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;  <span class="comment">// 得到 abc的常量池</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>; <span class="comment">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true，因为存放在字符串常量池</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    String src = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        src += <span class="string">"a"</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>{</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) {</span><br><span class="line">        sb.append(<span class="string">"a"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p>
<p>结论：</p>
<ul>
<li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li>
</ul>
<p>好处</p>
<ul>
<li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li>
<li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li>
<li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li>
</ul>
<p>改进的空间</p>
<ul>
<li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li>
<li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li>
</ul>
<h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><h4 id="new-String-“as”-会创建几个对象"><a href="#new-String-“as”-会创建几个对象" class="headerlink" title="new String(“as”)会创建几个对象"></a>new String(“as”)会创建几个对象</h4><ul>
<li>一个对象是：new关键字在堆空间中创建</li>
<li>另一个对象：字符串常量池中的对象</li>
</ul>
<h4 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h4><ul>
<li>对象1：new StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池的 a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池的 b</li>
<li>对象6：toString中会创建一个 new String(“ab”)<ul>
<li>调用toString方法，不会在常量池中生成ab</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_44259720/article/details/88237822" target="_blank" rel="noopener">Java 定义字符串时：String 和 new String() 的区别</a></p>
<h3 id="美团：深入解析String-intern"><a href="#美团：深入解析String-intern" class="headerlink" title="美团：深入解析String#intern"></a><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团：深入解析String#intern</a></h3><h3 id="intern题目"><a href="#intern题目" class="headerlink" title="intern题目"></a>intern题目</h3><p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20220107101214463" class="fancybox"><img alt="image-20220107101214463" title="image-20220107101214463" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172259.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20220107101237047" class="fancybox"><img alt="image-20220107101237047" title="image-20220107101237047" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172254.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20220107101245959" class="fancybox"><img alt="image-20220107101245959" title="image-20220107101245959" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="idea安装jclasslib"><a href="#idea安装jclasslib" class="headerlink" title="idea安装jclasslib"></a>idea安装jclasslib</h2><p>选中字节码文件，view中show With Jclasslib即可查看字节码指令</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211227170720770" class="fancybox"><img alt="image-20211227170720770" title="image-20211227170720770" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172248.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h2 id="Notepad-字节码"><a href="#Notepad-字节码" class="headerlink" title="Notepad++字节码"></a>Notepad++字节码</h2><p><a href="https://github.com/chcg/NPP_HexEdit/releases/tag/0.9.5.11" target="_blank" rel="noopener">HexEdit下载地址</a></p>
<p>下载对应版本的dll文件，在notepad++插件文件夹创建HexEdit文件夹，将解压的dll文件放入，重启即可。</p>
<p><a href="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image-20211227170551121" class="fancybox"><img alt="image-20211227170551121" title="image-20211227170551121" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20220224172215.png" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/loading.gif" class="lazyload"></a></p>
<h2 id="VisualVM插件GC安装"><a href="#VisualVM插件GC安装" class="headerlink" title="VisualVM插件GC安装"></a>VisualVM插件GC安装</h2><p><a href="https://blog.csdn.net/weixin_45759791/article/details/107332860" target="_blank" rel="noopener">VisualVM安装VisualGC插件</a></p>
<p> <a href="https://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">Plugins Centers 插件中心</a></p>
<h1 id="推荐笔记"><a href="#推荐笔记" class="headerlink" title="推荐笔记"></a>推荐笔记</h1><p> <strong><a href="https://gitee.com/moxi159753" target="_blank" rel="noopener">陌溪</a> / <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">LearningNotes</a></strong></p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陳 ？</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/">http://raptor1998.top/2021/12/15/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://raptor1998.top">raptor's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/2222.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/JavaEE/zhifubao.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/01/20/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>JVM——垃圾回收篇</span></div></a></div><div class="next-post pull_right"><a href="/2021/11/08/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E4%B8%80/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/raptor1998/imghouse/untidy/joker1.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/raptor1998/imghouse/raptor1998_img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>高频面试 Ι</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/01/20/JVM——垃圾回收篇/" title="JVM——垃圾回收篇"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-08-15</div><div class="relatedPosts_title">JVM——垃圾回收篇</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODEyMS8yNDYxOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Raptor1998/imghouse/untidy/20210722092259.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By 陳 ？</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">show me the code</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/ClickShowText.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>